==== _concat/project_structure-MatheMagicApp.text ====

- MatheMagicApp
  - Info.plist
  - Brain-Old
    - BrainAnimationSequence.swift
    - IdleToIdle.swift
    - IdleToWalk.swift
    - WalkToWalk.swift
  - Components
    - CameraRotationComponent.swift
    - MoveComponent.swift
    - RealityViewExtensions.swift
    - TapComponent.swift
  - Entities
    - EntityEntries.swift
  - Environment
    - SkyboxUtilities.swift
  - Game Engine
    - GameMachineStates.swift
    - GlobalEntities.swift
    - PlayData.swift
  - Load
    - PreLoadAssets.swift
  - AI
    - MatheMagicAIConfig.swift
    - AIEndpointConfig.swift
    - FlashAIEmoteCatalog.swift
    - FlashAIIdleEmoteCatalog.swift
    - MatheMagicAIContract.swift
    - MatheMagicAIEventPipeline.swift
    - MatheMagicAICharacterDialoguePipeline.swift
    - MatheMagicAIService.swift
    - AIDebugState.swift
  - Top-Level
    - AppState.swift
    - ContentView.swift
    - GameModel.swift
    - GameModelView.swift
    - CharacterDialogueState.swift
    - ImmersiveVew.swift
    - RealityTextInputState.swift
    - MatheMagicApp.swift
  - Utilities
    - ExtensionsEntity.swift
    - LocalUtilities.swift
  - Views
    - AnimationDebugHUDOverlayView.swift
    - AIResponseHUDView.swift
    - CharacterDialogueBubbleView.swift
    - RealityTextInputOverlayView.swift
    - BallView.swift
    - CustomButtonStyle.swift
    - GameOver.swift
    - Lobby.swift
    - Play.swift
    - Scene Functions
      - SceneManager.swift
      - setupCharacterWithComponents.swift
    - Selection.swift
    - Start.swift

==== _concat/project_structure-AILib.text ====

- AILibS
  - ClassifierKit
    - AIJSONContract.swift
    - AIJSONRunModels.swift
    - AILibConnection.swift
    - ClassifierError.swift
    - ClassifierKitLogger.swift
    - ClassifierRunner.swift
    - JSONSchema.swift
    - JSONSchemaValidator.swift
    - JSONValue.swift
    - MCQFilledResponse.swift
    - MCQKey.swift
    - MCQSchemaBuilder.swift
    - MCQTemplate.swift
    - ModelOutputJSONExtractor.swift
    - OllamaChatModels.swift
    - OllamaClient.swift
    - OllamaEndpointParser.swift
    - OllamaJSONFiller.swift
    - PromptBuilder.swift
    - SchemaPromptBuilder.swift
    - StrictJSONPromptBuilder.swift

==== _concat/project_structure-AnimLib.text ====

- AnimLibS
  - AnimationTransforms
    - PlayTransforms.swift
    - Transforms-To-Play
      - 0-TransformsToPlay.swift
      - 1-orig-data.swift
      - 2-Alterations Data Functions
        - cirWalk-data.swift
        - matchTransform-data.swift
        - stride-data.swift
      - 2-apply-alterations-pre-blend.swift
      - 3-blend-elments-in-tree.swift
      - 4-inertial-data.swift
  - AnimationTranstions
    - Construct Poses
      - 0-Pose-Level
        - AdjustPose-Idle.swift
      - 1-Body-Part-Level
        - AdjustBodyParts.swift
      - Bones-Level
        - AboutToLiftFoot-Idle.swift
        - LiftFoot-Idle.swift
        - PlantedFeetIfPossible-Idle.swift
      - Specific-Bone-Functions
        - AdjustCalf.swift
        - CorrectHipHeight.swift
        - ExtendFoot.swift
        - MoveBonesUtilities.swift
        - OrientThigh.swift
        - RollThigh.swift
        - TiltPelvis.swift
    - Idle-Idle Transitions
      - 0-fillOutIdeToIdleElements.swift
      - addAdditiveSourceElement.swift
      - addAdditiveSourceElementFromTr.swift
      - addBlendInSourceElementFromCustomInfo.swift
      - addTargetAnimationSequenceAfterIdleToIdle.swift
    - Idle-Walk Transitions
      - addBlendInSourceElement.swift
      - fillWalkIdleElements.swift
    - Walk-Walk Transitions
      - CirWalk
        - CirWalk.swift
        - CirWalkBoneOffsets.swift
      - Stride
        - StrideFunctions.swift
        - StrideMIN-toDelete.swift
        - StrideMain.swift
  - Brain
    - BrainAnimationSequence.swift
    - Travel&StyleEvents.swift
    - Idle
      - 0-IdleSequence.swift
      - 1-eval-orientation.swift
      - 2-pick-transition.swift
      - 3-build-transition.swift
      - 4-inertial-units.swift
    - Walk
      - 0-WalkSequence.swift
      - 1-PathwayEval.swift
      - 2-ExtendWalkSequence.swift
      - 3-TranstionalSequence.swift
      - 4-StepAlterations.swift
      - 5-InertialUnits.swift
      - 6-walkToIdle.swift
  - Components
    - AnimationSystem.swift
    - AnimationPlaybackStateComponent.swift
    - BrainComponent.swift
    - CustomAnimationSystem.swift
    - EventComponent.swift
    - SkeletalPosesSystem.swift
    - TravelComponent.swift
  - SettingsAndDataStructs
    - AnimationSettings.swift
    - CharacterAttachment.swift
    - SequenceData.swift
    - StyleGuide.swift
    - TravelGuide.swift
  - Utilities
    - AnimationDebugHUD.swift
    - BuildTransforms.swift
    - CommonUseCases.swift
    - OneShotAnimationRequests.swift
    - CriricalPoseFunctions.swift
    - SkeletonUtilities.swift
    - TransformUtilities.swift
    - mathUtilities.swift
    - Sequence Functions
      - CreateAnimationSequence.swift
      - addBlendInSourceElementWithCustomAnimation.swift

==== _concat/project_structure-AssetLib.text ====

- AssetLibS
  - AssetEntity
    - TeraEntries.swift
    - TeraModelDictionaryActor.swift
    - TeraSet.swift
  - BuildTerrain
    - SimpleTerrainMaterial.swift
    - TerrainHeight.swift
    - TerrainMeshBuilder.swift
    - TerrainModelEntityLoader.swift
  - Components
    - TeraComponent.swift
  - Import
    - AssetManager.swift
    - ImportMaterial.swift
    - ImportTerrain.swift
  - Shaders
    - SimpleTerrainShader.metal
    - SplatTerrainShader.metal
    - TerrainMaterials.h
    - TerrainMaterials.metal

==== _concat/project_structure-CoreLib.text ====

- CoreLibS
  - Components
    - DataCenterComponent.swift
  - CoreEntity
    - EntityExtensions.swift
    - EntitySet.swift
    - ModelEntityUtilities.swift
  - CoreUtilities
    - AdditiveOffsetsForCirWalk.swift
    - AppLogger.swift
    - CoreTransform.swift
    - SmoothingUtilities.swift
    - VectorMath.swift
  - ImportData
    - AutoGenFromPython
      - CriticalPosesDefinitions.swift
    - BoneOperations.swift
    - CommonStructs.swift
    - CriticalPosesFunctions.swift
    - DataManager.swift
    - GeneratedAnimCache.swift
    - ImportAnim.swift
    - ImportMap.swift
    - ImportTransforms.swift
    - ImportTransitions.swift
    - Mirror.swift
    - ReOrderJointsAtLoad.swift

==== _concat/project_structure-Inertialization.text ====

- InertializationS
  - inert-caching-unused.swift
  - inert-main.swift

==== _concat/project_structure-joystickController.text ====

- joystickControllerS
  - ExternalDataProtocol.swift
  - JoystickInterpreter.swift
  - UI
    - ActionButtonView.swift
    - JoystickController.swift

==== MatheMagicApp/AI/MatheMagicAIConfig.swift ====


import Foundation

enum MatheMagicAIConfig {


    static let defaultOllamaBaseURLString: String = "http://100.93.96.72:11434"
    static let defaultOllamaModelName: String = "mistral-small"

    static let defaultTimeoutSeconds: TimeInterval = 90

    static let minTimeoutSeconds: TimeInterval = 5
    static let maxTimeoutSeconds: TimeInterval = 300

    static let maxEventCharacters: Int = 1_024

    static let maxDebugCharacters: Int = 12_000


    static var baseURLString: String {
        infoPlistString("OllamaBaseURL") ?? defaultOllamaBaseURLString
    }

    static var modelName: String {
        infoPlistString("OllamaModelName") ?? defaultOllamaModelName
    }

    static var timeout: TimeInterval {
        let raw = infoPlistTimeInterval("OllamaTimeoutSeconds") ?? defaultTimeoutSeconds
        return clampTimeoutSeconds(raw)
    }


    static var ollamaBaseURLString: String { baseURLString }
    static var ollamaModelName: String { modelName }


    static var diagnosticsSummary: String {
        "OllamaBaseURL=\(baseURLString), OllamaModelName=\(modelName), OllamaTimeoutSeconds=\(timeout)"
    }


    private static func infoPlistString(_ key: String) -> String? {
        guard let raw = Bundle.main.object(forInfoDictionaryKey: key) else { return nil }

        if let s = raw as? String {
            let trimmed = s.trimmingCharacters(in: .whitespacesAndNewlines)
            return trimmed.isEmpty ? nil : trimmed
        }

        let s = String(describing: raw).trimmingCharacters(in: .whitespacesAndNewlines)
        return s.isEmpty ? nil : s
    }

    private static func infoPlistTimeInterval(_ key: String) -> TimeInterval? {
        guard let raw = Bundle.main.object(forInfoDictionaryKey: key) else { return nil }

        if let n = raw as? NSNumber {
            return n.doubleValue
        }

        if let s = raw as? String {
            let trimmed = s.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !trimmed.isEmpty else { return nil }
            return Double(trimmed)
        }

        return nil
    }

    private static func clampTimeoutSeconds(_ value: TimeInterval) -> TimeInterval {
        min(max(value, minTimeoutSeconds), maxTimeoutSeconds)
    }
}

==== MatheMagicApp/AI/FlashAIIdleEmoteCatalog.swift ====


import AnimLib
import Foundation

enum FlashAIIdleEmoteCatalog {

    static let aiContractFieldKey: String = "flash_idle_emote"

    static let optionUnclear: String = "unclear"
    static let optionNoChange: String = "no_change"

    static var allowedIdleAnimationNames: [String] {
        FlashAIIdleEmoteOptions.animationNames
    }

    static var aiContractOptionValues: [String] {
        [optionUnclear, optionNoChange] + allowedIdleAnimationNames.map { contractToken(forAnimationName: $0) }
    }

    static func normalizedSuggestion(from rawValue: String?) -> String? {
        guard let rawValue else { return nil }

        let trimmed = rawValue.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }

        guard trimmed != optionUnclear, trimmed != optionNoChange else { return nil }

        if allowedIdleAnimationNames.contains(trimmed) {
            return trimmed
        }

        return animationNameByContractToken[trimmed]
    }

    private static func contractToken(forAnimationName animationName: String) -> String {
        var out = ""
        out.reserveCapacity(animationName.count)

        for scalar in animationName.unicodeScalars {
            if CharacterSet.alphanumerics.contains(scalar) || scalar == "_" {
                out.unicodeScalars.append(scalar)
            } else {
                out.append("_")
            }
        }

        return out
    }

    private static var animationNameByContractToken: [String: String] {
        var dict: [String: String] = [:]
        for anim in allowedIdleAnimationNames {
            dict[contractToken(forAnimationName: anim)] = anim
        }
        return dict
    }

    private struct OptionDetails {
        let label: String
        let meaning: String
    }

    private static let idleEmoteDetailsByAnimationName: [String: OptionDetails] = [
        "01011_3_EmotionalR-Salute_M": .init(
            label: "Salute (greeting / acknowledgement / respect / wave / hey / bye)",
            meaning: "Use for greeting, acknowledgement, respect, pride, ceremonies, or impressive flyovers. Example: dragon riders are flying overhead."
        ),
        "01012_1_Emotes-Lose_Turn_Around": .init(
            label: "Turn away (embarrassed / defeated / frustrated)",
            meaning: "Use for negative news, embarrassment, defeat, awkwardness, rejection, or a negative turn-away reaction."
        ),
        "01012_2_Emotes-Ponder": .init(
            label: "Ponder (thinking / puzzled / curious)",
            meaning: "Use when asked question, thinking, analyzing, unsure, or reacting to something puzzling (\"hmm\")."
        )
    ]

    private static var optionDetailsByContractValue: [String: OptionDetails] {
        var dict: [String: OptionDetails] = [
            optionUnclear: .init(
                label: "Unclear",
                meaning: "Ambiguous or insufficient info to confidently choose an emote."
            ),
            optionNoChange: .init(
                label: "No emote",
                meaning: "No idle emote reaction needed; keep current idle."
            )
        ]

        for anim in allowedIdleAnimationNames {
            let token = contractToken(forAnimationName: anim)

            if let details = idleEmoteDetailsByAnimationName[anim] {
                dict[token] = details
            } else {
                dict[token] = .init(
                    label: prettifiedFallbackLabel(from: anim),
                    meaning: "Idle emote animation."
                )
            }
        }

        return dict
    }

    static var aiContractOptionsJSONArray: String {
        let detailsByValue = optionDetailsByContractValue

        return aiContractOptionValues
            .map { value in
                optionJSONObject(value: value, details: detailsByValue[value])
            }
            .joined(separator: ",\n                ")
    }

    private static func optionJSONObject(value: String, details: OptionDetails?) -> String {
        let escapedValue = jsonEscaped(value)

        guard let details else {
            return #"{ "value": "\#(escapedValue)" }"#
        }

        let escapedLabel = jsonEscaped(details.label)
        let escapedMeaning = jsonEscaped(details.meaning)

        return #"{ "value": "\#(escapedValue)", "label": "\#(escapedLabel)", "meaning": "\#(escapedMeaning)" }"#
    }

    private static func prettifiedFallbackLabel(from animationName: String) -> String {
        let base = animationName.split(separator: "-").last.map(String.init) ?? animationName
        let cleaned = base
            .replacingOccurrences(of: "_", with: " ")
            .trimmingCharacters(in: .whitespacesAndNewlines)

        return cleaned.isEmpty ? "Idle emote" : cleaned
    }

    private static func jsonEscaped(_ s: String) -> String {
        s
            .replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")
            .replacingOccurrences(of: "\n", with: "\\n")
            .replacingOccurrences(of: "\r", with: "\\r")
            .replacingOccurrences(of: "\t", with: "\\t")
    }
}

==== MatheMagicApp/AI/MatheMagicAIContract.swift ====


import Foundation

enum MatheMagicAIContract {
    static let schemaVersion: Int = 2

    static var templateJSONString: String {
        let idleEmoteOptions = FlashAIIdleEmoteCatalog.aiContractOptionsJSONArray

        return #"""
        {
          "schemaVersion": \#(schemaVersion),
          "title": "MatheMagicEventToAnimation",
          "includeEventEcho": true,
          "eventEchoRequired": false,
          "context": "You help a game character react to a short EVENT typed by the player by selecting exactly ONE Flash idle emote. Do not choose generic character actions or moods. Use no_change if no idle emote reaction is needed. Use unclear if ambiguous.",
          "fields": [
            {
              "key": "\#(FlashAIIdleEmoteCatalog.aiContractFieldKey)",
              "promptTitle": "Flash: Idle Emote",
              "context": "Pick the single best idle emote reaction for the EVENT (if any). Use the option labels/meanings to map intent (e.g., greeting / acknowledgement / respect -> Salute). Example: \"dragon riders are flying overhead\" => Salute. Use no_change if no emote is needed. Use unclear if ambiguous.",
              "required": true,
              "options": [
                \#(idleEmoteOptions)
              ]
            }
          ]
        }
        """#
    }
}

==== MatheMagicApp/AI/MatheMagicAIEventPipeline.swift ====


import AILib
import Foundation

struct MatheMagicAIRunResult: Sendable, Equatable {
    let event: String
    let runID: String
    let durationMs: Int

    let baseURLString: String
    let modelName: String
    let attempts: Int

    let schemaVersion: Int
    let eventEcho: String?
    let values: [String: String]

    let promptPreview: String
    let rawModelContent: String
    let extractedJSON: String
    let decodedText: String
    let statusText: String
}

actor MatheMagicAIEventPipeline {

    enum PipelineError: LocalizedError, Sendable {
        case emptyEvent

        var errorDescription: String? {
            switch self {
            case .emptyEvent:
                return "Event text is empty."
            }
        }
    }

    func run(eventText: String) async throws -> MatheMagicAIRunResult {
        let event = try Self.normalizeEvent(eventText)
        try Task.checkCancellation()

        let startedAt = Date()

        let baseURLString = MatheMagicAIConfig.ollamaBaseURLString
        let modelName = MatheMagicAIConfig.ollamaModelName
        let template = MatheMagicAIContract.templateJSONString

        let promptPreview = ClassifierRunner().buildPromptPreview(
            event: event,
            templateJSONString: template
        )

        let connection = try AILibConnection(
            baseURLString: baseURLString,
            modelName: modelName
        )

        let run = try await connection.fillValues(
            event: event,
            templateJSONString: template
        )

        try Task.checkCancellation()

        let durationMs = Int(Date().timeIntervalSince(startedAt) * 1000)
        let attempts = run.attempts.count

        let last = run.attempts.last
        let raw = String((last?.rawModelContent ?? "").prefix(MatheMagicAIConfig.maxDebugCharacters))
        let extracted = String((last?.extractedJSON ?? "").prefix(MatheMagicAIConfig.maxDebugCharacters))

        let decoded = Self.describe(run.output)

        let runIDString = String(describing: run.runID)

        let status = """
        AI: OK (\(durationMs)ms)
        Attempts: \(attempts)
        Base URL: \(connection.baseURL.absoluteString)
        Model: \(modelName)
        RunID: \(runIDString)
        """

        return MatheMagicAIRunResult(
            event: event,
            runID: runIDString,
            durationMs: durationMs,
            baseURLString: connection.baseURL.absoluteString,
            modelName: modelName,
            attempts: attempts,
            schemaVersion: run.output.schemaVersion,
            eventEcho: run.output.eventEcho,
            values: run.output.values,
            promptPreview: promptPreview,
            rawModelContent: raw,
            extractedJSON: extracted,
            decodedText: decoded,
            statusText: status
        )
    }

    private static func normalizeEvent(_ text: String) throws -> String {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { throw PipelineError.emptyEvent }

        if trimmed.count > MatheMagicAIConfig.maxEventCharacters {
            return String(trimmed.prefix(MatheMagicAIConfig.maxEventCharacters))
        }

        return trimmed
    }

    private static func describe(_ output: MCQFilledResponse) -> String {
        var lines: [String] = []
        lines.append("schema_version: \(output.schemaVersion)")
        lines.append("event_echo: \(output.eventEcho ?? "<nil>")")

        for key in output.values.keys.sorted() {
            if let value = output.values[key] {
                lines.append("\(key): \(value)")
            }
        }

        return lines.joined(separator: "\n")
    }
}

==== MatheMagicApp/AI/MatheMagicAICharacterDialoguePipeline.swift ====


import Foundation

actor MatheMagicAICharacterDialoguePipeline {

    enum PipelineError: LocalizedError, Sendable {
        case emptyEvent
        case invalidBaseURL(String)
        case invalidHTTPResponse
        case httpError(statusCode: Int, bodyPreview: String)
        case decodingFailed(String)
        case emptyModelResponse

        var errorDescription: String? {
            switch self {
            case .emptyEvent:
                return "Event text is empty."
            case .invalidBaseURL(let s):
                return "Invalid Ollama base URL: \(s)"
            case .invalidHTTPResponse:
                return "Invalid HTTP response."
            case .httpError(let statusCode, let bodyPreview):
                return "Ollama chat request failed (HTTP \(statusCode)): \(bodyPreview)"
            case .decodingFailed(let details):
                return "Failed to decode Ollama response: \(details)"
            case .emptyModelResponse:
                return "Model returned an empty dialogue response."
            }
        }
    }

    func run(eventText: String) async throws -> String {
        let event = try Self.normalizeEvent(eventText)
        try Task.checkCancellation()

        let baseURLString = MatheMagicAIConfig.ollamaBaseURLString
        let modelName = MatheMagicAIConfig.ollamaModelName
        let timeout = MatheMagicAIConfig.timeout

        guard let baseURL = Self.makeBaseURL(baseURLString) else {
            throw PipelineError.invalidBaseURL(baseURLString)
        }

        let chatURL = baseURL
            .appendingPathComponent("api")
            .appendingPathComponent("chat")

        let systemPrompt = """
        You are Flash, a friendly magical character in a kids iPad game called MatheMagic.
        Reply to the player's message with exactly ONE short sentence (max 20 words).
        No quotes. No emojis. No narration or actions. No newlines.
        """

        let payload = ChatRequest(
            model: modelName,
            messages: [
                .init(role: "system", content: systemPrompt),
                .init(role: "user", content: event)
            ],
            stream: false,
            options: .init(
                temperature: 0.3,
                topP: 1.0,
                numPredict: 60
            )
        )

        var request = URLRequest(url: chatURL)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONEncoder().encode(payload)
        request.timeoutInterval = timeout

        let config = URLSessionConfiguration.ephemeral
        config.timeoutIntervalForRequest = timeout
        config.timeoutIntervalForResource = timeout
        let session = URLSession(configuration: config)

        let (data, response) = try await session.data(for: request)
        try Task.checkCancellation()

        guard let http = response as? HTTPURLResponse else {
            throw PipelineError.invalidHTTPResponse
        }

        guard (200..<300).contains(http.statusCode) else {
            throw PipelineError.httpError(
                statusCode: http.statusCode,
                bodyPreview: Self.previewBody(data)
            )
        }

        let decoded: ChatResponse
        do {
            decoded = try JSONDecoder().decode(ChatResponse.self, from: data)
        } catch {
            throw PipelineError.decodingFailed(String(describing: error))
        }

        let raw = decoded.message?.content ?? decoded.response ?? ""
        let cleaned = Self.sanitize(raw)

        guard !cleaned.isEmpty else { throw PipelineError.emptyModelResponse }
        return cleaned
    }


    private struct ChatRequest: Encodable {
        struct Options: Encodable {
            let temperature: Double?
            let topP: Double?
            let numPredict: Int?

            enum CodingKeys: String, CodingKey {
                case temperature
                case topP = "top_p"
                case numPredict = "num_predict"
            }
        }

        let model: String
        let messages: [ChatMessage]
        let stream: Bool
        let options: Options?
    }

    private struct ChatMessage: Encodable {
        let role: String
        let content: String
    }

    private struct ChatResponse: Decodable {
        struct Message: Decodable {
            let role: String?
            let content: String?
        }

        let message: Message?
        let response: String?
    }


    private static func makeBaseURL(_ raw: String) -> URL? {
        let trimmed = raw.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }

        if let url = URL(string: trimmed), url.scheme != nil {
            return url
        }
        return URL(string: "http://" + trimmed)
    }

    private static func normalizeEvent(_ text: String) throws -> String {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { throw PipelineError.emptyEvent }

        if trimmed.count > MatheMagicAIConfig.maxEventCharacters {
            return String(trimmed.prefix(MatheMagicAIConfig.maxEventCharacters))
        }
        return trimmed
    }

    private static func sanitize(_ raw: String) -> String {
        var s = raw.trimmingCharacters(in: .whitespacesAndNewlines)

        if (s.hasPrefix("\"") && s.hasSuffix("\"")) ||
            (s.hasPrefix("‚Äú") && s.hasSuffix("‚Äù")) ||
            (s.hasPrefix("‚Äò") && s.hasSuffix("‚Äô")) ||
            (s.hasPrefix("'") && s.hasSuffix("'"))
        {
            s = String(s.dropFirst().dropLast()).trimmingCharacters(in: .whitespacesAndNewlines)
        }

        let parts = s.components(separatedBy: .whitespacesAndNewlines).filter { !$0.isEmpty }
        s = parts.joined(separator: " ")

        if let end = sentenceTerminatorIndex(in: s) {
            let after = s.index(after: end)
            s = String(s[..<after]).trimmingCharacters(in: .whitespacesAndNewlines)
        }

        let words = s.split(whereSeparator: { $0.isWhitespace })
        if words.count > 20 {
            s = words.prefix(20).map(String.init).joined(separator: " ")
        }

        let limit = 240
        if s.count > limit {
            s = String(s.prefix(limit)).trimmingCharacters(in: .whitespacesAndNewlines)
        }

        return s
    }

    private static func sentenceTerminatorIndex(in s: String) -> String.Index? {
        for idx in s.indices {
            let ch = s[idx]
            guard ch == "." || ch == "!" || ch == "?" else { continue }

            let next = s.index(after: idx)
            if next == s.endIndex { return idx }
            if s[next] == " " { return idx }
        }
        return nil
    }

    private static func previewBody(_ data: Data) -> String {
        let s = (String(data: data, encoding: .utf8) ?? "<non-utf8 body: \(data.count) bytes>")
            .trimmingCharacters(in: .whitespacesAndNewlines)

        if s.count <= 400 { return s }
        return String(s.prefix(400)) + "‚Ä¶"
    }
}

==== MatheMagicApp/AI/AIDebugState.swift ====


import Foundation

struct AIDebugState: Equatable, Sendable {
    var isRunning: Bool = false
    var statusText: String = "AI: idle"
    var lastEventText: String = ""

    var promptPreview: String = ""
    var decodedText: String = ""
    var extractedJSON: String = ""
    var rawModelContent: String = ""
    var latestValues: [String: String] = [:]

    mutating func start(eventText: String) {
        isRunning = true
        statusText = "AI: running‚Ä¶"
        lastEventText = eventText

        promptPreview = ""
        decodedText = ""
        extractedJSON = ""
        rawModelContent = ""
        latestValues = [:]
    }

    mutating func setSuccess(_ result: MatheMagicAIRunResult) {
        isRunning = false
        statusText = result.statusText
        promptPreview = result.promptPreview
        decodedText = result.decodedText
        extractedJSON = result.extractedJSON
        rawModelContent = result.rawModelContent
        latestValues = result.values
    }

    mutating func setFailure(_ error: Error) {
        isRunning = false
        statusText = "AI: FAILED: \(error.localizedDescription)"
    }

    mutating func setCancelled() {
        isRunning = false
        statusText = "AI: cancelled"
    }
}

==== MatheMagicApp/Top-Level/GameModelView.swift ====

import AnimLib
import AssetLib
import Combine
import CoreLib
import Foundation
import joystickController
import RealityKit
import SwiftUI

class GameModelView: ObservableObject, JoystickDataProvider, AIIdleAnimationSuggestionProvider {

    @Published var showAnimationDebugHUD: Bool = false {
        didSet {
            AnimationDebugBus.shared.setEnabled(showAnimationDebugHUD, resetHistory: showAnimationDebugHUD)
        }
    }

    @Published var animationDebugHUDCards: [AnimationDebugCard] = []

    private var animationDebugHUDCancellables = Set<AnyCancellable>()

    lazy var gameModel: GameModel = .init(gameModelView: self, teraStore: teraStore)

    let teraStore: TeraModelDictionaryActor

    @Published var isPaused: Bool = false {
        didSet {
            Task { await updateIsPausedInComponents() }
        }
    }

    @Published var isFinished: Bool = false
    @Published var currentState: GameScreenState = .start

    @Published var assetsLoaded: Bool = false // property to track asset loading
    @Published var score: Int = 0
    @Published var clockTime: Double = 0

    @Published var showQuestion: Bool = false
    @Published var isHoldingButton: Bool = false

    @Published var realityTextInput: RealityTextInputState = .init()

    @Published var isUserTextInputFocused: Bool = false

    @Published var aiDebug: AIDebugState = .init()

    @Published var characterDialogue: CharacterDialogueState = .init()

    private let aiPipeline = MatheMagicAIEventPipeline()
    private let aiCharacterDialoguePipeline = MatheMagicAICharacterDialoguePipeline()

    private var aiTask: Task<Void, Never>?
    private var aiDialogueTask: Task<Void, Never>?
    private var aiActiveEventID: UUID?

    private var dialogueHideTask: Task<Void, Never>?

    private var pendingAIIdleAnimationSuggestion: String?


    @Published var joystickMagnitude: CGFloat = 0
    @Published var joystickAngle: Angle = .degrees(0)
    @Published var joystickIsTouching = false
    var cameraYaw: Angle { camera.cameraYaw }

    @Published var isDragging: Bool = false
    @Published var rawDragTranslation: CGSize? = nil

    @Published var isPinching: Bool = false
    @Published var rawPinchScale: CGFloat = 1.0
    var initialPinchScale: CGFloat = 1.0 // capture starting scale

    @Published var camera: CameraState = .init()

    private var timer: Timer?
    private var startDate: Date?

    init(teraStore: TeraModelDictionaryActor) {
        self.teraStore = teraStore
        Task { await gameModel.initialize() }

        setupAnimationDebugHUDSubscription()
        startTimer()
    }

    var rootEntity: Entity? {
        didSet {
            Task { await updateIsPausedInComponents() }
        }
    } // need to pull the scene it is in

    @MainActor
    func updateIsPausedInComponents() {}

    private func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.001, repeats: true) { _ in
            Task {
                let state = await self.gameModel.getGameScreenState()
                let score = await self.gameModel.score
                await MainActor.run {
                    self.currentState = state
                    self.score = score
                    if let start = self.startDate {
                        self.clockTime = Date().timeIntervalSince(start)
                    }
                }
            }
        }
    }

    func toggleAnimationDebugHUD() {
        showAnimationDebugHUD.toggle()
    }

    func consumeAIIdleAnimationSuggestion() -> String? {
        let v = pendingAIIdleAnimationSuggestion
        pendingAIIdleAnimationSuggestion = nil
        return v
    }

    @MainActor
    func handleSubmittedRealityText(_ event: UserTextInputEvent) {
        AppLogger.shared.info("üìù Captured user text input (\(event.source.rawValue)): \(event.text)")

        Task { await gameModel.enqueueUserTextInput(event) }

        runAIClassification(for: event)
    }


    @MainActor
    private func runAIClassification(for event: UserTextInputEvent) {
        aiTask?.cancel()
        aiDialogueTask?.cancel()

        aiActiveEventID = event.id
        aiDebug.start(eventText: event.text)

        pendingAIIdleAnimationSuggestion = nil
        clearCharacterDialogue()

        let eventID = event.id
        let eventText = event.text

        aiDialogueTask = Task { [weak self] in
            guard let self else { return }

            do {
                let speech = try await self.aiCharacterDialoguePipeline.run(eventText: eventText)
                try Task.checkCancellation()

                await MainActor.run {
                    guard !Task.isCancelled, self.aiActiveEventID == eventID else { return }
                    self.showCharacterDialogue(speech)
                }
            } catch is CancellationError {
            } catch {
                AppLogger.shared.error("AI Dialogue: FAILED eventID=\(eventID) error=\(String(describing: error))")
            }
        }

        aiTask = Task { @MainActor [weak self] in
            guard let self else { return }

            do {
                let result = try await self.aiPipeline.run(eventText: eventText)
                guard !Task.isCancelled, self.aiActiveEventID == eventID else { return }

                self.aiDebug.setSuccess(result)

                self.pendingAIIdleAnimationSuggestion = FlashAIIdleEmoteCatalog.normalizedSuggestion(
                    from: result.values[FlashAIIdleEmoteCatalog.aiContractFieldKey]
                )
            } catch is CancellationError {
                guard self.aiActiveEventID == eventID else { return }
                self.aiDebug.setCancelled()

                AppLogger.shared.info("AI: cancelled eventID=\(eventID)")
            } catch {
                guard !Task.isCancelled, self.aiActiveEventID == eventID else { return }
                self.aiDebug.setFailure(error)

                let err = String(describing: error)
                AppLogger.shared.error("AI: FAILED eventID=\(eventID) error=\(err)")
                print("AI: FAILED eventID=\(eventID) error=\(err)")
            }
        }
    }


    @MainActor
    private func showCharacterDialogue(_ text: String, durationSeconds: TimeInterval = 15) {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }
        guard durationSeconds > 0 else { return }

        dialogueHideTask?.cancel()

        let newState = CharacterDialogueState(id: UUID(), text: trimmed, isVisible: true)
        characterDialogue = newState

        let shownID = newState.id
        dialogueHideTask = Task { @MainActor [weak self] in
            guard let self else { return }

            do {
                try await Task.sleep(nanoseconds: UInt64(durationSeconds * 1_000_000_000))
            } catch {
                return
            }

            guard self.characterDialogue.id == shownID else { return }
            self.characterDialogue = .init()
        }
    }

    @MainActor
    private func clearCharacterDialogue() {
        dialogueHideTask?.cancel()
        dialogueHideTask = nil
        characterDialogue = .init()
    }

    private func setupAnimationDebugHUDSubscription() {
        AnimationDebugBus.shared.events
            .receive(on: RunLoop.main)
            .sink { [weak self] event in
                guard let self else { return }
                switch event {
                case .reset:
                    self.animationDebugHUDCards.removeAll()

                case .card(let card):
                    if let last = self.animationDebugHUDCards.last,
                       last.kind == card.kind,
                       last.title == card.title
                    {
                        let updated = AnimationDebugCard(
                            id: last.id,
                            gameTimeSeconds: card.gameTimeSeconds,
                            characterName: card.characterName,
                            kind: card.kind,
                            title: card.title,
                            subtitle: card.subtitle,
                            details: card.details
                        )
                        self.animationDebugHUDCards[self.animationDebugHUDCards.count - 1] = updated
                    } else {
                        self.animationDebugHUDCards.append(card)
                        if self.animationDebugHUDCards.count > 3 {
                            self.animationDebugHUDCards.removeFirst(self.animationDebugHUDCards.count - 3)
                        }
                    }
                }
            }
            .store(in: &animationDebugHUDCancellables)
    }

    func togglePause() {
        isPaused.toggle()
        Task {
            await gameModel.setPaused(isPaused)
        }
    }

    func setFinished(_ finished: Bool) {
        isFinished = finished
        Task {
            await gameModel.setFinished(finished)
        }
    }

    func play() {
        startDate = Date()
        Task {
            await gameModel.play()
        }
    }

    func lobby() {
        if startDate == nil {
            startDate = Date()
        }
        Task {
            await gameModel.lobby()
        }
    }

    func selection() {
        if startDate == nil {
            startDate = Date()
        }
        Task {
            await gameModel.selection()
        }
    }

    func ball() {
        Task {
            await gameModel.ball()
        }
    }

    func reset() {
        startDate = Date()
        Task {
            await gameModel.reset()
        }
    }

    deinit {
        aiTask?.cancel()
        aiDialogueTask?.cancel()
        dialogueHideTask?.cancel()
    }
}

==== MatheMagicApp/Top-Level/CharacterDialogueState.swift ====


import Foundation

struct CharacterDialogueState: Equatable, Sendable {
    let id: UUID
    let text: String
    let isVisible: Bool

    init(id: UUID = UUID(), text: String = "", isVisible: Bool = false) {
        self.id = id
        self.text = text
        self.isVisible = isVisible
    }
}

==== MatheMagicApp/Top-Level/RealityTextInputState.swift ====


import Foundation

enum UserTextInputSource: String, Sendable {
    case sendButton
    case keyboardReturn
}

struct UserTextInputEvent: Identifiable, Equatable, Sendable {
    let id: UUID
    let text: String

    let submittedAtUnix: TimeInterval

    let source: UserTextInputSource

    init(
        id: UUID = UUID(),
        text: String,
        submittedAtUnix: TimeInterval = Date().timeIntervalSince1970,
        source: UserTextInputSource
    ) {
        self.id = id
        self.text = text
        self.submittedAtUnix = submittedAtUnix
        self.source = source
    }
}

struct RealityTextInputState: Equatable {
    var draft: String = ""
    private(set) var submitted: [UserTextInputEvent] = []

    static let historyLimit: Int = 50

    var lastSubmitted: UserTextInputEvent? { submitted.last }

    var canSubmit: Bool {
        !draft.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }

    @discardableResult
    mutating func submitDraft(source: UserTextInputSource) -> UserTextInputEvent? {
        let trimmed = draft.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }

        let event = UserTextInputEvent(text: trimmed, source: source)
        submitted.append(event)

        if submitted.count > Self.historyLimit {
            submitted.removeFirst(submitted.count - Self.historyLimit)
        }

        draft = ""
        return event
    }

    mutating func clearHistory(keepingCapacity: Bool = true) {
        submitted.removeAll(keepingCapacity: keepingCapacity)
    }
}

==== MatheMagicApp/Views/AIResponseHUDView.swift ====


import SwiftUI

struct AIResponseHUDView: View {
    let state: AIDebugState

    @State private var showDetails: Bool = false

    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            HStack(spacing: 10) {
                Text("AI")
                    .font(.headline)

                if state.isRunning {
                    ProgressView()
                        .controlSize(.small)
                }

                Spacer(minLength: 0)
            }

            Text(state.statusText)
                .font(.system(.footnote, design: .monospaced))
                .textSelection(.enabled)
                .lineLimit(4)

            if !state.decodedText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                Text(state.decodedText)
                    .font(.system(.footnote, design: .monospaced))
                    .textSelection(.enabled)
                    .lineLimit(10)
            }

            if !state.promptPreview.isEmpty || !state.extractedJSON.isEmpty || !state.rawModelContent.isEmpty {
                DisclosureGroup("Details", isExpanded: $showDetails) {
                    if !state.promptPreview.isEmpty {
                        VStack(alignment: .leading, spacing: 6) {
                            Text("Prompt preview")
                                .font(.caption)

                            Text(state.promptPreview)
                                .font(.system(.footnote, design: .monospaced))
                                .textSelection(.enabled)
                        }
                        .padding(.top, 6)
                    }

                    if !state.extractedJSON.isEmpty {
                        VStack(alignment: .leading, spacing: 6) {
                            Text("Extracted JSON")
                                .font(.caption)

                            Text(state.extractedJSON)
                                .font(.system(.footnote, design: .monospaced))
                                .textSelection(.enabled)
                        }
                        .padding(.top, 6)
                    }

                    if !state.rawModelContent.isEmpty {
                        VStack(alignment: .leading, spacing: 6) {
                            Text("Raw model content")
                                .font(.caption)

                            Text(state.rawModelContent)
                                .font(.system(.footnote, design: .monospaced))
                                .textSelection(.enabled)
                        }
                        .padding(.top, 6)
                    }
                }
                .font(.caption)
            }
        }
        .padding(12)
        .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 14, style: .continuous))
        .overlay(
            RoundedRectangle(cornerRadius: 14, style: .continuous)
                .stroke(.white.opacity(0.25), lineWidth: 1)
        )
    }
}

==== MatheMagicApp/Views/RealityTextInputOverlayView.swift ====


import SwiftUI

struct RealityTextInputOverlayView: View {
    @Binding var input: RealityTextInputState

    var placeholder: String = "Type a message‚Ä¶"
    var onSubmit: (UserTextInputEvent) -> Void
    var onFocusChange: (Bool) -> Void = { _ in }

    @FocusState private var isFocused: Bool

    var body: some View {
        HStack(spacing: 12) {
            TextField(placeholder, text: $input.draft)
                .textFieldStyle(.roundedBorder)
                .textInputAutocapitalization(.never)
                .autocorrectionDisabled()
                .focused($isFocused)
                .submitLabel(.send)
                .onSubmit { submit(source: .keyboardReturn) }
                .onChange(of: isFocused) { newValue in
                    onFocusChange(newValue)
                }

            Button {
                submit(source: .sendButton)
            } label: {
                Image(systemName: "paperplane.fill")
                    .font(.system(size: 16, weight: .semibold))
            }
            .buttonStyle(.borderedProminent)
            .disabled(!input.canSubmit)
            .accessibilityLabel("Send")
        }
        .padding(12)
        .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 14, style: .continuous))
        .overlay(
            RoundedRectangle(cornerRadius: 14, style: .continuous)
                .stroke(.white.opacity(0.25), lineWidth: 1)
        )
        .accessibilityElement(children: .contain)
    }

    private func submit(source: UserTextInputSource) {
        guard let event = input.submitDraft(source: source) else { return }
        onSubmit(event)

        isFocused = false
        onFocusChange(false)
    }
}

==== AILibS/ClassifierKit/AIJSONContract.swift ====


import Foundation

public struct AIJSONContract: Sendable, Equatable {
    public let template: MCQTemplate
    public let schemaJSONString: String
    public let schema: JSONSchema
    public let eventEchoKey: String?

    public var schemaVersion: Int { template.schemaVersion }

    public init(templateJSONString: String) throws {
        let decoded = try MCQTemplate.decode(jsonString: templateJSONString)
        try self.init(template: decoded)
    }

    public init(template: MCQTemplate) throws {
        let validated = try template.validated()
        let schemaJSONString = try MCQSchemaBuilder.buildSchemaJSONString(template: validated)
        let schema = try JSONSchema.parse(schemaJSONString)

        self.template = validated
        self.schemaJSONString = schemaJSONString
        self.schema = schema
        self.eventEchoKey = validated.includeEventEcho ? "event_echo" : nil
    }

    public func buildMessages(
        event: String,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) -> [OllamaChatMessage] {
        PromptBuilder.buildMessages(
            event: event,
            template: template,
            schemaJSONString: schemaJSONString,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides
        )
    }

    public func buildPromptPreview(
        event: String,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) -> String {
        PromptBuilder.buildPromptPreview(
            event: event,
            template: template,
            schemaJSONString: schemaJSONString,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides
        )
    }
}

==== AILibS/ClassifierKit/AILibConnection.swift ====


import Foundation

public struct AILibConnection: Sendable, Equatable {
    public let baseURL: URL
    public let modelName: String

    public var options: OllamaChatOptions?
    public var timeout: TimeInterval

    public init(
        baseURL: URL,
        modelName: String,
        options: OllamaChatOptions? = .deterministic,
        timeout: TimeInterval = 90
    ) {
        self.baseURL = baseURL
        self.modelName = modelName
        self.options = options
        self.timeout = timeout
    }

    public init(
        baseURLString: String,
        modelName: String,
        options: OllamaChatOptions? = .deterministic,
        timeout: TimeInterval = 90
    ) throws {
        let url = try OllamaEndpointParser.parseBaseURL(from: baseURLString)
        self.init(baseURL: url, modelName: modelName, options: options, timeout: timeout)
    }

    public func preflight(requiredModelName: String? = nil) async throws -> OllamaPreflightReport {
        let client = OllamaClient(baseURL: baseURL)

        let version = try await client.preflightVersion()

        let trimmedRequired: String? = {
            guard let requiredModelName else { return nil }
            let t = requiredModelName.trimmingCharacters(in: .whitespacesAndNewlines)
            return t.isEmpty ? nil : t
        }()

        do {
            let names = try await client.preflightTags()
            return OllamaPreflightReport(
                baseURL: baseURL,
                version: version,
                availableModelNames: names,
                requiredModelName: trimmedRequired,
                tagsError: nil
            )
        } catch {
            return OllamaPreflightReport(
                baseURL: baseURL,
                version: version,
                availableModelNames: [],
                requiredModelName: trimmedRequired,
                tagsError: error.localizedDescription
            )
        }
    }

    public func fillJSON(
        event: String,
        templateJSONString: String,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) async throws -> AIJSONRunResult<String> {
        let contract = try AIJSONContract(templateJSONString: templateJSONString)
        return try await fillJSON(
            event: event,
            contract: contract,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides
        )
    }

    public func fillJSON(
        event: String,
        contract: AIJSONContract,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) async throws -> AIJSONRunResult<String> {
        try await runValidated(
            event: event,
            contract: contract,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides,
            outputBuilder: { extracted in extracted }
        )
    }

    public func fillValues(
        event: String,
        templateJSONString: String,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) async throws -> AIJSONRunResult<MCQFilledResponse> {
        let contract = try AIJSONContract(templateJSONString: templateJSONString)
        return try await fillValues(
            event: event,
            contract: contract,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides
        )
    }

    public func fillValues(
        event: String,
        contract: AIJSONContract,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) async throws -> AIJSONRunResult<MCQFilledResponse> {
        try await runValidated(
            event: event,
            contract: contract,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides,
            outputBuilder: { extracted in
                try MCQFilledResponse.decode(jsonString: extracted)
            }
        )
    }


    private func runValidated<Output: Sendable>(
        event: String,
        contract: AIJSONContract,
        additionalInstructions: String?,
        fieldContextOverrides: [String: String]?,
        outputBuilder: @Sendable (String) throws -> Output
    ) async throws -> AIJSONRunResult<Output> {
        let messages = contract.buildMessages(
            event: event,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides
        )

        let originalUserMessage = messages.first(where: { $0.role == .user })?.content

        let filler = OllamaJSONFiller(
            baseURL: baseURL,
            modelName: modelName,
            options: options,
            timeout: timeout
        )

        return try await filler.run(
            event: event,
            schemaJSONString: contract.schemaJSONString,
            messages: messages,
            repairMessagesBuilder: { event, previous, summary in
                StrictJSONPromptBuilder.buildRepairMessages(
                    event: event,
                    schemaJSONString: contract.schemaJSONString,
                    previousModelOutput: previous,
                    errorSummary: summary,
                    originalUserMessage: originalUserMessage
                )
            },
            validator: { extracted in
                try JSONSchemaValidator.validate(
                    jsonString: extracted,
                    schema: contract.schema,
                    options: .init(eventEchoKey: contract.eventEchoKey, originalEvent: event)
                )
                return try outputBuilder(extracted)
            }
        )
    }
}

==== AILibS/ClassifierKit/OllamaChatModels.swift ====


import Foundation

public struct OllamaChatMessage: Codable, Sendable, Equatable {
    public enum Role: String, Codable, Sendable {
        case system
        case user
        case assistant
    }

    public let role: Role
    public let content: String

    public init(role: Role, content: String) {
        self.role = role
        self.content = content
    }
}

public struct OllamaChatOptions: Codable, Sendable, Equatable {
    public var temperature: Double?

    public var seed: Int?

    public init(temperature: Double? = nil, seed: Int? = nil) {
        self.temperature = temperature
        self.seed = seed
    }

    public static var deterministic: OllamaChatOptions {
        .init(temperature: 0.0, seed: 42)
    }
}

public struct OllamaChatRequest: Encodable, Sendable {
    public let model: String
    public let messages: [OllamaChatMessage]
    public let stream: Bool
    public let format: JSONValue?
    public let options: OllamaChatOptions?

    public init(
        model: String,
        messages: [OllamaChatMessage],
        stream: Bool,
        format: JSONValue?,
        options: OllamaChatOptions?
    ) {
        self.model = model
        self.messages = messages
        self.stream = stream
        self.format = format
        self.options = options
    }
}

public struct OllamaChatResponse: Decodable, Sendable {
    public let message: OllamaChatMessage

    public let model: String?
    public let createdAt: String?
    public let done: Bool?

    public enum CodingKeys: String, CodingKey {
        case message
        case model
        case createdAt = "created_at"
        case done
    }
}

==== AILibS/ClassifierKit/ClassifierKitLogger.swift ====


import Foundation
import os

public enum ClassifierKitLogger {
    public static let isEnabled: Bool = {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }()

    public static let maxPayloadCharacters: Int = 12_000

    private static let log = Logger(subsystem: "ClassifierKit", category: "Debug")

    public static func debug(_ message: @autoclosure () -> String) {
        guard isEnabled else { return }
        let msg = message()
        log.debug("\(msg, privacy: .public)")
        print("[ClassifierKit][DEBUG] \(msg)")
    }

    public static func info(_ message: @autoclosure () -> String) {
        guard isEnabled else { return }
        let msg = message()
        log.info("\(msg, privacy: .public)")
        print("[ClassifierKit][INFO] \(msg)")
    }

    public static func error(_ message: @autoclosure () -> String) {
        guard isEnabled else { return }
        let msg = message()
        log.error("\(msg, privacy: .public)")
        print("[ClassifierKit][ERROR] \(msg)")
    }

    public static func clip(_ s: String, limit: Int? = nil) -> String {
        let lim = limit ?? maxPayloadCharacters
        let t = s.trimmingCharacters(in: .whitespacesAndNewlines)
        guard t.count > lim else { return t }
        let idx = t.index(t.startIndex, offsetBy: lim)
        return String(t[..<idx]) + "‚Ä¶"
    }
}

==== AILibS/ClassifierKit/OllamaClient.swift ====

import Foundation

public struct OllamaClient: Sendable {
    public let baseURL: URL

    public init(baseURL: URL) {
        self.baseURL = baseURL
    }


    public func preflightVersion() async throws -> String {
        let response: VersionResponse = try await getJSON(path: "/api/version")
        return response.version
    }

    public func preflightTags() async throws -> [String] {
        let response: TagsResponse = try await getJSON(path: "/api/tags")
        return response.models.map(\.name).sorted()
    }

    public func chat(
        model: String,
        messages: [OllamaChatMessage],
        format: JSONValue?,
        options: OllamaChatOptions? = .deterministic,
        timeout: TimeInterval = 90
    ) async throws -> OllamaChatResponse {
        let body = OllamaChatRequest(
            model: model,
            messages: messages,
            stream: false,
            format: format,
            options: options
        )

        let response: OllamaChatResponse = try await postJSON(
            path: "/api/chat",
            body: body,
            timeout: timeout
        )
        return response
    }


    private func postJSON<T: Decodable, Body: Encodable>(
        path: String,
        body: Body,
        timeout: TimeInterval
    ) async throws -> T {
        let url = try makeURL(path: path)

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.timeoutInterval = timeout
        request.cachePolicy = .reloadIgnoringLocalCacheData
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        do {
            request.httpBody = try JSONEncoder().encode(body)
        } catch {
            throw ClassifierError.encoding(url: url, underlying: error.localizedDescription)
        }

        let data: Data
        let response: URLResponse

        do {
            (data, response) = try await Self.session.data(for: request)
        } catch {
            throw ClassifierError.classifyTransport(error, url: url)
        }

        guard let http = response as? HTTPURLResponse else {
            throw ClassifierError.nonHTTPResponse(url: url)
        }

        guard (200...299).contains(http.statusCode) else {
            throw ClassifierError.http(
                url: url,
                statusCode: http.statusCode,
                bodySnippet: Self.bodySnippet(from: data)
            )
        }

        do {
            return try JSONDecoder().decode(T.self, from: data)
        } catch {
            throw ClassifierError.decoding(
                url: url,
                underlying: error.localizedDescription,
                bodySnippet: Self.bodySnippet(from: data)
            )
        }
    }

    private func getJSON<T: Decodable>(path: String) async throws -> T {
        let url = try makeURL(path: path)

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.timeoutInterval = 10
        request.cachePolicy = .reloadIgnoringLocalCacheData
        request.setValue("application/json", forHTTPHeaderField: "Accept")

        let data: Data
        let response: URLResponse

        do {
            (data, response) = try await Self.session.data(for: request)
        } catch {
            throw ClassifierError.classifyTransport(error, url: url)
        }

        guard let http = response as? HTTPURLResponse else {
            throw ClassifierError.nonHTTPResponse(url: url)
        }

        guard (200...299).contains(http.statusCode) else {
            throw ClassifierError.http(
                url: url,
                statusCode: http.statusCode,
                bodySnippet: Self.bodySnippet(from: data)
            )
        }

        do {
            return try JSONDecoder().decode(T.self, from: data)
        } catch {
            throw ClassifierError.decoding(
                url: url,
                underlying: error.localizedDescription,
                bodySnippet: Self.bodySnippet(from: data)
            )
        }
    }

    private func makeURL(path: String) throws -> URL {
        guard let url = URL(string: path, relativeTo: baseURL)?.absoluteURL else {
            throw ClassifierError.invalidBaseURL("baseURL=\(baseURL.absoluteString), path=\(path)")
        }
        return url
    }

    private static func bodySnippet(from data: Data, limit: Int = 2_048) -> String? {
        guard !data.isEmpty else { return nil }
        let prefix = data.prefix(limit)
        let s = String(decoding: prefix, as: UTF8.self).trimmingCharacters(in: .whitespacesAndNewlines)
        return s.isEmpty ? nil : s
    }

    private static let session: URLSession = {
        let config = URLSessionConfiguration.ephemeral
        config.timeoutIntervalForRequest = 10
        config.timeoutIntervalForResource = 120
        config.waitsForConnectivity = false
        config.requestCachePolicy = .reloadIgnoringLocalCacheData
        return URLSession(configuration: config)
    }()


    private struct VersionResponse: Decodable {
        let version: String
    }

    private struct TagsResponse: Decodable {
        struct Model: Decodable {
            let name: String
        }
        let models: [Model]
    }
}


public struct OllamaPreflightReport: Sendable {
    public let baseURL: URL
    public let version: String

    public let availableModelNames: [String]

    public let requiredModelName: String?

    public let tagsError: String?

    public init(
        baseURL: URL,
        version: String,
        availableModelNames: [String],
        requiredModelName: String?,
        tagsError: String?
    ) {
        self.baseURL = baseURL
        self.version = version
        self.availableModelNames = availableModelNames
        self.requiredModelName = requiredModelName
        self.tagsError = tagsError
    }

    public var requiredModelFound: Bool? {
        guard tagsError == nil else { return nil }
        guard let requiredModelName else { return nil }

        let needle = requiredModelName
            .trimmingCharacters(in: .whitespacesAndNewlines)
            .lowercased()

        guard !needle.isEmpty else { return nil }

        return availableModelNames.contains { name in
            let n = name.lowercased()
            return n == needle || n.hasPrefix(needle + ":")
        }
    }
}

==== AILibS/ClassifierKit/OllamaJSONFiller.swift ====


import Foundation

public struct OllamaJSONFiller: Sendable {
    public let client: OllamaClient
    public let modelName: String
    public let options: OllamaChatOptions?
    public let timeout: TimeInterval

    public init(
        baseURL: URL,
        modelName: String,
        options: OllamaChatOptions? = .deterministic,
        timeout: TimeInterval = 90
    ) {
        self.client = OllamaClient(baseURL: baseURL)
        self.modelName = modelName
        self.options = options
        self.timeout = timeout
    }

    public func run<Output: Sendable>(
        event: String,
        schemaJSONString: String,
        messages: [OllamaChatMessage],
        repairMessagesBuilder: @Sendable (_ event: String, _ previousModelOutput: String, _ errorSummary: String) -> [OllamaChatMessage],
        validator: @Sendable (_ extractedJSON: String) throws -> Output
    ) async throws -> AIJSONRunResult<Output> {
        let runID = UUID().uuidString

        let schemaFormat: JSONValue
        do {
            schemaFormat = try JSONValue.parse(schemaJSONString)
        } catch {
            throw ClassifierError.invalidSchema(reason: error.localizedDescription)
        }

        logStart(runID: runID, event: event, messages: messages, schemaJSONString: schemaJSONString)

        var attempts: [AIJSONAttempt] = []

        do {
            let raw = try await performChat(runID: runID, attempt: 1, messages: messages, schemaFormat: schemaFormat)

            guard let extracted = ModelOutputJSONExtractor.extractFirstJSONObject(from: raw) else {
                let err = ClassifierError.modelOutputInvalid(
                    reason: "No JSON object found in message.content.",
                    rawModelContent: raw
                )
                attempts.append(.init(rawModelContent: raw, extractedJSON: nil, errorSummary: err.localizedDescription))
                throw err
            }

            ClassifierKitLogger.debug("[\(runID)] Extracted JSON (attempt=1):\n\(ClassifierKitLogger.clip(extracted))")

            do {
                let output = try validator(extracted)
                attempts.append(.init(rawModelContent: raw, extractedJSON: extracted, errorSummary: nil))
                ClassifierKitLogger.info("[\(runID)] ‚úÖ Valid output (attempt=1)")
                return .init(event: event, output: output, attempts: attempts, runID: runID)
            } catch {
                attempts.append(.init(rawModelContent: raw, extractedJSON: extracted, errorSummary: error.localizedDescription))
                ClassifierKitLogger.error("[\(runID)] ‚ùå Validation failed (attempt=1): \(oneLine(error.localizedDescription))")
                throw error
            }

        } catch {
            guard shouldAttemptRepair(error) else {
                if attempts.isEmpty {
                    attempts.append(.init(rawModelContent: nil, extractedJSON: nil, errorSummary: error.localizedDescription))
                }
                ClassifierKitLogger.error("[\(runID)] ‚ùå Failed (no repair): \(oneLine(error.localizedDescription))")
                throw error
            }

            let previous = attempts.last?.rawModelContent ?? ""
            let summary = oneLine(error.localizedDescription)

            let repairMessages = repairMessagesBuilder(event, previous, summary)
            if ClassifierKitLogger.isEnabled {
                let rendered = render(messages: repairMessages)
                ClassifierKitLogger.debug("[\(runID)] Repair prompt messages:\n\(ClassifierKitLogger.clip(rendered))")
            }

            do {
                let raw2 = try await performChat(runID: runID, attempt: 2, messages: repairMessages, schemaFormat: schemaFormat)

                guard let extracted2 = ModelOutputJSONExtractor.extractFirstJSONObject(from: raw2) else {
                    let err2 = ClassifierError.modelOutputInvalid(
                        reason: "No JSON object found in message.content (repair attempt).",
                        rawModelContent: raw2
                    )
                    attempts.append(.init(rawModelContent: raw2, extractedJSON: nil, errorSummary: err2.localizedDescription))
                    throw err2
                }

                ClassifierKitLogger.debug("[\(runID)] Extracted JSON (attempt=2):\n\(ClassifierKitLogger.clip(extracted2))")

                do {
                    let output2 = try validator(extracted2)
                    attempts.append(.init(rawModelContent: raw2, extractedJSON: extracted2, errorSummary: nil))
                    ClassifierKitLogger.info("[\(runID)] ‚úÖ Valid output (attempt=2)")
                    return .init(event: event, output: output2, attempts: attempts, runID: runID)
                } catch {
                    attempts.append(.init(rawModelContent: raw2, extractedJSON: extracted2, errorSummary: error.localizedDescription))
                    ClassifierKitLogger.error("[\(runID)] ‚ùå Validation failed (attempt=2): \(oneLine(error.localizedDescription))")
                    throw error
                }

            } catch {
                if attempts.last?.errorSummary == nil {
                    attempts.append(.init(rawModelContent: nil, extractedJSON: nil, errorSummary: error.localizedDescription))
                }
                ClassifierKitLogger.error("[\(runID)] ‚ùå Failed (repair): \(oneLine(error.localizedDescription))")
                throw error
            }
        }
    }

    private func logStart(runID: String, event: String, messages: [OllamaChatMessage], schemaJSONString: String) {
        ClassifierKitLogger.info("[\(runID)] OllamaJSONFiller.start model=\(modelName) baseURL=\(client.baseURL.absoluteString) timeout=\(timeout)")

        if let options {
            let temp = options.temperature.map { String($0) } ?? "nil"
            let seed = options.seed.map { String($0) } ?? "nil"
            ClassifierKitLogger.info("[\(runID)] options temperature=\(temp) seed=\(seed)")
        }

        ClassifierKitLogger.debug("[\(runID)] Event:\n\(ClassifierKitLogger.clip(event))")

        if ClassifierKitLogger.isEnabled {
            let rendered = render(messages: messages)
            ClassifierKitLogger.debug("[\(runID)] Prompt messages:\n\(ClassifierKitLogger.clip(rendered))")
            ClassifierKitLogger.debug("[\(runID)] Schema JSON:\n\(ClassifierKitLogger.clip(schemaJSONString))")
        }
    }

    private func performChat(
        runID: String,
        attempt: Int,
        messages: [OllamaChatMessage],
        schemaFormat: JSONValue
    ) async throws -> String {
        let promptPreview = messages.last?.content.prefix(60) ?? ""
        ClassifierKitLogger.info("üì§ API=\(client.baseURL.absoluteString)/api/chat model=\(modelName) prompt=\"\(promptPreview)...\" attempt=\(attempt)")
        let response = try await client.chat(
            model: modelName,
            messages: messages,
            format: schemaFormat,
            options: options,
            timeout: timeout
        )
        let raw = response.message.content
        let responsePreview = raw.prefix(80).replacingOccurrences(of: "\n", with: " ")
        ClassifierKitLogger.info("üì§ RESPONSE len=\(raw.count) preview=\"\(responsePreview)...\" attempt=\(attempt)")
        return raw
    }

    private func shouldAttemptRepair(_ error: Error) -> Bool {
        guard let e = error as? ClassifierError else { return false }
        switch e {
        case .modelOutputInvalid, .modelOutputSchemaMismatch:
            return true
        default:
            return false
        }
    }

    private func oneLine(_ s: String, limit: Int = 180) -> String {
        let t = s.replacingOccurrences(of: "\n", with: " ").trimmingCharacters(in: .whitespacesAndNewlines)
        guard t.count > limit else { return t }
        let idx = t.index(t.startIndex, offsetBy: limit)
        return String(t[..<idx]) + "‚Ä¶"
    }

    private func render(messages: [OllamaChatMessage]) -> String {
        messages
            .map { "[\($0.role.rawValue.uppercased())]\n\($0.content)" }
            .joined(separator: "\n\n")
    }
}

==== CoreLibS/CoreUtilities/AppLogger.swift ====

import os

public final class AppLogger: @unchecked Sendable {
    public static let shared = AppLogger() // Error: Static property 'shared' is not concurrency-safe because non-'Sendable' type 'AppLogger' may have shared mutable state
    
    private let prefix = "‚åöÔ∏è"
    
    public var clockTimeProvider: () -> Double = { 0.0 }
    
    private var gameTime: Double {
        self.clockTimeProvider()
    }
        
    private var formattedGameTime: String {
        String(format: "%.4f", self.gameTime)
    }
    
    let debugLogger = Logger(subsystem: "com.matheMagic.app", category: "debug")
    let infoLogger = Logger(subsystem: "com.matheMagic.app", category: "info")
    let uiLogger = Logger(subsystem: "com.matheMagic.app", category: "ui")
    let animLogger = Logger(subsystem: "com.matheMagic.app", category: "animation")
    let warningLogger = Logger(subsystem: "com.matheMagic.app", category: "warning")
    let errorLogger = Logger(subsystem: "com.matheMagic.app", category: "error")
    let plotLogger = Logger(subsystem: "com.matheMagic.app", category: "plot")

    

    public func debug(_ message: String, _ toPrint: Bool = true) {
        if toPrint {
            self.debugLogger.debug("\(self.prefix)\(self.formattedGameTime) üêû \(message)")
        }
    }
    
    public func info(_ message: String, _ toPrint: Bool = true) {
        if toPrint {
            self.infoLogger.info("\(self.prefix)\(self.formattedGameTime) ‚ÑπÔ∏è \(message)")
        }
    }
    
    public func ui(_ message: String, _ toPrint: Bool = true) {
        if toPrint {
            self.uiLogger.debug("\(self.prefix)\(self.formattedGameTime) üéØ \(message)")
        }
    }
    
    public func anim(_ message: String, _ toPrint: Bool = true) {
        if toPrint {
            self.animLogger.debug("\(self.prefix)\(self.formattedGameTime) ‚ú® \(message)")
        }
    }
    
    public func warning(_ message: String, _ toPrint: Bool = true) {
        if toPrint {
            self.warningLogger.notice("\(self.prefix)\(self.formattedGameTime) ‚ö†Ô∏è \(message)")
        }
    }
    
    public func error(_ message: String, _ toPrint: Bool = true) {
        if toPrint {
            self.errorLogger.error("\(self.prefix)\(self.formattedGameTime)  ‚ùå \(message)")
        }
    }
    
    public func plot(_ message: String, _ toPrint: Bool = true) {
        if toPrint {
            self.plotLogger.info("\(self.prefix)\(self.formattedGameTime) üìä \(message)")
        }
    }
    
    private init() {}
}
