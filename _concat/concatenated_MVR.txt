==== _concat/project_structure-MatheMagicApp.text ====

- MatheMagicApp
  - Info.plist
  - Brain-Old
    - BrainAnimationSequence.swift
    - IdleToIdle.swift
    - IdleToWalk.swift
    - WalkToWalk.swift
  - Components
    - CameraRotationComponent.swift
    - MoveComponent.swift
    - RealityViewExtensions.swift
    - TapComponent.swift
  - Entities
    - EntityEntries.swift
  - Environment
    - SkyboxUtilities.swift
  - Game Engine
    - GameMachineStates.swift
    - GlobalEntities.swift
    - PlayData.swift
  - Load
    - PreLoadAssets.swift
  - AI
    - MatheMagicAIConfig.swift
    - AIEndpointConfig.swift
    - MatheMagicAIContract.swift
    - MatheMagicAIEventPipeline.swift
    - MatheMagicAIService.swift
    - AIDebugState.swift
  - Top-Level
    - AppState.swift
    - ContentView.swift
    - GameModel.swift
    - GameModelView.swift
    - ImmersiveVew.swift
    - RealityTextInputState.swift
    - MatheMagicApp.swift
  - Utilities
    - ExtensionsEntity.swift
    - LocalUtilities.swift
  - Views
    - AnimationDebugHUDOverlayView.swift
    - AIResponseHUDView.swift
    - RealityTextInputOverlayView.swift
    - BallView.swift
    - CustomButtonStyle.swift
    - GameOver.swift
    - Lobby.swift
    - Play.swift
    - Scene Functions
      - SceneManager.swift
      - setupCharacterWithComponents.swift
    - Selection.swift
    - Start.swift

==== _concat/project_structure-AILib.text ====

- AILibS
  - ClassifierKit
    - AIJSONContract.swift
    - AIJSONRunModels.swift
    - AILibConnection.swift
    - ClassifierError.swift
    - ClassifierKitLogger.swift
    - ClassifierRunner.swift
    - JSONSchema.swift
    - JSONSchemaValidator.swift
    - JSONValue.swift
    - MCQFilledResponse.swift
    - MCQKey.swift
    - MCQSchemaBuilder.swift
    - MCQTemplate.swift
    - ModelOutputJSONExtractor.swift
    - OllamaChatModels.swift
    - OllamaClient.swift
    - OllamaEndpointParser.swift
    - OllamaJSONFiller.swift
    - PromptBuilder.swift
    - SchemaPromptBuilder.swift
    - StrictJSONPromptBuilder.swift

==== _concat/project_structure-AnimLib.text ====

- AnimLibS
  - AnimationTransforms
    - PlayTransforms.swift
    - Transforms-To-Play
      - 0-TransformsToPlay.swift
      - 1-orig-data.swift
      - 2-Alterations Data Functions
        - cirWalk-data.swift
        - matchTransform-data.swift
        - stride-data.swift
      - 2-apply-alterations-pre-blend.swift
      - 3-blend-elments-in-tree.swift
      - 4-inertial-data.swift
  - AnimationTranstions
    - Construct Poses
      - 0-Pose-Level
        - AdjustPose-Idle.swift
      - 1-Body-Part-Level
        - AdjustBodyParts.swift
      - Bones-Level
        - AboutToLiftFoot-Idle.swift
        - LiftFoot-Idle.swift
        - PlantedFeetIfPossible-Idle.swift
      - Specific-Bone-Functions
        - AdjustCalf.swift
        - CorrectHipHeight.swift
        - ExtendFoot.swift
        - MoveBonesUtilities.swift
        - OrientThigh.swift
        - RollThigh.swift
        - TiltPelvis.swift
    - Idle-Idle Transitions
      - 0-fillOutIdeToIdleElements.swift
      - addAdditiveSourceElement.swift
      - addAdditiveSourceElementFromTr.swift
      - addBlendInSourceElementFromCustomInfo.swift
      - addTargetAnimationSequenceAfterIdleToIdle.swift
    - Idle-Walk Transitions
      - addBlendInSourceElement.swift
      - fillWalkIdleElements.swift
    - Walk-Walk Transitions
      - CirWalk
        - CirWalk.swift
        - CirWalkBoneOffsets.swift
      - Stride
        - StrideFunctions.swift
        - StrideMIN-toDelete.swift
        - StrideMain.swift
  - Brain
    - BrainAnimationSequence.swift
    - Travel&StyleEvents.swift
    - Idle
      - 0-IdleSequence.swift
      - 1-eval-orientation.swift
      - 2-pick-transition.swift
      - 3-build-transition.swift
      - 4-inertial-units.swift
    - Walk
      - 0-WalkSequence.swift
      - 1-PathwayEval.swift
      - 2-ExtendWalkSequence.swift
      - 3-TranstionalSequence.swift
      - 4-StepAlterations.swift
      - 5-InertialUnits.swift
      - 6-walkToIdle.swift
  - Components
    - AnimationSystem.swift
    - AnimationPlaybackStateComponent.swift
    - BrainComponent.swift
    - CustomAnimationSystem.swift
    - EventComponent.swift
    - SkeletalPosesSystem.swift
    - TravelComponent.swift
  - SettingsAndDataStructs
    - AnimationSettings.swift
    - CharacterAttachment.swift
    - SequenceData.swift
    - StyleGuide.swift
    - TravelGuide.swift
  - Utilities
    - AnimationDebugHUD.swift
    - BuildTransforms.swift
    - CommonUseCases.swift
    - CriricalPoseFunctions.swift
    - SkeletonUtilities.swift
    - TransformUtilities.swift
    - mathUtilities.swift
    - Sequence Functions
      - CreateAnimationSequence.swift
      - addBlendInSourceElementWithCustomAnimation.swift

==== _concat/project_structure-CoreLib.text ====

- CoreLibS
  - Components
    - DataCenterComponent.swift
  - CoreEntity
    - EntityExtensions.swift
    - EntitySet.swift
    - ModelEntityUtilities.swift
  - CoreUtilities
    - AdditiveOffsetsForCirWalk.swift
    - AppLogger.swift
    - CoreTransform.swift
    - SmoothingUtilities.swift
    - VectorMath.swift
  - ImportData
    - AutoGenFromPython
      - CriticalPosesDefinitions.swift
    - BoneOperations.swift
    - CommonStructs.swift
    - CriticalPosesFunctions.swift
    - DataManager.swift
    - GeneratedAnimCache.swift
    - ImportAnim.swift
    - ImportMap.swift
    - ImportTransforms.swift
    - ImportTransitions.swift
    - Mirror.swift
    - ReOrderJointsAtLoad.swift

==== _concat/project_structure-Inertialization.text ====

- InertializationS
  - inert-caching-unused.swift
  - inert-main.swift

==== _concat/project_structure-joystickController.text ====

- joystickControllerS
  - ExternalDataProtocol.swift
  - JoystickInterpreter.swift
  - UI
    - ActionButtonView.swift
    - JoystickController.swift

==== MatheMagicApp/Info.plist ====

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(MARKETING_VERSION)</string>
	<key>CFBundleVersion</key>
	<string>$(CURRENT_PROJECT_VERSION)</string>

	<key>LSRequiresIPhoneOS</key>
	<true/>

	<!-- Optional: runtime-configurable Ollama endpoint/model (read by MatheMagicAIConfig) -->
	<key>OllamaBaseURL</key>
	<string>http://100.93.96.72:11434</string>
	<key>OllamaModelName</key>
	<string>mistral-small</string>

	<key>NSAppTransportSecurity</key>
	<dict>
		<!-- Keeps ATS enabled, but allows cleartext for local-style hosts -->
		<key>NSAllowsLocalNetworking</key>
		<true/>

		<!-- Allow cleartext HTTP to the specific Ollama IP you are using -->
		<key>NSExceptionDomains</key>
		<dict>
			<key>100.93.96.72</key>
			<dict>
				<key>NSExceptionAllowsInsecureHTTPLoads</key>
				<true/>
			</dict>

			<!-- Optional: keep the same â€œrangeâ€ exceptions you tested in SwiftAIBaseApp -->
			<key>100.64.0.0/10</key>
			<dict>
				<key>NSExceptionAllowsInsecureHTTPLoads</key>
				<true/>
			</dict>
			<key>10.0.0.0/8</key>
			<dict>
				<key>NSExceptionAllowsInsecureHTTPLoads</key>
				<true/>
			</dict>
			<key>172.16.0.0/12</key>
			<dict>
				<key>NSExceptionAllowsInsecureHTTPLoads</key>
				<true/>
			</dict>
			<key>192.168.0.0/16</key>
			<dict>
				<key>NSExceptionAllowsInsecureHTTPLoads</key>
				<true/>
			</dict>
			<key>169.254.0.0/16</key>
			<dict>
				<key>NSExceptionAllowsInsecureHTTPLoads</key>
				<true/>
			</dict>
		</dict>
	</dict>

	<key>NSLocalNetworkUsageDescription</key>
	<string>Connect to my Ollama server on the local network.</string>

	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<true/>
	</dict>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
	<key>UILaunchScreen</key>
	<dict/>

	<!-- Match current target settings (portrait + landscape, iPad = landscape only) -->
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
		<string>UIInterfaceOrientationPortrait</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
</dict>
</plist>

==== MatheMagicApp/Components/MoveComponent.swift ====

import RealityKit
import CoreLib

struct MoveComponent: RealityKit.Component {
    var posx: Float = 0.0
    var posz: Float = 0.0
}

class MoveSystem: RealityKit.System {
    @MainActor private static let query = EntityQuery(where: .has(MoveComponent.self))
    static weak var gameModelView: GameModelView?


    required init(scene: RealityKit.Scene) {}

    static var dependencies: [SystemDependency] { [] }

    func update(context: SceneUpdateContext) {
        guard let gameModelView = Self.gameModelView else {
            AppLogger.shared.error("Error: GameModelView is not set for MoveSystem")
            return
        }
        let characters = context.entities(matching: Self.query, updatingSystemWhen: .rendering)

        let deltaPos : Float = 0.03
        for character in characters {
            guard
                var moveComponent = character.components[MoveComponent.self]
            else { continue }
            var posx = moveComponent.posx
            var posz = moveComponent.posz
            if gameModelView.isHoldingButton {
                let xVar = deltaPos * Float(gameModelView.joystickMagnitude) * cos(Float(gameModelView.joystickAngle.radians))
                let zVar = deltaPos * Float(gameModelView.joystickMagnitude) * sin(Float(gameModelView.joystickAngle.radians))
                posx += xVar
                posz += zVar
                moveComponent.posx = posx
                moveComponent.posz = posz
                character.position = simd_float3(posx, 0, posz)
                character.components.set(moveComponent)
            }
        }
    }
}

==== MatheMagicApp/AI/MatheMagicAIConfig.swift ====


import Foundation

enum MatheMagicAIConfig {


    static let defaultOllamaBaseURLString: String = "http://100.93.96.72:11434"
    static let defaultOllamaModelName: String = "mistral-small"

    static let defaultTimeoutSeconds: TimeInterval = 90

    static let minTimeoutSeconds: TimeInterval = 5
    static let maxTimeoutSeconds: TimeInterval = 300

    static let maxEventCharacters: Int = 1_024

    static let maxDebugCharacters: Int = 12_000


    static var baseURLString: String {
        infoPlistString("OllamaBaseURL") ?? defaultOllamaBaseURLString
    }

    static var modelName: String {
        infoPlistString("OllamaModelName") ?? defaultOllamaModelName
    }

    static var timeout: TimeInterval {
        let raw = infoPlistTimeInterval("OllamaTimeoutSeconds") ?? defaultTimeoutSeconds
        return clampTimeoutSeconds(raw)
    }


    static var ollamaBaseURLString: String { baseURLString }
    static var ollamaModelName: String { modelName }


    static var diagnosticsSummary: String {
        "OllamaBaseURL=\(baseURLString), OllamaModelName=\(modelName), OllamaTimeoutSeconds=\(timeout)"
    }


    private static func infoPlistString(_ key: String) -> String? {
        guard let raw = Bundle.main.object(forInfoDictionaryKey: key) else { return nil }

        if let s = raw as? String {
            let trimmed = s.trimmingCharacters(in: .whitespacesAndNewlines)
            return trimmed.isEmpty ? nil : trimmed
        }

        let s = String(describing: raw).trimmingCharacters(in: .whitespacesAndNewlines)
        return s.isEmpty ? nil : s
    }

    private static func infoPlistTimeInterval(_ key: String) -> TimeInterval? {
        guard let raw = Bundle.main.object(forInfoDictionaryKey: key) else { return nil }

        if let n = raw as? NSNumber {
            return n.doubleValue
        }

        if let s = raw as? String {
            let trimmed = s.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !trimmed.isEmpty else { return nil }
            return Double(trimmed)
        }

        return nil
    }

    private static func clampTimeoutSeconds(_ value: TimeInterval) -> TimeInterval {
        min(max(value, minTimeoutSeconds), maxTimeoutSeconds)
    }
}

==== MatheMagicApp/AI/AIEndpointConfig.swift ====


import Foundation

struct AIEndpointConfig: Sendable, Equatable {
    var baseURLString: String
    var modelName: String
    var timeout: TimeInterval

    static var current: AIEndpointConfig {
        .init(
            baseURLString: MatheMagicAIConfig.baseURLString,
            modelName: MatheMagicAIConfig.modelName,
            timeout: MatheMagicAIConfig.timeout
        )
    }
}

==== MatheMagicApp/AI/MatheMagicAIContract.swift ====


import Foundation

enum MatheMagicAIContract {
    static let schemaVersion: Int = 1

    static let templateJSONString: String = #"""
    {
      "schemaVersion": 1,
      "title": "MatheMagicEventToAnimation",
      "includeEventEcho": true,
      "eventEchoRequired": false,
      "context": "You help a game character react to a short EVENT typed by the player. Choose a primary action and a mood. Use no_change if EVENT should not change the current state. Use unclear if ambiguous.",
      "fields": [
        {
          "key": "character_action",
          "promptTitle": "Character: Action",
          "context": "Pick the primary physical action the character should take. Keep coherent with character_mood.",
          "required": true,
          "options": [
            { "value": "unclear" },
            { "value": "no_change" },
            { "value": "idle" },
            { "value": "walk" },
            { "value": "run" },
            { "value": "jump" },
            { "value": "wave" }
          ]
        },
        {
          "key": "character_mood",
          "promptTitle": "Character: Mood",
          "context": "Pick an emotional tone coherent with character_action.",
          "required": true,
          "options": [
            { "value": "unclear" },
            { "value": "no_change" },
            { "value": "calm" },
            { "value": "happy" },
            { "value": "angry" },
            { "value": "scared" },
            { "value": "surprised" }
          ]
        }
      ]
    }
    """#
}

==== MatheMagicApp/AI/MatheMagicAIEventPipeline.swift ====


import AILib
import Foundation

struct MatheMagicAIRunResult: Sendable, Equatable {
    let event: String
    let runID: String
    let durationMs: Int

    let baseURLString: String
    let modelName: String
    let attempts: Int

    let schemaVersion: Int
    let eventEcho: String?
    let values: [String: String]

    let promptPreview: String
    let rawModelContent: String
    let extractedJSON: String
    let decodedText: String
    let statusText: String
}

actor MatheMagicAIEventPipeline {

    enum PipelineError: LocalizedError, Sendable {
        case emptyEvent

        var errorDescription: String? {
            switch self {
            case .emptyEvent:
                return "Event text is empty."
            }
        }
    }

    func run(eventText: String) async throws -> MatheMagicAIRunResult {
        let event = try Self.normalizeEvent(eventText)
        try Task.checkCancellation()

        let startedAt = Date()

        let baseURLString = MatheMagicAIConfig.ollamaBaseURLString
        let modelName = MatheMagicAIConfig.ollamaModelName
        let template = MatheMagicAIContract.templateJSONString

        let promptPreview = ClassifierRunner().buildPromptPreview(
            event: event,
            templateJSONString: template
        )

        let connection = try AILibConnection(
            baseURLString: baseURLString,
            modelName: modelName
        )

        let run = try await connection.fillValues(
            event: event,
            templateJSONString: template
        )

        try Task.checkCancellation()

        let durationMs = Int(Date().timeIntervalSince(startedAt) * 1000)
        let attempts = run.attempts.count

        let last = run.attempts.last
        let raw = String((last?.rawModelContent ?? "").prefix(MatheMagicAIConfig.maxDebugCharacters))
        let extracted = String((last?.extractedJSON ?? "").prefix(MatheMagicAIConfig.maxDebugCharacters))

        let decoded = Self.describe(run.output)

        let runIDString = String(describing: run.runID)

        let status = """
        AI: OK (\(durationMs)ms)
        Attempts: \(attempts)
        Base URL: \(connection.baseURL.absoluteString)
        Model: \(modelName)
        RunID: \(runIDString)
        """

        return MatheMagicAIRunResult(
            event: event,
            runID: runIDString,
            durationMs: durationMs,
            baseURLString: connection.baseURL.absoluteString,
            modelName: modelName,
            attempts: attempts,
            schemaVersion: run.output.schemaVersion,
            eventEcho: run.output.eventEcho,
            values: run.output.values,
            promptPreview: promptPreview,
            rawModelContent: raw,
            extractedJSON: extracted,
            decodedText: decoded,
            statusText: status
        )
    }

    private static func normalizeEvent(_ text: String) throws -> String {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { throw PipelineError.emptyEvent }

        if trimmed.count > MatheMagicAIConfig.maxEventCharacters {
            return String(trimmed.prefix(MatheMagicAIConfig.maxEventCharacters))
        }

        return trimmed
    }

    private static func describe(_ output: MCQFilledResponse) -> String {
        var lines: [String] = []
        lines.append("schema_version: \(output.schemaVersion)")
        lines.append("event_echo: \(output.eventEcho ?? "<nil>")")

        for key in output.values.keys.sorted() {
            if let value = output.values[key] {
                lines.append("\(key): \(value)")
            }
        }

        return lines.joined(separator: "\n")
    }
}

==== MatheMagicApp/AI/MatheMagicAIService.swift ====


import Foundation
import AILib
import os

struct AIEventRunDebug: Sendable, Equatable {
    let runID: String
    let event: String

    let baseURLString: String
    let modelName: String
    let durationMs: Int
    let attempts: Int

    let schemaVersion: Int
    let eventEcho: String?
    let values: [String: String]

    let rawModelContent: String
    let extractedJSON: String

    var formattedValuesText: String {
        var lines: [String] = []
        lines.append("schema_version: \(schemaVersion)")
        lines.append("event_echo: \(eventEcho ?? "<nil>")")

        for key in values.keys.sorted() {
            if let v = values[key] {
                lines.append("\(key): \(v)")
            }
        }
        return lines.joined(separator: "\n")
    }
}

enum MatheMagicAIServiceError: Error, LocalizedError, Sendable {
    case emptyEvent

    var errorDescription: String? {
        switch self {
        case .emptyEvent:
            return "Event text is empty."
        }
    }
}

actor MatheMagicAIService {
    private let log = Logger(
        subsystem: Bundle.main.bundleIdentifier ?? "MatheMagicApp",
        category: "MatheMagicAIService"
    )

    private var endpoint: AIEndpointConfig
    private let templateJSONString: String

    private var cachedContract: AIJSONContract?

    init(
        endpoint: AIEndpointConfig = .current,
        templateJSONString: String = MatheMagicAIContract.templateJSONString
    ) {
        self.endpoint = endpoint
        self.templateJSONString = templateJSONString
    }

    func refreshEndpointFromInfoPlist() {
        endpoint = .current
        log.info("AI endpoint refreshed baseURL=\(self.endpoint.baseURLString, privacy: .public) model=\(self.endpoint.modelName, privacy: .public)")
    }

    func run(event rawEvent: String) async throws -> AIEventRunDebug {
        let event = rawEvent.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !event.isEmpty else { throw MatheMagicAIServiceError.emptyEvent }

        try Task.checkCancellation()
        let startedAt = Date()

        let contract: AIJSONContract = try {
            if let cachedContract { return cachedContract }
            let c = try AIJSONContract(templateJSONString: templateJSONString)
            cachedContract = c
            return c
        }()

        let connection = try AILibConnection(
            baseURLString: endpoint.baseURLString,
            modelName: endpoint.modelName,
            options: .deterministic,
            timeout: endpoint.timeout
        )

        let run = try await connection.fillValues(
            event: event,
            contract: contract
        )

        try Task.checkCancellation()

        let durationMs = Int(Date().timeIntervalSince(startedAt) * 1000)
        let last = run.attempts.last

        let clippedRaw = Self.clip(last?.rawModelContent ?? "")
        let clippedExtracted = Self.clip(last?.extractedJSON ?? "")

        return AIEventRunDebug(
            runID: run.runID,
            event: event,
            baseURLString: endpoint.baseURLString,
            modelName: endpoint.modelName,
            durationMs: durationMs,
            attempts: run.attempts.count,
            schemaVersion: run.output.schemaVersion,
            eventEcho: run.output.eventEcho,
            values: run.output.values,
            rawModelContent: clippedRaw,
            extractedJSON: clippedExtracted
        )
    }

    private static func clip(_ s: String, limit: Int = 12_000) -> String {
        let t = s.trimmingCharacters(in: .whitespacesAndNewlines)
        guard t.count > limit else { return t }
        let idx = t.index(t.startIndex, offsetBy: limit)
        return String(t[..<idx]) + "â€¦"
    }
}

==== MatheMagicApp/AI/AIDebugState.swift ====


import Foundation

struct AIDebugState: Equatable, Sendable {
    var isRunning: Bool = false
    var statusText: String = "AI: idle"
    var lastEventText: String = ""

    var promptPreview: String = ""
    var decodedText: String = ""
    var extractedJSON: String = ""
    var rawModelContent: String = ""
    var latestValues: [String: String] = [:]

    mutating func start(eventText: String) {
        isRunning = true
        statusText = "AI: runningâ€¦"
        lastEventText = eventText

        promptPreview = ""
        decodedText = ""
        extractedJSON = ""
        rawModelContent = ""
        latestValues = [:]
    }

    mutating func setSuccess(_ result: MatheMagicAIRunResult) {
        isRunning = false
        statusText = result.statusText
        promptPreview = result.promptPreview
        decodedText = result.decodedText
        extractedJSON = result.extractedJSON
        rawModelContent = result.rawModelContent
        latestValues = result.values
    }

    mutating func setFailure(_ error: Error) {
        isRunning = false
        statusText = "AI: FAILED: \(error.localizedDescription)"
    }

    mutating func setCancelled() {
        isRunning = false
        statusText = "AI: cancelled"
    }
}

==== MatheMagicApp/Top-Level/GameModelView.swift ====

import AnimLib
import AssetLib
import Combine
import CoreLib
import Foundation
import joystickController
import RealityKit
import SwiftUI

class GameModelView: ObservableObject, JoystickDataProvider {

    @Published var showAnimationDebugHUD: Bool = false {
        didSet {
            AnimationDebugBus.shared.setEnabled(showAnimationDebugHUD, resetHistory: showAnimationDebugHUD)
        }
    }

    @Published var animationDebugHUDCards: [AnimationDebugCard] = []

    private var animationDebugHUDCancellables = Set<AnyCancellable>()

    lazy var gameModel: GameModel = .init(gameModelView: self, teraStore: teraStore)

    let teraStore: TeraModelDictionaryActor

    @Published var isPaused: Bool = false {
        didSet {
            Task { await updateIsPausedInComponents() }
        }
    }

    @Published var isFinished: Bool = false
    @Published var currentState: GameScreenState = .start

    @Published var assetsLoaded: Bool = false // property to track asset loading
    @Published var score: Int = 0
    @Published var clockTime: Double = 0

    @Published var showQuestion: Bool = false
    @Published var isHoldingButton: Bool = false

    @Published var realityTextInput: RealityTextInputState = .init()

    @Published var isUserTextInputFocused: Bool = false

    @Published var aiDebug: AIDebugState = .init()

    private let aiPipeline = MatheMagicAIEventPipeline()
    private var aiTask: Task<Void, Never>?
    private var aiActiveEventID: UUID?


    @Published var joystickMagnitude: CGFloat = 0
    @Published var joystickAngle: Angle = .degrees(0)
    @Published var joystickIsTouching = false
    var cameraYaw: Angle { camera.cameraYaw }

    @Published var isDragging: Bool = false
    @Published var rawDragTranslation: CGSize? = nil

    @Published var isPinching: Bool = false
    @Published var rawPinchScale: CGFloat = 1.0
    var initialPinchScale: CGFloat = 1.0 // capture starting scale

    @Published var camera: CameraState = .init()

    private var timer: Timer?
    private var startDate: Date?

    init(teraStore: TeraModelDictionaryActor) {
        self.teraStore = teraStore
        Task { await gameModel.initialize() }

        setupAnimationDebugHUDSubscription()
        startTimer()
    }

    var rootEntity: Entity? {
        didSet {
            Task { await updateIsPausedInComponents() }
        }
    } // need to pull the scene it is in

    @MainActor
    func updateIsPausedInComponents() {}

    private func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.001, repeats: true) { _ in
            Task {
                let state = await self.gameModel.getGameScreenState()
                let score = await self.gameModel.score
                await MainActor.run {
                    self.currentState = state
                    self.score = score
                    if let start = self.startDate {
                        self.clockTime = Date().timeIntervalSince(start)
                    }
                }
            }
        }
    }

    func toggleAnimationDebugHUD() {
        showAnimationDebugHUD.toggle()
    }

    @MainActor
    func handleSubmittedRealityText(_ event: UserTextInputEvent) {
        AppLogger.shared.info("ðŸ“ Captured user text input (\(event.source.rawValue)): \(event.text)")

        Task { await gameModel.enqueueUserTextInput(event) }

        runAIClassification(for: event)
    }


    @MainActor
    private func runAIClassification(for event: UserTextInputEvent) {
        aiTask?.cancel()

        aiActiveEventID = event.id
        aiDebug.start(eventText: event.text)

        let eventID = event.id
        let eventText = event.text

        aiTask = Task { [weak self] in
            guard let self else { return }

            do {
                let result = try await self.aiPipeline.run(eventText: eventText)
                guard !Task.isCancelled, self.aiActiveEventID == eventID else { return }
                self.aiDebug.setSuccess(result)
            } catch is CancellationError {
                guard self.aiActiveEventID == eventID else { return }
                self.aiDebug.setCancelled()
            } catch {
                guard !Task.isCancelled, self.aiActiveEventID == eventID else { return }
                self.aiDebug.setFailure(error)
            }
        }
    }

    private func setupAnimationDebugHUDSubscription() {
        AnimationDebugBus.shared.events
            .receive(on: RunLoop.main)
            .sink { [weak self] event in
                guard let self else { return }
                switch event {
                case .reset:
                    self.animationDebugHUDCards.removeAll()

                case .card(let card):
                    self.animationDebugHUDCards.append(card)
                    if self.animationDebugHUDCards.count > 3 {
                        self.animationDebugHUDCards.removeFirst(self.animationDebugHUDCards.count - 3)
                    }
                }
            }
            .store(in: &animationDebugHUDCancellables)
    }

    func togglePause() {
        isPaused.toggle()
        Task {
            await gameModel.setPaused(isPaused)
        }
    }

    func setFinished(_ finished: Bool) {
        isFinished = finished
        Task {
            await gameModel.setFinished(finished)
        }
    }

    func play() {
        startDate = Date()
        Task {
            await gameModel.play()
        }
    }

    func lobby() {
        if startDate == nil {
            startDate = Date()
        }
        Task {
            await gameModel.lobby()
        }
    }

    func selection() {
        if startDate == nil {
            startDate = Date()
        }
        Task {
            await gameModel.selection()
        }
    }

    func ball() {
        Task {
            await gameModel.ball()
        }
    }

    func reset() {
        startDate = Date()
        Task {
            await gameModel.reset()
        }
    }

    deinit {
        aiTask?.cancel()
    }
}

==== MatheMagicApp/Top-Level/ImmersiveVew.swift ====

import AnimLib
import AssetLib
import CoreLib

import CoreGraphics
import ImageIO
import joystickController
import RealityKit
import RealityKitContent
import SwiftUI

struct Selection: View {
    @StateObject private var sceneManager = SceneManager() // Create a dedicated manager
    @EnvironmentObject private var gameModelView: GameModelView
    @Environment(\.teraStore) private var teraStore: TeraModelDictionaryActor

    @State private var dragStartAngle: Angle = .zero
    @GestureState private var dragOffset: CGSize = .zero
    @State private var lastDragTranslation: CGSize = .zero
    @State private var lastDragUpdateTime: TimeInterval = CACurrentMediaTime()
    @State private var lastDeltaX: CGFloat = 0.0
    @State private var dragBaseline: CGFloat = 0.0

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                RealityView { content in
                    content.add(spaceOrigin)
                    
                    sceneManager.addDirectionalLight(to: spaceOrigin)
                    
                    
                    guard let iblComponent = try? await sceneManager.addImageBasedLight(name: "ImageBasedLighting") else { return }
                    spaceOrigin.components.set(iblComponent) // space origin emits light
                    
                    gameModelView.camera.updateCameraTransform(deltaTime: 0.0, gameModelView: gameModelView)
                    
                    gameModelView.camera.loadSkybox(into: content, for: .forest, with: iblComponent) // This loads png image as skybox
                    
                    //                         AppLogger.shared.error("Error loading fantasycastle skybox: \(error)")
                    
                    
                    let flashModel = setupCharacterWithComponents(entityDictionaryID: "flash", gameModelView: gameModelView)
                    sceneManager.addContentWithLight(entity: flashModel, iblComponent: iblComponent)
                    gameModelView.camera.trackedEntity = flashModel
                    gameModelView.camera.addCamera(to: content, relativeTo: flashModel, gameModelView: gameModelView, deltaTime: 0)
                    
                    AppLogger.shared.info("Plane position: \(flashModel.transform.translation)")
                    
                    
                    

                

                    let terrainEntity = Entity()
                    terrainEntity.name = "TerrainRoot"
                    terrainEntity.components.set(TeraComponent())

                    spaceOrigin.addChild(terrainEntity)
                    AppLogger.shared.debug("âœ…  Terrain added to scene.")
                }
                .id("SingleRealityView")
                .frame(width: geometry.size.width, height: geometry.size.height)
                .ignoresSafeArea()


                .gesture(
                    DragGesture()
                        .onChanged { value in
                            guard !gameModelView.isUserTextInputFocused else { return }
                            gameModelView.rawDragTranslation = value.translation
                            gameModelView.isDragging = true
                        }
                        .onEnded { _ in
                            guard !gameModelView.isUserTextInputFocused else { return }
                            gameModelView.isDragging = false
                            gameModelView.rawDragTranslation = .zero
                        }
                )
                .simultaneousGesture(
                    MagnificationGesture()
                        .onChanged { scale in
                            guard !gameModelView.isUserTextInputFocused else { return }
                            if !gameModelView.isPinching {
                                gameModelView.initialPinchScale = scale
                            }
                            gameModelView.isPinching = true
                            gameModelView.rawPinchScale = scale
                        }
                        .onEnded { _ in
                            guard !gameModelView.isUserTextInputFocused else { return }
                            gameModelView.isPinching = false
                            gameModelView.rawPinchScale = 1.0
                        }
                )

                VStack {
                    HStack {
                        AIResponseHUDView(state: gameModelView.aiDebug)
                        .frame(maxWidth: 520)
                        .allowsHitTesting(false)

                        Spacer(minLength: 0)
                    }

                    Spacer(minLength: 0)
                }
                .padding([.top, .leading], 20)

                VStack {
                    Spacer()
                    HStack(alignment: .bottom, spacing: 14) {
                        JoystickView(
                            onChange: { magnitude, angle in
                                gameModelView.joystickMagnitude = magnitude
                                gameModelView.joystickAngle = angle
                                gameModelView.joystickIsTouching = true
                            },
                            onEnd: {
                                gameModelView.joystickMagnitude = 0
                                gameModelView.joystickAngle = .zero
                                gameModelView.joystickIsTouching = false
                            }
                        )
                        .padding([.bottom, .leading], 20)

                        Spacer(minLength: 12)

                        VStack(spacing: 10) {
                            RealityTextInputOverlayView(
                                input: $gameModelView.realityTextInput,
                                placeholder: "Type input for AIâ€¦",
                                onSubmit: { event in
                                    gameModelView.handleSubmittedRealityText(event)
                                },
                                onFocusChange: { isFocused in
                                    gameModelView.isUserTextInputFocused = isFocused

                                    if isFocused {
                                        gameModelView.isDragging = false
                                        gameModelView.rawDragTranslation = .zero
                                        gameModelView.isPinching = false
                                        gameModelView.rawPinchScale = 1.0
                                    }
                                }
                            )
                        }
                        .frame(maxWidth: 520)
                        .padding(.bottom, 20)

                        Spacer(minLength: 12)

                        ActionButtonView(
                            onPressStart: { gameModelView.isHoldingButton = true },
                            onPressEnd: { gameModelView.isHoldingButton = false }
                        )
                        .padding([.bottom, .trailing], 20)
                    }
                }
            }
            .background(Color.white.ignoresSafeArea())
        }
    }
}

==== MatheMagicApp/Top-Level/RealityTextInputState.swift ====


import Foundation

enum UserTextInputSource: String, Sendable {
    case sendButton
    case keyboardReturn
}

struct UserTextInputEvent: Identifiable, Equatable, Sendable {
    let id: UUID
    let text: String

    let submittedAtUnix: TimeInterval

    let source: UserTextInputSource

    init(
        id: UUID = UUID(),
        text: String,
        submittedAtUnix: TimeInterval = Date().timeIntervalSince1970,
        source: UserTextInputSource
    ) {
        self.id = id
        self.text = text
        self.submittedAtUnix = submittedAtUnix
        self.source = source
    }
}

struct RealityTextInputState: Equatable {
    var draft: String = ""
    private(set) var submitted: [UserTextInputEvent] = []

    static let historyLimit: Int = 50

    var lastSubmitted: UserTextInputEvent? { submitted.last }

    var canSubmit: Bool {
        !draft.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }

    @discardableResult
    mutating func submitDraft(source: UserTextInputSource) -> UserTextInputEvent? {
        let trimmed = draft.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }

        let event = UserTextInputEvent(text: trimmed, source: source)
        submitted.append(event)

        if submitted.count > Self.historyLimit {
            submitted.removeFirst(submitted.count - Self.historyLimit)
        }

        draft = ""
        return event
    }

    mutating func clearHistory(keepingCapacity: Bool = true) {
        submitted.removeAll(keepingCapacity: keepingCapacity)
    }
}

==== MatheMagicApp/Views/AIResponseHUDView.swift ====


import SwiftUI

struct AIResponseHUDView: View {
    let state: AIDebugState

    @State private var showDetails: Bool = false

    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            HStack(spacing: 10) {
                Text("AI")
                    .font(.headline)

                if state.isRunning {
                    ProgressView()
                        .controlSize(.small)
                }

                Spacer(minLength: 0)
            }

            Text(state.statusText)
                .font(.system(.footnote, design: .monospaced))
                .textSelection(.enabled)
                .lineLimit(4)

            if !state.decodedText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                Text(state.decodedText)
                    .font(.system(.footnote, design: .monospaced))
                    .textSelection(.enabled)
                    .lineLimit(10)
            }

            if !state.promptPreview.isEmpty || !state.extractedJSON.isEmpty || !state.rawModelContent.isEmpty {
                DisclosureGroup("Details", isExpanded: $showDetails) {
                    if !state.promptPreview.isEmpty {
                        VStack(alignment: .leading, spacing: 6) {
                            Text("Prompt preview")
                                .font(.caption)

                            Text(state.promptPreview)
                                .font(.system(.footnote, design: .monospaced))
                                .textSelection(.enabled)
                        }
                        .padding(.top, 6)
                    }

                    if !state.extractedJSON.isEmpty {
                        VStack(alignment: .leading, spacing: 6) {
                            Text("Extracted JSON")
                                .font(.caption)

                            Text(state.extractedJSON)
                                .font(.system(.footnote, design: .monospaced))
                                .textSelection(.enabled)
                        }
                        .padding(.top, 6)
                    }

                    if !state.rawModelContent.isEmpty {
                        VStack(alignment: .leading, spacing: 6) {
                            Text("Raw model content")
                                .font(.caption)

                            Text(state.rawModelContent)
                                .font(.system(.footnote, design: .monospaced))
                                .textSelection(.enabled)
                        }
                        .padding(.top, 6)
                    }
                }
                .font(.caption)
            }
        }
        .padding(12)
        .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 14, style: .continuous))
        .overlay(
            RoundedRectangle(cornerRadius: 14, style: .continuous)
                .stroke(.white.opacity(0.25), lineWidth: 1)
        )
    }
}

==== MatheMagicApp/Views/RealityTextInputOverlayView.swift ====


import SwiftUI

struct RealityTextInputOverlayView: View {
    @Binding var input: RealityTextInputState

    var placeholder: String = "Type a messageâ€¦"
    var onSubmit: (UserTextInputEvent) -> Void
    var onFocusChange: (Bool) -> Void = { _ in }

    @FocusState private var isFocused: Bool

    var body: some View {
        HStack(spacing: 12) {
            TextField(placeholder, text: $input.draft)
                .textFieldStyle(.roundedBorder)
                .textInputAutocapitalization(.never)
                .autocorrectionDisabled()
                .focused($isFocused)
                .submitLabel(.send)
                .onSubmit { submit(source: .keyboardReturn) }
                .onChange(of: isFocused) { newValue in
                    onFocusChange(newValue)
                }

            Button {
                submit(source: .sendButton)
            } label: {
                Image(systemName: "paperplane.fill")
                    .font(.system(size: 16, weight: .semibold))
            }
            .buttonStyle(.borderedProminent)
            .disabled(!input.canSubmit)
            .accessibilityLabel("Send")
        }
        .padding(12)
        .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 14, style: .continuous))
        .overlay(
            RoundedRectangle(cornerRadius: 14, style: .continuous)
                .stroke(.white.opacity(0.25), lineWidth: 1)
        )
        .accessibilityElement(children: .contain)
    }

    private func submit(source: UserTextInputSource) {
        guard let event = input.submitDraft(source: source) else { return }
        onSubmit(event)

        isFocused = false
        onFocusChange(false)
    }
}

==== MatheMagicApp/Views/Scene Functions/setupCharacterWithComponents.swift ====

import AnimLib
import CoreLib
import RealityKit


@MainActor func setupCharacterWithComponents(
    entityDictionaryID: String,
    gameModelView: GameModelView
) -> Entity {
    var entity = Entity()
    if let template = entityModelDictionaryCore[entityDictionaryID] {
        entity = template.entity

        entity.components[EventComponent.self] = EventComponent(dataProvider: gameModelView) // ERROR: Cannot find 'gameModelView' in scope

        if let dataManager = template.dataManager {
            entity.components[DataCenterComponent.self] = DataCenterComponent(dataManager: dataManager)
        }

        entity.components[BrainComponent.self] = BrainComponent()

        entity.components[TravelComponent.self] = TravelComponent()

        entity.components.set(AnimationComponent())

    } else { AppLogger.shared.error("Error: did not find \(entityDictionaryID) key in entityTemplateDictionary") }
    return entity
}

==== AILibS/ClassifierKit/AIJSONContract.swift ====


import Foundation

public struct AIJSONContract: Sendable, Equatable {
    public let template: MCQTemplate
    public let schemaJSONString: String
    public let schema: JSONSchema
    public let eventEchoKey: String?

    public var schemaVersion: Int { template.schemaVersion }

    public init(templateJSONString: String) throws {
        let decoded = try MCQTemplate.decode(jsonString: templateJSONString)
        try self.init(template: decoded)
    }

    public init(template: MCQTemplate) throws {
        let validated = try template.validated()
        let schemaJSONString = try MCQSchemaBuilder.buildSchemaJSONString(template: validated)
        let schema = try JSONSchema.parse(schemaJSONString)

        self.template = validated
        self.schemaJSONString = schemaJSONString
        self.schema = schema
        self.eventEchoKey = validated.includeEventEcho ? "event_echo" : nil
    }

    public func buildMessages(
        event: String,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) -> [OllamaChatMessage] {
        PromptBuilder.buildMessages(
            event: event,
            template: template,
            schemaJSONString: schemaJSONString,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides
        )
    }

    public func buildPromptPreview(
        event: String,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) -> String {
        PromptBuilder.buildPromptPreview(
            event: event,
            template: template,
            schemaJSONString: schemaJSONString,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides
        )
    }
}

==== AILibS/ClassifierKit/AIJSONRunModels.swift ====


import Foundation

public struct AIJSONAttempt: Sendable {
    public let rawModelContent: String?
    public let extractedJSON: String?
    public let errorSummary: String?

    public init(rawModelContent: String?, extractedJSON: String?, errorSummary: String?) {
        self.rawModelContent = rawModelContent
        self.extractedJSON = extractedJSON
        self.errorSummary = errorSummary
    }
}

public struct AIJSONRunResult<Output: Sendable>: Sendable {
    public let event: String
    public let output: Output
    public let attempts: [AIJSONAttempt]
    public let runID: String

    public init(
        event: String,
        output: Output,
        attempts: [AIJSONAttempt],
        runID: String = UUID().uuidString
    ) {
        self.event = event
        self.output = output
        self.attempts = attempts
        self.runID = runID
    }
}

==== AILibS/ClassifierKit/AILibConnection.swift ====


import Foundation

public struct AILibConnection: Sendable, Equatable {
    public let baseURL: URL
    public let modelName: String

    public var options: OllamaChatOptions?
    public var timeout: TimeInterval

    public init(
        baseURL: URL,
        modelName: String,
        options: OllamaChatOptions? = .deterministic,
        timeout: TimeInterval = 90
    ) {
        self.baseURL = baseURL
        self.modelName = modelName
        self.options = options
        self.timeout = timeout
    }

    public init(
        baseURLString: String,
        modelName: String,
        options: OllamaChatOptions? = .deterministic,
        timeout: TimeInterval = 90
    ) throws {
        let url = try OllamaEndpointParser.parseBaseURL(from: baseURLString)
        self.init(baseURL: url, modelName: modelName, options: options, timeout: timeout)
    }

    public func preflight(requiredModelName: String? = nil) async throws -> OllamaPreflightReport {
        let client = OllamaClient(baseURL: baseURL)

        let version = try await client.preflightVersion()

        let trimmedRequired: String? = {
            guard let requiredModelName else { return nil }
            let t = requiredModelName.trimmingCharacters(in: .whitespacesAndNewlines)
            return t.isEmpty ? nil : t
        }()

        do {
            let names = try await client.preflightTags()
            return OllamaPreflightReport(
                baseURL: baseURL,
                version: version,
                availableModelNames: names,
                requiredModelName: trimmedRequired,
                tagsError: nil
            )
        } catch {
            return OllamaPreflightReport(
                baseURL: baseURL,
                version: version,
                availableModelNames: [],
                requiredModelName: trimmedRequired,
                tagsError: error.localizedDescription
            )
        }
    }

    public func fillJSON(
        event: String,
        templateJSONString: String,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) async throws -> AIJSONRunResult<String> {
        let contract = try AIJSONContract(templateJSONString: templateJSONString)
        return try await fillJSON(
            event: event,
            contract: contract,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides
        )
    }

    public func fillJSON(
        event: String,
        contract: AIJSONContract,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) async throws -> AIJSONRunResult<String> {
        try await runValidated(
            event: event,
            contract: contract,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides,
            outputBuilder: { extracted in extracted }
        )
    }

    public func fillValues(
        event: String,
        templateJSONString: String,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) async throws -> AIJSONRunResult<MCQFilledResponse> {
        let contract = try AIJSONContract(templateJSONString: templateJSONString)
        return try await fillValues(
            event: event,
            contract: contract,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides
        )
    }

    public func fillValues(
        event: String,
        contract: AIJSONContract,
        additionalInstructions: String? = nil,
        fieldContextOverrides: [String: String]? = nil
    ) async throws -> AIJSONRunResult<MCQFilledResponse> {
        try await runValidated(
            event: event,
            contract: contract,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides,
            outputBuilder: { extracted in
                try MCQFilledResponse.decode(jsonString: extracted)
            }
        )
    }


    private func runValidated<Output: Sendable>(
        event: String,
        contract: AIJSONContract,
        additionalInstructions: String?,
        fieldContextOverrides: [String: String]?,
        outputBuilder: @Sendable (String) throws -> Output
    ) async throws -> AIJSONRunResult<Output> {
        let messages = contract.buildMessages(
            event: event,
            additionalInstructions: additionalInstructions,
            fieldContextOverrides: fieldContextOverrides
        )

        let originalUserMessage = messages.first(where: { $0.role == .user })?.content

        let filler = OllamaJSONFiller(
            baseURL: baseURL,
            modelName: modelName,
            options: options,
            timeout: timeout
        )

        return try await filler.run(
            event: event,
            schemaJSONString: contract.schemaJSONString,
            messages: messages,
            repairMessagesBuilder: { event, previous, summary in
                StrictJSONPromptBuilder.buildRepairMessages(
                    event: event,
                    schemaJSONString: contract.schemaJSONString,
                    previousModelOutput: previous,
                    errorSummary: summary,
                    originalUserMessage: originalUserMessage
                )
            },
            validator: { extracted in
                try JSONSchemaValidator.validate(
                    jsonString: extracted,
                    schema: contract.schema,
                    options: .init(eventEchoKey: contract.eventEchoKey, originalEvent: event)
                )
                return try outputBuilder(extracted)
            }
        )
    }
}

==== AILibS/ClassifierKit/ClassifierError.swift ====

import Foundation

public enum ClassifierError: Error, Sendable, LocalizedError {
    case notImplemented(String)

    case invalidBaseURL(String)
    case invalidSchema(reason: String)
    case invalidTemplate(reason: String)

    case transport(url: URL, kind: TransportKind, underlying: String)
    case nonHTTPResponse(url: URL)
    case http(url: URL, statusCode: Int, bodySnippet: String?)

    case encoding(url: URL, underlying: String)
    case decoding(url: URL, underlying: String, bodySnippet: String?)

    case modelNotFound(required: String, available: [String])

    case modelOutputInvalid(reason: String, rawModelContent: String)

    case modelOutputSchemaMismatch(reasons: [String], rawJSON: String)

    public enum TransportKind: String, Sendable {
        case atsBlocked
        case localNetworkDenied
        case cannotConnect
        case timedOut
        case notConnected
        case unknown
    }

    public var errorDescription: String? {
        switch self {
        case .notImplemented(let message):
            return message

        case .invalidBaseURL(let raw):
            return "Invalid base URL: \(raw)"

        case .invalidSchema(let reason):
            return "Invalid JSON schema: \(reason)"

        case .invalidTemplate(let reason):
            return "Invalid template: \(reason)"

        case .transport(let url, let kind, let underlying):
            switch kind {
            case .atsBlocked:
                let host = url.host?.lowercased()
                let isIPv4 = host.flatMap { ClassifierError.parseIPv4Octets($0) } != nil
                let isIPv6 = (host?.contains(":") == true)
                let isIPLiteral = isIPv4 || isIPv6

                if isIPLiteral {
                    return """
                    App Transport Security blocked an insecure connection to \(url.absoluteString).

                    Fix (iOS/iPadOS 17+): HTTP to IP addresses is blocked unless you explicitly whitelist the IP (or a CIDR range)
                    in Info.plist:
                      NSAppTransportSecurity -> NSExceptionDomains -> <ip-or-cidr> -> NSExceptionAllowsInsecureHTTPLoads = YES

                    Preferred (production): use HTTPS for the endpoint.

                    Underlying: \(underlying)
                    """
                } else {
                    return """
                    App Transport Security blocked an insecure connection to \(url.absoluteString).

                    Fix options:
                    - Preferred: use HTTPS for the endpoint.
                    - If you must use HTTP for local naming (.local / unqualified hostnames):
                      NSAppTransportSecurity -> NSAllowsLocalNetworking = YES
                    - Otherwise add a tight NSExceptionDomains entry for that hostname.

                    Underlying: \(underlying)
                    """
                }
            case .localNetworkDenied:
                return """
                Local Network access appears denied for \(url.host ?? url.absoluteString).
                Fix: Add NSLocalNetworkUsageDescription to Info.plist, then enable the app under Settings -> Privacy & Security -> Local Network.
                Underlying: \(underlying)
                """
            case .cannotConnect:
                return """
                Cannot connect to \(url.absoluteString).
                Check: server is running, reachable from iPad (Wiâ€‘Fi/Tailscale), firewall allows 11434, and Ollama is bound to a non-loopback interface (OLLAMA_HOST).
                Underlying: \(underlying)
                """
            case .timedOut:
                return """
                Request timed out connecting to \(url.absoluteString).
                Check: network reachability and that the server responds to /api/version.
                Underlying: \(underlying)
                """
            case .notConnected:
                return """
                Network appears offline while connecting to \(url.absoluteString).
                Check: iPad network connection; if this is a LAN IP, also confirm Local Network permission.
                Underlying: \(underlying)
                """
            case .unknown:
                return "Network transport error connecting to \(url.absoluteString). Underlying: \(underlying)"
            }

        case .nonHTTPResponse(let url):
            return "Non-HTTP response from \(url.absoluteString)."

        case .http(let url, let statusCode, let bodySnippet):
            if let bodySnippet, !bodySnippet.isEmpty {
                return "HTTP \(statusCode) from \(url.absoluteString). Body (truncated): \(bodySnippet)"
            } else {
                return "HTTP \(statusCode) from \(url.absoluteString)."
            }

        case .decoding(let url, let underlying, let bodySnippet):
            if let bodySnippet, !bodySnippet.isEmpty {
                return "Failed to decode JSON from \(url.absoluteString): \(underlying). Body (truncated): \(bodySnippet)"
            } else {
                return "Failed to decode JSON from \(url.absoluteString): \(underlying)"
            }

        case .encoding(let url, let underlying):
            return "Failed to encode JSON request for \(url.absoluteString): \(underlying)"

        case .modelNotFound(let required, let available):
            return "Model \"\(required)\" was not found in /api/tags. Available: \(available.joined(separator: ", "))"

        case .modelOutputInvalid(let reason, let rawModelContent):
            return """
            Model output invalid: \(reason)

            Raw model output (truncated):
            \(Self.truncate(rawModelContent))
            """

        case .modelOutputSchemaMismatch(let reasons, let rawJSON):
            let bulletList = reasons
                .map { "- \($0)" }
                .joined(separator: "\n")

            return """
            Model output failed validation:
            \(bulletList)

            JSON (truncated):
            \(Self.truncate(rawJSON))
            """
        }


    public static func classifyTransport(_ error: Error, url: URL) -> ClassifierError {
        if let urlError = error as? URLError {
            let kind: TransportKind

            switch urlError.code {
            case .appTransportSecurityRequiresSecureConnection:
                kind = .atsBlocked

            case .cannotConnectToHost, .cannotFindHost, .dnsLookupFailed, .networkConnectionLost:
                kind = .cannotConnect

            case .timedOut:
                kind = .timedOut

            case .notConnectedToInternet:
                if isLikelyLocalHost(url.host) {
                    kind = .localNetworkDenied
                } else {
                    kind = .notConnected
                }

            default:
                kind = .unknown
            }

            return .transport(
                url: url,
                kind: kind,
                underlying: "URLError(\(urlError.code.rawValue): \(urlError.code)) - \(urlError.localizedDescription)"
            )
        }

        return .transport(
            url: url,
            kind: .unknown,
            underlying: String(describing: error)
        )
    }

    private static func isLikelyLocalHost(_ host: String?) -> Bool {
        guard let host, !host.isEmpty else { return false }
        let h = host.lowercased()

        if h == "localhost" { return true }
        if h.hasSuffix(".local") { return true }

        guard let octets = parseIPv4Octets(h) else { return false }
        let a = Int(octets[0])
        let b = Int(octets[1])

        if a == 10 { return true }
        if a == 172, (16...31).contains(b) { return true }
        if a == 192, b == 168 { return true }

        if a == 169, b == 254 { return true }

        if a == 100, (64...127).contains(b) { return true }

        return false
    }

    private static func parseIPv4Octets(_ host: String) -> [UInt8]? {
        let parts = host.split(separator: ".", omittingEmptySubsequences: true)
        guard parts.count == 4 else { return nil }

        var octets: [UInt8] = []
        octets.reserveCapacity(4)

        for part in parts {
            guard let v = UInt8(part) else { return nil }
            octets.append(v)
        }
        return octets
    }

    private static func truncate(_ s: String, limit: Int = 2_048) -> String {
        let t = s.trimmingCharacters(in: .whitespacesAndNewlines)
        guard t.count > limit else { return t }
        let idx = t.index(t.startIndex, offsetBy: limit)
        return String(t[..<idx]) + "â€¦"
    }
}

==== AILibS/ClassifierKit/ClassifierRunner.swift ====

import Foundation

public struct ClassifierRunner: Sendable {

    public typealias Attempt = AIJSONAttempt

    public init() {}

    public func buildPromptPreview(
        event: String,
        templateJSONString: String,
        additionalInstructions: String? = nil
    ) -> String {
        do {
            let template = try MCQTemplate.decode(jsonString: templateJSONString).validated()
            let schemaJSONString = try MCQSchemaBuilder.buildSchemaJSONString(template: template)
            return PromptBuilder.buildPromptPreview(
                event: event,
                template: template,
                schemaJSONString: schemaJSONString,
                additionalInstructions: additionalInstructions
            )
        } catch {
            return "INVALID TEMPLATE: \(error.localizedDescription)"
        }
    }

    public func buildSchemaPromptPreview(event: String, schemaJSONString: String) throws -> String {
        let schema = try JSONSchema.parse(schemaJSONString)
        return SchemaPromptBuilder.buildPromptPreview(event: event, schema: schema)
    }

    public func preflight(
        baseURL: URL,
        requiredModelName: String? = nil
    ) async throws -> OllamaPreflightReport {
        let client = OllamaClient(baseURL: baseURL)

        let version = try await client.preflightVersion()

        let trimmedRequired: String? = {
            guard let requiredModelName else { return nil }
            let t = requiredModelName.trimmingCharacters(in: .whitespacesAndNewlines)
            return t.isEmpty ? nil : t
        }()

        do {
            let names = try await client.preflightTags()
            return OllamaPreflightReport(
                baseURL: baseURL,
                version: version,
                availableModelNames: names,
                requiredModelName: trimmedRequired,
                tagsError: nil
            )
        } catch {
            return OllamaPreflightReport(
                baseURL: baseURL,
                version: version,
                availableModelNames: [],
                requiredModelName: trimmedRequired,
                tagsError: error.localizedDescription
            )
        }
    }


    public func fillJSON(
        event: String,
        schemaJSONString: String,
        baseURL: URL,
        modelName: String,
        eventEchoKey: String? = "event_echo",
        options: OllamaChatOptions? = .deterministic,
        timeout: TimeInterval = 90
    ) async throws -> AIJSONRunResult<String> {
        let schema = try JSONSchema.parse(schemaJSONString)
        let messages = SchemaPromptBuilder.buildMessages(event: event, schema: schema)

        return try await fillJSON(
            event: event,
            schema: schema,
            schemaJSONString: schemaJSONString,
            messages: messages,
            baseURL: baseURL,
            modelName: modelName,
            eventEchoKey: eventEchoKey,
            options: options,
            timeout: timeout
        )
    }

    public func fillJSON(
        event: String,
        schemaJSONString: String,
        messages: [OllamaChatMessage],
        baseURL: URL,
        modelName: String,
        eventEchoKey: String? = "event_echo",
        options: OllamaChatOptions? = .deterministic,
        timeout: TimeInterval = 90
    ) async throws -> AIJSONRunResult<String> {
        let schema = try JSONSchema.parse(schemaJSONString)

        return try await fillJSON(
            event: event,
            schema: schema,
            schemaJSONString: schemaJSONString,
            messages: messages,
            baseURL: baseURL,
            modelName: modelName,
            eventEchoKey: eventEchoKey,
            options: options,
            timeout: timeout
        )
    }


    public func fillJSON(
        event: String,
        templateJSONString: String,
        baseURL: URL,
        modelName: String,
        additionalInstructions: String? = nil,
        options: OllamaChatOptions? = .deterministic,
        timeout: TimeInterval = 90
    ) async throws -> AIJSONRunResult<String> {
        let template = try MCQTemplate.decode(jsonString: templateJSONString).validated()
        let schemaJSONString = try MCQSchemaBuilder.buildSchemaJSONString(template: template)

        let messages = PromptBuilder.buildMessages(
            event: event,
            template: template,
            schemaJSONString: schemaJSONString,
            additionalInstructions: additionalInstructions
        )

        let echoKey: String? = template.includeEventEcho ? "event_echo" : nil

        let schema = try JSONSchema.parse(schemaJSONString)

        return try await fillJSON(
            event: event,
            schema: schema,
            schemaJSONString: schemaJSONString,
            messages: messages,
            baseURL: baseURL,
            modelName: modelName,
            eventEchoKey: echoKey,
            options: options,
            timeout: timeout
        )
    }


    private func fillJSON(
        event: String,
        schema: JSONSchema,
        schemaJSONString: String,
        messages: [OllamaChatMessage],
        baseURL: URL,
        modelName: String,
        eventEchoKey: String?,
        options: OllamaChatOptions?,
        timeout: TimeInterval
    ) async throws -> AIJSONRunResult<String> {
        let originalUserMessage = messages.first(where: { $0.role == .user })?.content

        let filler = OllamaJSONFiller(
            baseURL: baseURL,
            modelName: modelName,
            options: options,
            timeout: timeout
        )

        return try await filler.run(
            event: event,
            schemaJSONString: schemaJSONString,
            messages: messages,
            repairMessagesBuilder: { event, previous, summary in
                StrictJSONPromptBuilder.buildRepairMessages(
                    event: event,
                    schemaJSONString: schemaJSONString,
                    previousModelOutput: previous,
                    errorSummary: summary,
                    originalUserMessage: originalUserMessage
                )
            },
            validator: { extracted in
                try JSONSchemaValidator.validate(
                    jsonString: extracted,
                    schema: schema,
                    options: .init(eventEchoKey: eventEchoKey, originalEvent: event)
                )
                return extracted
            }
        )
    }
}

==== AILibS/ClassifierKit/MCQFilledResponse.swift ====


import Foundation

public struct MCQFilledResponse: Sendable, Equatable, Codable {
    public let schemaVersion: Int
    public let eventEcho: String?
    public let values: [String: String]

    public init(schemaVersion: Int, eventEcho: String?, values: [String: String]) {
        self.schemaVersion = schemaVersion
        self.eventEcho = eventEcho
        self.values = values
    }

    public subscript(key: String) -> String? {
        values[key]
    }

    public static func decode(jsonString: String) throws -> MCQFilledResponse {
        let data = Data(jsonString.utf8)
        do {
            return try JSONDecoder().decode(MCQFilledResponse.self, from: data)
        } catch {
            throw ClassifierError.modelOutputInvalid(
                reason: "Failed to decode validated JSON into MCQFilledResponse: \(error.localizedDescription)",
                rawModelContent: jsonString
            )
        }
    }


    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: AnyCodingKey.self)

        let schemaKey = AnyCodingKey("schema_version")
        guard container.contains(schemaKey) else {
            throw DecodingError.keyNotFound(
                schemaKey,
                .init(codingPath: decoder.codingPath, debugDescription: "Missing schema_version")
            )
        }
        self.schemaVersion = try container.decode(Int.self, forKey: schemaKey)

        let echoKey = AnyCodingKey("event_echo")
        self.eventEcho = try container.decodeIfPresent(String.self, forKey: echoKey)

        var out: [String: String] = [:]
        out.reserveCapacity(container.allKeys.count)

        for key in container.allKeys {
            let k = key.stringValue
            if k == "schema_version" || k == "event_echo" { continue }

            if let v = try container.decodeIfPresent(String.self, forKey: key) {
                out[k] = v
            }
        }

        self.values = out
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: AnyCodingKey.self)

        try container.encode(schemaVersion, forKey: AnyCodingKey("schema_version"))
        try container.encodeIfPresent(eventEcho, forKey: AnyCodingKey("event_echo"))

        for (k, v) in values {
            try container.encode(v, forKey: AnyCodingKey(k))
        }
    }

    fileprivate struct AnyCodingKey: CodingKey, Hashable {
        var stringValue: String
        var intValue: Int?

        init(_ string: String) {
            self.stringValue = string
            self.intValue = nil
        }

        init?(stringValue: String) {
            self.stringValue = stringValue
            self.intValue = nil
        }

        init?(intValue: Int) {
            return nil
        }
    }
}

==== AILibS/ClassifierKit/MCQKey.swift ====


import Foundation

public enum MCQKey {
    private static let reserved: Set<String> = ["schema_version", "event_echo"]

    public static func sanitize(_ raw: String) -> String {
        let trimmed = raw.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return "" }

        let lower = trimmed.lowercased()

        var scalars: [UnicodeScalar] = []
        scalars.reserveCapacity(lower.unicodeScalars.count)

        var lastWasUnderscore = false
        for s in lower.unicodeScalars {
            if CharacterSet.alphanumerics.contains(s) {
                scalars.append(s)
                lastWasUnderscore = false
            } else {
                if !lastWasUnderscore {
                    scalars.append("_")
                    lastWasUnderscore = true
                }
            }
        }

        var out = String(String.UnicodeScalarView(scalars))
        out = out.trimmingCharacters(in: CharacterSet(charactersIn: "_"))
        guard !out.isEmpty else { return "" }

        if let first = out.unicodeScalars.first,
           CharacterSet.decimalDigits.contains(first) {
            out = "k_" + out
        }

        if reserved.contains(out) {
            out = "field_" + out
        }

        return out
    }

    public static func make(_ parts: String...) -> String {
        let fragments = parts
            .map(sanitize)
            .filter { !$0.isEmpty }

        return fragments.joined(separator: "_")
    }

    public static func isReserved(_ key: String) -> Bool {
        reserved.contains(key)
    }
}

==== AILibS/ClassifierKit/MCQTemplate.swift ====


import Foundation

public struct MCQTemplate: Codable, Sendable, Equatable {
    public var schemaVersion: Int
    public var title: String?
    public var includeEventEcho: Bool
    public var eventEchoRequired: Bool

    public var context: String?

    public var fields: [MCQField]

    public init(
        schemaVersion: Int,
        title: String? = nil,
        includeEventEcho: Bool = true,
        eventEchoRequired: Bool = false,
        context: String? = nil,
        fields: [MCQField]
    ) {
        self.schemaVersion = schemaVersion
        self.title = title
        self.includeEventEcho = includeEventEcho
        self.eventEchoRequired = eventEchoRequired
        self.context = context
        self.fields = fields
    }

    public static func decode(jsonString: String) throws -> MCQTemplate {
        let data = Data(jsonString.utf8)
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase

        do {
            return try decoder.decode(MCQTemplate.self, from: data)
        } catch {
            throw ClassifierError.invalidTemplate(reason: "Template JSON decode failed: \(error.localizedDescription)")
        }
    }

    public func validated(
        requiringFallbackOptions: Bool = true,
        maxContextCharacters: Int = 20_000,
        maxFieldContextCharacters: Int = 4_000
    ) throws -> MCQTemplate {
        var reasons: [String] = []

        if schemaVersion <= 0 {
            reasons.append("schemaVersion must be > 0.")
        }

        if fields.isEmpty {
            reasons.append("fields must not be empty.")
        }

        if !includeEventEcho && eventEchoRequired {
            reasons.append("eventEchoRequired=true requires includeEventEcho=true.")
        }

        if let c = context?.trimmingCharacters(in: .whitespacesAndNewlines),
           !c.isEmpty,
           c.count > maxContextCharacters {
            reasons.append("context is too large (>\(maxContextCharacters) characters).")
        }

        let reservedKeys: Set<String> = ["schema_version", "event_echo"]

        let rawKeys = fields.map { $0.key.trimmingCharacters(in: .whitespacesAndNewlines) }
        if rawKeys.contains(where: { $0.isEmpty }) {
            reasons.append("Each field.key must be non-empty.")
        }

        let uniqueKeys = Set(rawKeys)
        if uniqueKeys.count != rawKeys.count {
            let duplicates = Dictionary(grouping: rawKeys, by: { $0 })
                .filter { $1.count > 1 }
                .keys
                .sorted()
            reasons.append("Duplicate field keys: \(duplicates.joined(separator: ", ")).")
        }

        for key in rawKeys where !key.isEmpty {
            if reservedKeys.contains(key) {
                reasons.append("Field key \"\(key)\" is reserved (schema_version/event_echo).")
            }

            let allowed = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: "_"))
            let isSafe = key.unicodeScalars.allSatisfy { allowed.contains($0) }
            if !isSafe {
                reasons.append("Field key \"\(key)\" must use only [A-Za-z0-9_].")
            }
        }

        for field in fields {
            let k = field.key.trimmingCharacters(in: .whitespacesAndNewlines)
            if k.isEmpty { continue }

            if field.options.isEmpty {
                reasons.append("Field \"\(k)\" must have at least one option.")
                continue
            }

            let optionValues = field.options.map { $0.value.trimmingCharacters(in: .whitespacesAndNewlines) }
            if optionValues.contains(where: { $0.isEmpty }) {
                reasons.append("Field \"\(k)\" has an option with empty value.")
            }

            let uniqueOptionValues = Set(optionValues)
            let allowedValueChars = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: "_"))
            for v in optionValues where !v.isEmpty {
                let isSafe = v.unicodeScalars.allSatisfy { allowedValueChars.contains($0) }
                if !isSafe {
                    reasons.append("Field \"\(k)\" option value \"\(v)\" must use only [A-Za-z0-9_].")
                }
            }

            if let fc = field.context?.trimmingCharacters(in: .whitespacesAndNewlines),
               !fc.isEmpty,
               fc.count > maxFieldContextCharacters {
                reasons.append("Field \"\(k)\" context is too large (>\(maxFieldContextCharacters) characters).")
            }

            if uniqueOptionValues.count != optionValues.count {
                let duplicates = Dictionary(grouping: optionValues, by: { $0 })
                    .filter { $1.count > 1 }
                    .keys
                    .sorted()
                reasons.append("Field \"\(k)\" has duplicate option values: \(duplicates.joined(separator: ", ")).")
            }

            if requiringFallbackOptions {
                let hasUnclear = uniqueOptionValues.contains("unclear")
                let hasNoChange = uniqueOptionValues.contains("no_change")
                if !hasUnclear || !hasNoChange {
                    reasons.append("Field \"\(k)\" must include fallback options \"unclear\" and \"no_change\".")
                }
            }
        }

        if !reasons.isEmpty {
            throw ClassifierError.invalidTemplate(reason: reasons.joined(separator: " "))
        }

        var out = self
        out.title = title?.trimmingCharacters(in: .whitespacesAndNewlines)

        let trimmedContext = context?.trimmingCharacters(in: .whitespacesAndNewlines)
        out.context = (trimmedContext?.isEmpty == false) ? trimmedContext : nil

        out.fields = fields.map { $0.normalized() }
        return out
    }
}

public struct MCQField: Codable, Sendable, Equatable {
    public var key: String
    public var promptTitle: String?

    public var context: String?

    public var required: Bool
    public var options: [MCQOption]

    public init(
        key: String,
        promptTitle: String? = nil,
        context: String? = nil,
        required: Bool = true,
        options: [MCQOption]
    ) {
        self.key = key
        self.promptTitle = promptTitle
        self.context = context
        self.required = required
        self.options = options
    }

    fileprivate func normalized() -> MCQField {
        var f = self
        f.key = key.trimmingCharacters(in: .whitespacesAndNewlines)
        f.promptTitle = promptTitle?.trimmingCharacters(in: .whitespacesAndNewlines)

        let trimmedContext = context?.trimmingCharacters(in: .whitespacesAndNewlines)
        f.context = (trimmedContext?.isEmpty == false) ? trimmedContext : nil

        f.options = options.map { $0.normalized() }
        return f
    }
}

public struct MCQOption: Codable, Sendable, Equatable {
    public var value: String
    public var label: String?
    public var meaning: String?

    public init(value: String, label: String? = nil, meaning: String? = nil) {
        self.value = value
        self.label = label
        self.meaning = meaning
    }

    fileprivate func normalized() -> MCQOption {
        var o = self
        o.value = value.trimmingCharacters(in: .whitespacesAndNewlines)
        o.label = label?.trimmingCharacters(in: .whitespacesAndNewlines)
        o.meaning = meaning?.trimmingCharacters(in: .whitespacesAndNewlines)
        return o
    }
}

==== AILibS/ClassifierKit/OllamaChatModels.swift ====


import Foundation

public struct OllamaChatMessage: Codable, Sendable, Equatable {
    public enum Role: String, Codable, Sendable {
        case system
        case user
        case assistant
    }

    public let role: Role
    public let content: String

    public init(role: Role, content: String) {
        self.role = role
        self.content = content
    }
}

public struct OllamaChatOptions: Codable, Sendable, Equatable {
    public var temperature: Double?

    public var seed: Int?

    public init(temperature: Double? = nil, seed: Int? = nil) {
        self.temperature = temperature
        self.seed = seed
    }

    public static var deterministic: OllamaChatOptions {
        .init(temperature: 0.0, seed: 42)
    }
}

public struct OllamaChatRequest: Encodable, Sendable {
    public let model: String
    public let messages: [OllamaChatMessage]
    public let stream: Bool
    public let format: JSONValue?
    public let options: OllamaChatOptions?

    public init(
        model: String,
        messages: [OllamaChatMessage],
        stream: Bool,
        format: JSONValue?,
        options: OllamaChatOptions?
    ) {
        self.model = model
        self.messages = messages
        self.stream = stream
        self.format = format
        self.options = options
    }
}

public struct OllamaChatResponse: Decodable, Sendable {
    public let message: OllamaChatMessage

    public let model: String?
    public let createdAt: String?
    public let done: Bool?

    public enum CodingKeys: String, CodingKey {
        case message
        case model
        case createdAt = "created_at"
        case done
    }
}

==== AnimLibS/Brain/BrainAnimationSequence.swift ====

import CoreLib
import RealityKit

enum buildAnimationSequenceOutcome {
    case tooEarly
    case done
    case alreadyReady
    case failed
}

@MainActor // Debug: to delete //ðŸ‘€
func buildAnimationSequence(
    entity: Entity, // Debug: to delete //ðŸ‘€
    currentAnimationSequence: inout [AnimationSequenceElement],
    initAnimationSequenceIndex: inout Int,
    styleGuide: inout StyleGuide,
    travelGuide: inout TravelGuide,
    eventComponent: EventComponent?, // Debug: to delete //ðŸ‘€
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    var isSuccess: buildAnimationSequenceOutcome = .failed

    guard let transitionableIndex = findNextTransitionableCurrentSequenceIndex(
        currentIndex: initAnimationSequenceIndex,
        animationSequence: currentAnimationSequence,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("ðŸ§  Error: No animation segments after custom animation segments.")
        return .failed
    }

    guard transitionableIndex == 0 else {
        AppLogger.shared.anim("ðŸ§  Too early to transition. Skipping buildAnimationSequence.")
        return .tooEarly
    }

    if transitionableIndex + 1 < currentAnimationSequence.count,
       currentAnimationSequence[transitionableIndex + 1].isReadyToPlay == true,
       styleGuide.targets[0].isNew == false
    {
        AppLogger.shared.anim("ðŸ§  Next element already ready to play. Skipping buildAnimationSequence.")
        return .alreadyReady
    }

    let initAnimationSequenceElement = currentAnimationSequence[transitionableIndex]
    
    
    guard
        let currentFrame = initAnimationSequenceElement.currentFrame,
        let endPoseFrame = initAnimationSequenceElement.endPoseFrame
    else {
        AppLogger.shared.error("ðŸ§  Error: Current frame or end pose frame is nil.")
        return .failed
    }
    
    

    let initMoveType = initAnimationSequenceElement.endPoseName.moveType
    
    if let firstTargetDestination = travelGuide.targetDestinations.first {
        AppLogger.shared.anim("ðŸ§  TravelGuide First Destination: inPlace: \(firstTargetDestination.inPlace)  |  isNew: \(firstTargetDestination.isNew)")
    } else {
        AppLogger.shared.anim("ðŸ§  TravelGuide: no destinations.")
    }

    switch initMoveType {
    case .walk:
        
        guard initAnimationSequenceElement.isNearEndOfSegment() else {
            if printBrainSystem {
                AppLogger.shared.anim("Too early to construct walkâ€‘toâ€‘walk transition; segment not yet close to the end.")
            }
            return .tooEarly
        }

        AppLogger.shared.anim("Current move type is walk.")
        isSuccess = constructWalkSequence(
            animationSequence: &currentAnimationSequence,
            initIndex: transitionableIndex,
            styleGuide: &styleGuide,
            travelGuide: &travelGuide,
            entityWorldTransform: entity.transform,
            dataManager: dataManager
        )
        return isSuccess

    case .idle:
        AppLogger.shared.anim("Current move type is idle.")
        isSuccess = constructIdleSequence(
            animationSequence: &currentAnimationSequence,
            initIndex: transitionableIndex,
            styleGuide: &styleGuide,
            travelGuide: &travelGuide,
            entityWorldTransform: entity.transform,
            dataManager: dataManager
        )
        return isSuccess

    case .transition:
        AppLogger.shared.anim("Current move type is transition.")
        return .failed

    case .other:
        AppLogger.shared.error("Error: Undetermined init move type.")
        return .failed
    }
    

}

func findNextTransitionableCurrentSequenceIndex(
    currentIndex: Int?,
    animationSequence: [AnimationSequenceElement],
    dataManager: DataManager
) -> Int? {
    var index = currentIndex

    while let idx = index, idx < animationSequence.count {
        let currentElement = animationSequence[idx]
        let animationName = currentElement.animationName

        if currentElement.endPoseName.moveType != .transition {
            if printBrainSystem {
                AppLogger.shared.anim("Found non-transition segment at index \(idx): \(animationName) (endPose \(currentElement.endPoseName)).")
            }
            break
        }
        else {
            index = idx + 1
        }
    }

    if let finalIndex = index, finalIndex >= animationSequence.count {
        AppLogger.shared.error("Error: [2] Index \(finalIndex) is out of bounds. Returning nil.")
        return nil
    }

    return index
}

==== AnimLibS/Brain/Travel&StyleEvents.swift ====


import Foundation
import joystickController
import RealityKit
import simd


func setAnimationStyleWithButton(
    styleGuides: [StyleGuide],
    eventComponent: inout EventComponent,
    dataProvider: JoystickDataProvider
)
{
    let wasHolding = eventComponent.lastButtonState
    let isHolding = dataProvider.isHoldingButton

    if wasHolding, !isHolding, // released this frame
       !styleGuides.isEmpty
    {
        let next = (eventComponent.currentGuideIndex + 1) % styleGuides.count
        eventComponent.currentGuideIndex = next

        var guide = styleGuides[next]
        guide.targets = guide.targets.map
        { tgt in
            var t = tgt; t.isNew = true; return t
        }
        eventComponent.styleGuide = guide
    }

    eventComponent.lastButtonState = isHolding
}


private func travelGuideFromJoystickTouching(fromJoystickAngle Ï†: Float,
                                             cameraYaw Ïˆ: Float,
                                             distance: Float = 10) -> TravelGuide
{
    let vCam = SIMD3<Float>(sin(Ï†), 0, -cos(Ï†)) * distance
    let sinÏˆ = sin(Ïˆ), cosÏˆ = cos(Ïˆ)
    let x = vCam.x * cosÏˆ + vCam.z * sinÏˆ // rotate by â€“Ïˆ  (correct sign)
    let z = -vCam.x * sinÏˆ + vCam.z * cosÏˆ

    let target = TravelTarget(
        inPlace: false,
        location: SIMD3<Float>(x, 0, z),
        rotation: simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0)), // face forward
        areaScope: .point,
        isTransit: true,
        id: UUID().uuidString,
        isNew: true)

    return TravelGuide(targetDestinations: [target], estPathway: [])
}


private func travelGuideInPlace(entityWorldTransform: Transform) -> TravelGuide
{
    let target = TravelTarget(
        inPlace: true,
        location: entityWorldTransform.translation,
        rotation: entityWorldTransform.rotation,
        areaScope: .point,
        isTransit: false,
        id: UUID().uuidString,
        isNew: true)
    return TravelGuide(targetDestinations: [target], estPathway: [])
}


func travelGuideFromJoystick(
    dataProvider: JoystickDataProvider,
    entityWorldTransform: Transform,
    distance: Float = 10
) -> TravelGuide
{
    if dataProvider.joystickIsTouching
    {
        let Ï† = Float(dataProvider.joystickAngle.radians)
        let Ïˆ = Float(dataProvider.cameraYaw.radians)
        return travelGuideFromJoystickTouching(fromJoystickAngle: Ï†,
                                               cameraYaw: Ïˆ,
                                               distance: distance)
    }
    else
    {
        return travelGuideInPlace(entityWorldTransform: entityWorldTransform)
    }
}

==== AnimLibS/Brain/Idle/0-IdleSequence.swift ====


import CoreLib
import RealityKit
import simd


func constructIdleSequence(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    styleGuide: inout StyleGuide,
    travelGuide: inout TravelGuide,
    entityWorldTransform: Transform,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    if printBrainSystem { AppLogger.shared.anim("ðŸ§  Constructing idle sequence") }

    let currentElement = animationSequence[initIndex]


    var nextMoveType: MoveType? = .idle
    if travelGuide.targetDestinations.count > 0, travelGuide.targetDestinations[0].inPlace == false {
        nextMoveType = .walk
    } else if travelGuide.targetDestinations.count == 0 {
        AppLogger.shared.error("ðŸ§  Error: No destinations found.")
    }

    AppLogger.shared.anim("ðŸ§  Currently in Idle. Next move type is \(String(describing: nextMoveType)).")

    let isNearEndOfSequence = (animationSequence.count == 1 && currentElement.isNearEndOfSegment())

    let isNewOrientation = !validateIdleAlignment(travelGuide: travelGuide, entityWorldTransform: entityWorldTransform)


    let animStyle = styleGuide.targets[0]
    let needToTransition = animStyle.isNew || isNewOrientation || nextMoveType != .idle

    guard isNearEndOfSequence || needToTransition else {
        AppLogger.shared.anim("ðŸ§  Too early to construct idle sequence. Neither of conditions are true: isNearEndOfSequence: \(isNearEndOfSequence), animStyle.isNew: \(animStyle.isNew), isNewOrientation: \(isNewOrientation), nextMoveType: \(String(describing: nextMoveType)).")
        return .tooEarly
    }


    if needToTransition == false {
        let extensionResult = extendAnimationSequence(
            animationSequence: &animationSequence,
            isFilledOut: false,
            dataManager: dataManager
        )
        if extensionResult == .done {
            AppLogger.shared.debug("âš§ï¸ Extended sequence without transitions.")
            animationSequence[initIndex + 1].isReadyToPlay = true
            return .done
        }
    }


    guard let (lastIndexBeforeTransition, transitionFrame) = findTransitionStart(
        from: initIndex,
        in: &animationSequence,
        dataManager: dataManager,
        printBrainSystem: printBrainSystem
    ) else {
        AppLogger.shared.error("ðŸ§  Error: Failed to find lastIndexBeforeTransition.")
        return .failed
    }

    let startAnimationName = animationSequence[lastIndexBeforeTransition].animationName



    let transitionID: String
    let endAnimationName: String
    let endCriticalPoseIndex: Int

    if nextMoveType == .idle {
        AppLogger.shared.anim("ðŸ§  Constructing Idle To Idle sequence.")

        guard let (_transitionID, _endAnimationName, _endCriticalPoseIndex) = determineIdleToIdleTransitionAndTarget(
            lastElementBelforeTransition: animationSequence[lastIndexBeforeTransition],
            animStyle: animStyle,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("ðŸ§  Error: Failed to build idle to idle sequence.")
            return .failed
        }
        (transitionID, endAnimationName, endCriticalPoseIndex) = (_transitionID, _endAnimationName, _endCriticalPoseIndex)
    } else if nextMoveType == .walk {
        AppLogger.shared.anim("ðŸ§  Constructing Idle To Walk sequence.")

        guard let (_transitionID, _endAnimationName, _endCriticalPoseIndex) = determineIdleToWalkTransitionAndTarget(
            lastElementBelforeTransition: animationSequence[lastIndexBeforeTransition],
            animStyle: animStyle,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("ðŸ§  Error: Failed to build idle to idle sequence.")
            return .failed
        }
        (transitionID, endAnimationName, endCriticalPoseIndex) = (_transitionID, _endAnimationName, _endCriticalPoseIndex)
    } else {
        AppLogger.shared.error("ðŸ§  Error: Invalid move type \(String(describing: nextMoveType)).")
        return .failed
    }



    let buildResult = buildTransitionSequence(
        animationSequence: &animationSequence,
        lastIndexBeforeTransition: lastIndexBeforeTransition,
        transitionFrame: transitionFrame,
        transitionID: transitionID,
        startAnimationName: startAnimationName,
        endAnimationName: endAnimationName,
        endCriticalPoseIndex: endCriticalPoseIndex,
        styleGuide: &styleGuide,
        dataManager: dataManager
    )

    guard buildResult == .done else {
        AppLogger.shared.error("ðŸ§  Error: Failed to build transition sequence.")
        return .failed
    }


    assignInertialInfoForIdle(
        animationSequence: &animationSequence,
        initIndex: initIndex,
        dataManager: dataManager
    )


    for i in initIndex + 1 ..< animationSequence.count {
        animationSequence[i].isFilledOut = true
    }

    animationSequence[initIndex + 1].isReadyToPlay = true

    if !styleGuide.targets.isEmpty {
        styleGuide.targets[0].isNew = false
    }

    return .done
}


private func determineIdleToWalkTransitionAndTarget(
    lastElementBelforeTransition element: AnimationSequenceElement,
    animStyle: StyleTarget,
    dataManager: DataManager
) -> (transitionID: String, endAnimationName: String, endCriticalPoseIndex: Int)? {
    let endAnimation: String
    if let newAnimDataPoint = dataManager.getAnimDataPoint(for: animStyle.animationName),
       newAnimDataPoint.moveList.contains(.walk)
    {
        endAnimation = animStyle.animationName
    } else {
        AppLogger.shared.error("ðŸ§  Error: The move target \(animStyle.animationName) is not a Walk animation. Reverting to default walk animation")
        endAnimation = defaultWalkAnimation
    }

    guard let startCriticalPoseIndex = element.endPoseIndex else {
        AppLogger.shared.error("ðŸ§  Error: endPoseIndex is nil for \(element.animationName).")
        return nil
    }

    guard
        let (transitionID, endPoseIdx) =
        selectIdleToWalkTransitionAndEndAnimations(
            startAnimationName: element.animationName,
            startCriticalPoseIndex: startCriticalPoseIndex,
            endAnimationName: endAnimation,
            endCriticalPoseIndex: nil,
            dataManager: dataManager
        )
    else {
        AppLogger.shared.error("ðŸ§  Error: Failed to select transition and end animations for idle-to-walk sequence.")
        return nil
    }

    return (transitionID, endAnimation, endPoseIdx)
}


private func determineIdleToIdleTransitionAndTarget(
    lastElementBelforeTransition: AnimationSequenceElement,
    animStyle: StyleTarget,
    dataManager: DataManager
) -> (transitionID: String, endAnimationName: String, endCriticalPoseIndex: Int)? {
    if printBrainSystem { AppLogger.shared.anim("ðŸ§  The move target is Idle") }

    let startElement = lastElementBelforeTransition
    let startAnimationName = startElement.animationName
    guard let startAnimeDataPoint = dataManager.getAnimDataPoint(for: startAnimationName) else {
        AppLogger.shared.error("ðŸ§  Error: Animation data point not found for \(startAnimationName).")
        return nil
    }

    let endAnimationName: String

    if animStyle.isNew {
        endAnimationName = animStyle.animationName
    } else if startAnimeDataPoint.isLoop {
        endAnimationName = startAnimationName
    } else {
        endAnimationName = defaultIdleAnimation
    }

    guard let startCriticalPoseIndex = startElement.endPoseIndex else {
        AppLogger.shared.error("ðŸ§  Error: endPoseIndex is nil for \(startAnimationName).")
        return nil
    }

    guard let (transitionID, endAnimationName, endCriticalPoseIndex) = selectIdleToIdleTransitionAndEndAnimations(
        startAnimationName: startAnimationName,
        startCriticalPoseIndex: startCriticalPoseIndex,
        endAnimationDict: [endAnimationName: nil], // animationÂ â†’Â criticalPoseIdx
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("ðŸ§  Error: Failed to select transition and end animations.")
        return nil
    }

    return (transitionID, endAnimationName, endCriticalPoseIndex)
}

func findTransitionStart(
    from initIndex: Int,
    in animationSequence: inout [AnimationSequenceElement],
    dataManager: DataManager,
    printBrainSystem: Bool = printBrainSystem
) -> (startIndex: Int, transitionFrame: Int)? {
    let originalCount = animationSequence.count

    for idx in initIndex ..< originalCount {
        guard let endFrame = animationSequence[idx].endPoseFrame else {
            AppLogger.shared.error("ðŸ§  Error: endPoseFrame is nil for index \(idx).")
            return nil
        }
        let footBones: Set<ExplicitBoneName> = [.leftFoot, .rightFoot]
        if footBones.contains(animationSequence[idx].endPoseName.groundBone) {
            if printBrainSystem {
                AppLogger.shared.anim("ðŸ§  Transition point found at index \(idx), frame \(endFrame)")
            }
            return (idx, endFrame)
        }
    }

    if printBrainSystem {
        AppLogger.shared.debug("ðŸ§  No both-feet-grounded in existing elements; extending idle sequence once")
    }
    let extensionResult = extendAnimationSequence(
        animationSequence: &animationSequence,
        isFilledOut: false,
        dataManager: dataManager
    )
    guard extensionResult == .done else {
        AppLogger.shared.error("ðŸ§  Error: Failed to extend the animation sequence.")
        return nil
    }

    for idx in originalCount ..< animationSequence.count {
        guard let endFrame = animationSequence[idx].endPoseFrame else {
            AppLogger.shared.error("ðŸ§  Error: endPoseFrame is nil for index \(idx).")
            return nil
        }
        if animationSequence[idx].endPoseName.bothFeet == .ground {
            if printBrainSystem {
                AppLogger.shared.anim("ðŸ§  Transition point found at index \(idx), frame \(endFrame)")
            }
            return (idx, endFrame)
        }
    }

    AppLogger.shared.error("ðŸ§  Error: No both-feet-grounded element found even after one extension.")
    return nil
}


private func buildTransitionSequence(
    animationSequence: inout [AnimationSequenceElement],
    lastIndexBeforeTransition: Int,
    transitionFrame: Int,
    transitionID: String,
    startAnimationName: String,
    endAnimationName: String,
    endCriticalPoseIndex: Int,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {

    guard
        let endAnimDP = dataManager.getAnimDataPoint(for: endAnimationName),
        endCriticalPoseIndex < endAnimDP.criticalPoses.count
    else {
        AppLogger.shared.error("ðŸ§  Error: Animation data point not found for \(endAnimationName).")
        return .failed
    }
    let frameForEndAnimation = endAnimDP.criticalPoses[endCriticalPoseIndex].frame

    guard let transitionSequenceData = dataManager.getTransitionSequence(sequenceID: transitionID) else {
        AppLogger.shared.error("ðŸ§  Error: Transition sequence not found for \(transitionID).")
        return .failed
    }

    AppLogger.shared.anim("ðŸ§  Transition sequence: \(transitionID) / \(startAnimationName) / \(endAnimationName)")
    guard let transitionSequence = buildIdleToIdleTransitionSequence(
        transitionID: transitionID,
        startAnimationName: startAnimationName,
        frameForStartAnimation: transitionFrame,
        endAnimationName: endAnimationName,
        frameForEndAnimation: frameForEndAnimation,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("ðŸ§  Error: Transition sequence not found for \(transitionID).")
        return .failed
    }

    let spliceIdx = lastIndexBeforeTransition + 1
    if spliceIdx < animationSequence.count {
        animationSequence.removeSubrange(spliceIdx ..< animationSequence.count)
    }

    if transitionSequenceData.transitionType == .idleToIdle {
        animationSequence.append(contentsOf: transitionSequence)


        guard let endAnimSeq = constructAnimationSequenceForGivenAnimation(
            animationName: endAnimationName,
            startCriticalPoseIndex: endCriticalPoseIndex,
            endCriticalPoseIndex: nil, // Search to end / full loop
            isFilledOut: false,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("ðŸ§  Error: Failed to construct animation sequence for \(endAnimationName).")
            return .failed
        }
        animationSequence.append(contentsOf: endAnimSeq)

        return .done
    }


    else if transitionSequenceData.transitionType == .idleToWalk {


        let lastNonWalkIdx = transitionSequence.lastIndex(where: {
            $0.startPoseName.moveType != .walk
        })

        let idleToWalkElements: [AnimationSequenceElement]
        let walkElements: [AnimationSequenceElement]

        if let n = lastNonWalkIdx {
            idleToWalkElements = Array(transitionSequence[...n])
            walkElements = (n + 1 < transitionSequence.count)
                ? Array(transitionSequence[(n + 1)...])
                : []
        } else {
            idleToWalkElements = []
            walkElements = transitionSequence
        }

        animationSequence.append(contentsOf: idleToWalkElements)

        guard let lastPoseName = animationSequence.last?.endPoseName else {
            AppLogger.shared.error("ðŸ§  Error: Unable to determine last endPoseName for transition sequence.")
            return .failed
        }
        guard let matchingIndices = dataManager.getIndicesOfCriticalPose(
            for: endAnimationName,
            matching: lastPoseName
        ),
            let newStartPoseIndex = matchingIndices.first
        else {
            AppLogger.shared.error(
                "ðŸ§  Error: No matching critical pose '\(lastPoseName)' found in \(endAnimationName)."
            )
            return .failed
        }

        let outcome = transitionToNewStyle(
            currentExtension: walkElements, // this is only the current sequence portion that goes into blendTree
            newAnimationName: endAnimationName,
            startPoseIndex: newStartPoseIndex,
            sequence: &animationSequence,
            styleGuide: &styleGuide,
            fullStepCount: fullStepCount,
            dataManager: dataManager
        )
        return outcome
    } else {
        AppLogger.shared.error("ðŸ§  Error: Unknown transition type \(transitionSequenceData.transitionType).")
        return .failed
    }
}

==== AnimLibS/Brain/Idle/2-pick-transition.swift ====


import CoreLib
import RealityKit
import simd


func selectIdleToIdleTransitionAndEndAnimations(
    startAnimationName: String,
    startCriticalPoseIndex: Int,
    endAnimationDict: [String: Int?]?, // animationÂ â†’Â criticalPoseIdx?
    dataManager: DataManager
) -> (String, String, Int)? { // (transitionID, endAnim, idx)
    let transitionType: TransitionType = .idleToIdle
    let transitionSubType: TransitionSubType = .legOff

    guard
        let startAnimDataPoint = dataManager.getAnimDataPoint(for: startAnimationName),
        startCriticalPoseIndex >= 0,
        startCriticalPoseIndex < startAnimDataPoint.criticalPoses.count
    else {
        AppLogger.shared.error("Error: selectTransitionAndEndAnimations: Invalid start animation â€˜\(startAnimationName)â€™ or pose indexÂ \(startCriticalPoseIndex).")
        return nil
    }

    let startCriticalPose = startAnimDataPoint.criticalPoses[startCriticalPoseIndex]
    let footOnGroundStart = startCriticalPose.poseName.sideOnGround

    guard
        let startGlobals = startCriticalPose.globalTransform,
        let leftStart = startGlobals[.leftFoot]?.location,
        let rightStart = startGlobals[.rightFoot]?.location
    else {
        AppLogger.shared.error("Error: selectTransitionAndEndAnimations: startCriticalPose has no globalTransform.")
        return nil
    }

    guard startCriticalPose.poseName.moveType == .idle else {
        AppLogger.shared.error("Error: in builing IdleToIdle transition sequence, startCriticalPose is not idle but \(startCriticalPose.poseName.moveType): \(startCriticalPose.poseName).")
        return nil
    }

    var candidatesEndAnims: [(name: String, index: Int?)] = []

    if let dict = endAnimationDict, dict.isEmpty == false {
        for (name, poseIdxOpt) in dict { // explicit list supplied
            candidatesEndAnims.append((name, poseIdxOpt))
        }
    } else {
        candidatesEndAnims.append((defaultIdleAnimation, nil))
    }

    var overallBest: (sequenceID: String, endAnim: String, endPoseIdx: Int, totalScore: Float)?

    for (endAnimationName, explicitPoseIdx) in candidatesEndAnims {
        guard let endAnimDataPoint = dataManager.getAnimDataPoint(for: endAnimationName) else {
            AppLogger.shared.error("Error: selectTransitionAndEndAnimations: No data for end animation â€˜\(endAnimationName)â€™.Â Skippingâ€¦")
            continue
        }

        let resolvedEndPoses: [CriticalPose] = {
            if let idx = explicitPoseIdx,
               idx >= 0, idx < endAnimDataPoint.criticalPoses.count
            {
                return [endAnimDataPoint.criticalPoses[idx]]
            }
            if !endAnimDataPoint.isLoop, let first = endAnimDataPoint.criticalPoses.first {
                return [first]
            }
            var poses = endAnimDataPoint.criticalPoses.filter { $0.poseName.bothFeet == .ground }
            if poses.isEmpty {
                poses = endAnimDataPoint.criticalPoses.filter { $0.poseName.bothLegs == .ground }
            }
            if poses.isEmpty {
                poses = endAnimDataPoint.criticalPoses.filter { $0.poseName.poseType != .high }
            }
            if poses.isEmpty, let first = endAnimDataPoint.criticalPoses.first {
                poses = [first]
            }
            return poses
        }()

        if resolvedEndPoses.isEmpty {
            AppLogger.shared.error("Error: selectTransitionAndEndAnimations: No landing poses in â€˜\(endAnimationName)â€™.Â Skippingâ€¦")
            continue
        }

        let transitionSequenceCandidates = dataManager.transitionSequences(
            transitionType: [transitionType],
            transitionSubType: [transitionSubType],
            footOnGroundStart: footOnGroundStart,
            footOnGroundEnd: resolvedEndPoses.first!.poseName.sideOnGround
        )

        if transitionSequenceCandidates.isEmpty { continue }

        let (sortedTransitions, startScores) = orderedTransitions(
            transitionCandidates: transitionSequenceCandidates,
            targetLeftFoot: leftStart,
            targetRightFoot: rightStart,
            startOrEnd: .start
        )

        AppLogger.shared.debug("âš§ï¸ Transition candidates sequence IDs and scores: \(sortedTransitions.map { $0.sequenceID }) \(startScores)")

        guard let (bestSeq, bestPose, total) = bestTransitionForEndPoses(
            candidates: sortedTransitions,
            startScores: startScores,
            endPoses: resolvedEndPoses
        ) else {
            continue // no viable pairing for this clip
        }

        guard let bestPoseIdx = dataManager.getIndexOfCriticalPose(for: endAnimationName, at: bestPose.frame) else {
            continue
        }

        if let current = overallBest {
            if total < current.totalScore {
                overallBest = (bestSeq.sequenceID, endAnimationName, bestPoseIdx, total)
            }
        } else {
            overallBest = (bestSeq.sequenceID, endAnimationName, bestPoseIdx, total)
        }
    }

    if let best = overallBest {
        return (best.sequenceID, best.endAnim, best.endPoseIdx)
    }

    AppLogger.shared.error("Error: selectTransitionAndEndAnimations: No usable transition found across \(candidatesEndAnims) endâ€‘clips.")
    return nil
}


func selectIdleToWalkTransitionAndEndAnimations(
    startAnimationName: String,
    startCriticalPoseIndex: Int,
    endAnimationName: String,
    endCriticalPoseIndex: Int?,
    dataManager: DataManager
) -> (String, Int)? {                                 // (transitionID, endPoseIdx)
    let transitionType: TransitionType = .idleToWalk

    guard
        let startAnim = dataManager.getAnimDataPoint(for: startAnimationName),
        startCriticalPoseIndex >= 0,
        startCriticalPoseIndex < startAnim.criticalPoses.count
    else {
        AppLogger.shared.error("Error: select IdleToWalk: bad start â€˜\(startAnimationName)â€™ / index \(startCriticalPoseIndex)")
        return nil
    }

    let startPose         = startAnim.criticalPoses[startCriticalPoseIndex]
    let footOnGroundStart = startPose.poseName.sideOnGround

    guard
        let g          = startPose.globalTransform,
        let leftStartLocation  = g[.leftFoot]?.location,
        let rightStartLocation = g[.rightFoot]?.location
    else {
        AppLogger.shared.error("Error: select IdleToWalk: start pose lacks globals")
        return nil
    }

    guard startPose.poseName.moveType == .idle else {
        AppLogger.shared.error("Error: select IdleToWalk: start pose is not idle")
        return nil
    }

    guard let endAnim = dataManager.getAnimDataPoint(for: endAnimationName) else {
        AppLogger.shared.error("Error: select IdleToWalk: no data for end anim â€˜\(endAnimationName)â€™")
        return nil
    }

    let candidates = dataManager.transitionSequences(
        transitionType: [transitionType],
        footOnGroundStart: footOnGroundStart,
        footOnGroundEnd: nil
    )

    guard !candidates.isEmpty else {
        AppLogger.shared.error("Error: select IdleToWalk: no \(transitionType) sequences found")
        return nil
    }

    let (sorted, _) = orderedTransitions(
        transitionCandidates: candidates,
        targetLeftFoot:  leftStartLocation,
        targetRightFoot: rightStartLocation,
        startOrEnd:      .start
    )

    if let explicit = endCriticalPoseIndex,
       explicit >= 0, explicit < endAnim.criticalPoses.count,
       let best = sorted.first {
        return (best.sequenceID, explicit)
    }

    for transition in sorted {
        guard let exitName = transition.transitionPoses.last?.criticalPoseName else { continue }

        if let indices = dataManager.getIndicesOfCriticalPose(for: endAnimationName,
                                                              matching: exitName),
           let landing = indices.min() {                      // choose earliest
            return (transition.sequenceID, landing)
        }
    }

    if let best = sorted.first, !endAnim.criticalPoses.isEmpty {
        return (best.sequenceID, 0)
    }

    AppLogger.shared.error("Error: select IdleToWalk: no usable transition for \(endAnimationName)")
    return nil
}


private func bestTransitionForEndPoses(
    candidates: [TransitionSequence],
    startScores: [Float],
    endPoses: [CriticalPose]
) -> (TransitionSequence, CriticalPose, Float)? { // (seq, pose, totalScore)
    precondition(candidates.count == startScores.count, "Candidates & scores misâ€‘aligned")

    var fallbackBest: (seq: TransitionSequence, pose: CriticalPose, total: Float)?

    for (idx, transition) in candidates.enumerated() {
        let startScore = startScores[idx]

        var bestEndScore: Float = .greatestFiniteMagnitude
        var bestPose: CriticalPose?

        for pose in endPoses {
            guard
                let g = pose.globalTransform,
                let l = g[.leftFoot]?.location,
                let r = g[.rightFoot]?.location
            else { continue }

            let targetVec = normalizedFootVector(leftFoot: l, rightFoot: r)
            let transVec = normalizedFootVector(
                leftFoot: transition.feetGlobalTransformEnd.leftFootTransform.translation,
                rightFoot: transition.feetGlobalTransformEnd.rightFootTransform.translation
            )
            let endScore = pow(distance(transVec, targetVec), 2)
            if endScore < bestEndScore {
                bestEndScore = endScore
                bestPose = pose
            }
        }

        guard let poseChosen = bestPose else { continue }

        if bestEndScore < startScore {
            return (transition, poseChosen, startScore + bestEndScore)
        }

        let total = startScore + bestEndScore
        if let cur = fallbackBest {
            if total < cur.total {
                fallbackBest = (transition, poseChosen, total)
            }
        } else {
            fallbackBest = (transition, poseChosen, total)
        }
    }

    if let best = fallbackBest {
        return (best.seq, best.pose, best.total)
    }
    return nil
}


private func orderedTransitions(
    transitionCandidates: [TransitionSequence],
    targetLeftFoot: SIMD3<Float>,
    targetRightFoot: SIMD3<Float>,
    startOrEnd: StartEndType
) -> (candidates: [TransitionSequence], scores: [Float]) {
    let targetVec = normalizedFootVector(leftFoot: targetLeftFoot, rightFoot: targetRightFoot)

    var scored: [(TransitionSequence, Float)] = []
    scored.reserveCapacity(transitionCandidates.count)

    for t in transitionCandidates {
        let feet = (startOrEnd == .start) ? t.feetGlobalTransformStart : t.feetGlobalTransformEnd
        let vec = normalizedFootVector(leftFoot: feet.leftFootTransform.translation,
                                       rightFoot: feet.rightFootTransform.translation)
        let s = pow(distance(vec, targetVec), 2)
        scored.append((t, s))
    }

    scored.sort { $0.1 < $1.1 }
    return (scored.map { $0.0 }, scored.map { $0.1 })
}

private func normalizedFootVector(leftFoot: SIMD3<Float>, rightFoot: SIMD3<Float>) -> SIMD3<Float> {
    rightFoot - leftFoot
}

==== AnimLibS/Brain/Walk/0-WalkSequence.swift ====


import CoreLib
import RealityKit
import simd

func constructWalkSequence(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    styleGuide: inout StyleGuide,
    travelGuide: inout TravelGuide,
    entityWorldTransform: Transform,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    if printBrainSystem { AppLogger.shared.anim("ðŸ§  Constructing walk sequence") }
    
    let currentElement = animationSequence[initIndex]
    let isAlmostStepFirstPose = currentElement.endPoseName.isStepFirstPose
    
    
    let recalculatePath = validateExistingPath(
        animationSequence: animationSequence,
        travelGuide: travelGuide,
        startingLocation: .zero,
        entityWorldOrientation: entityWorldTransform.rotation,
        accuracy: travelGuide.veerOffPathDeltaThreshold
    )
    
    AppLogger.shared.debug("DEBUG: recalculatePath: \(recalculatePath), isStepFirstPose: \(isAlmostStepFirstPose), Style: \(styleGuide.targets[0].animationName) [new: \(styleGuide.targets[0].isNew)]")
    
    let keepExistingElements = (recalculatePath == false && styleGuide.targets[0].isNew == false)
    
    let lastIndex = animationSequence.count - 1
    if animationSequence[lastIndex].endPoseName.moveType == .walk {
        extendInitWalkSequence(
            currentAnimationSequence: &animationSequence,
            initAnimationSequenceIndex: initIndex,
            keepExistingElements: keepExistingElements,
            styleGuide: &styleGuide,
            dataManager: dataManager
        )
    }
    
    
    if let isSuccess = attemptTransitionToIdle(
        animationSequence: &animationSequence,
        initIndex: initIndex,
        travelGuide: travelGuide,
        entityWorldTransform: entityWorldTransform,
        threshold: reachedIdleLocationThreshold,
        dataManager: dataManager
    ) {
        return isSuccess
    }
    
    
    guard initIndex + 1 < animationSequence.count else {
        AppLogger.shared.error("ðŸ§  Error: [1] No next element found in the animation sequence.")
        return .failed
    }
    
    guard recalculatePath || isAlmostStepFirstPose else {
        if printBrainSystem {
            AppLogger.shared.anim("No need to adjust the walk sequence - we are mid-step and on the same pathway as before.")
        }
        return .tooEarly
    }
    
    

    
    guard var endLocation = getEndLocation(
        animationSequence: animationSequence,
        startElementIndex: initIndex + 1,
        travelGuide: travelGuide,
        characterOrientation: entityWorldTransform.rotation,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Correction quaternion not found.")
        return .failed
    }
    
    var deltaOrientationQuat = travelGuide.calculatePathCorrectionQuaternion(endLocation: endLocation)
    
    
    if var transitionalAnimationNames = determineWalkTransitionalAnimationCandidates(deltaOrientationQuat: deltaOrientationQuat) {
        if printBrainSystem {
            AppLogger.shared.anim("Rebuilding the init Sequence with a transitional animation.")
        }
        buildWalkTransitionalSequence(
            currentAnimationSequence: &animationSequence,
            initAnimationSequenceIndex: initIndex,
            transitionalAnimationNames: &transitionalAnimationNames,
            dataManager: dataManager
        )

        if let endLocationCalc = getEndLocation(
            animationSequence: animationSequence,
            startElementIndex: initIndex + 1,
            travelGuide: travelGuide,
            characterOrientation: entityWorldTransform.rotation,
            dataManager: dataManager
        ) { endLocation = endLocationCalc } else {
            AppLogger.shared.error("Error: Correction quaternion not found for transitional sequence.")
            return .failed
        }

        deltaOrientationQuat = travelGuide.calculatePathCorrectionQuaternion(endLocation: endLocation)
    }
    
    
    let (pathDistanceBeforeCorrection, _) = travelGuide.distanceToPathway(from: endLocation)
    
    var effectiveOrientationChange: simd_quatf?
    if pathDistanceBeforeCorrection > travelGuide.veerOffPathDeltaThreshold {
        if printBrainSystem {
            AppLogger.shared.anim("DEBUG: Pathway deviation is too large. Suggesting CIR adjustment.")
        }
        effectiveOrientationChange = calculateCirAdjustment(
            animationSequence: &animationSequence,
            startElementIndex: initIndex + 1,
            deltaOrientationQuat: deltaOrientationQuat,
            dataManager: dataManager
        )
    }
    

    let pathDistanceAfterCorrection: Float
    if let effectiveOrientationChange = effectiveOrientationChange {
        pathDistanceAfterCorrection = travelGuide.distanceAfterPathCorrection(location: endLocation, using: effectiveOrientationChange)
    } else {
        pathDistanceAfterCorrection = pathDistanceBeforeCorrection
    }

    if pathDistanceAfterCorrection > travelGuide.veerOffPathDeltaThreshold {
        if printBrainSystem {
            AppLogger.shared.anim("DEBUG: Pathway deviation is too large after correction. Suggesting stride adjustment.")
        }

        adjustStrideLength(
            animationSequence: &animationSequence,
            startElementIndex: initIndex + 1,
            pathDistanceAfterCorrection: pathDistanceAfterCorrection,
            travelGuide: travelGuide,
            dataManager: dataManager
        )
    }

    assignInertialInfoForWalk(
        animationSequence: &animationSequence,
        initIndex: initIndex,
        dataManager: dataManager
    )
    
    for i in initIndex + 1 ..< animationSequence.count {
        animationSequence[i].isFilledOut = true
    }
    
    animationSequence[initIndex + 1].isReadyToPlay = true
    
    if !styleGuide.targets.isEmpty {
        styleGuide.targets[0].isNew = false
    }

    return .done
}


func getEndLocation(
    animationSequence: [AnimationSequenceElement],
    startElementIndex: Int,
    travelGuide: TravelGuide,
    characterOrientation: simd_quatf = simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0)),
    dataManager: DataManager
) -> SIMD3<Float>? {
    var localDisplacement = SIMD3<Float>(repeating: 0)

    for idx in startElementIndex ..< animationSequence.count {
        guard let animDataPoint = dataManager.getAnimDataPoint(
            for: animationSequence[idx].animationName)
        else {
            AppLogger.shared.error(
                "Error: AnimDataPoint not found for \(animationSequence[idx].animationName).")
            return nil
        }

        let deltaLoc = animDataPoint
            .criticalPoses[animationSequence[idx].startPoseIndex]
            .deltaLocation

        localDisplacement += deltaLoc
    }

    let worldDisplacement = characterOrientation.act(localDisplacement)

    return worldDisplacement
}


extension AnimationSequenceElement {
    func remainingPlayableFrames() -> Int? {
        guard let current = currentFrame else { return nil }
        guard let effectiveEnd = earlyStopFrame ?? endPoseFrame else { return nil }
        return effectiveEnd - current // can beÂ â‰¤Â 0 once we run out
    }
    
    func isNearEndOfSegment(systemMultiplier: Float = systemWideSpeedMultiplier) -> Bool {
        guard let left = remainingPlayableFrames() else { return false }
        return Float(left) <= max(3 * systemMultiplier, 2)
    }
}

==== AnimLibS/Brain/Walk/1-PathwayEval.swift ====


import CoreLib
import RealityKit
import simd

func validateExistingPath(
    animationSequence: [AnimationSequenceElement],
    travelGuide: TravelGuide,
    startingLocation: simd_float3 = .zero,
    entityWorldOrientation: simd_quatf,
    accuracy: Float = 0.2
) -> Bool {
    guard let existing = getExistingPath(
        animationSequence: animationSequence,
        startingLocation: startingLocation,
        entityWorldOrientation: entityWorldOrientation)
    else {
        AppLogger.shared.error("Error: No existing path found")
        return false
    }

    let needLen = totalArcLen(existing)
    guard let immediate = getImmediateTargetDestinations(
        travelGuide: travelGuide,
        withinDistance: needLen,
        startingLocation: startingLocation)
    else {
        AppLogger.shared.error("Error: No immediate path found")
        return false
    }

    let maxDev = frechetDistance(existing, immediate)
    let pathGood = maxDev <= accuracy

    let overshoots = detectOvershootBeyondInPlaceDestination(travelGuide)

    return pathGood && !overshoots
}

private func getImmediateTargetDestinations(
    travelGuide: TravelGuide,
    withinDistance: Float,
    startingLocation: simd_float3 = .zero
) -> [simd_float3]? {
    guard !travelGuide.targetDestinations.isEmpty else {
        AppLogger.shared.error("Error: No target destinations found")
        return nil
    }

    var path: [simd_float3] = [startingLocation]
    var travelled: Float = 0
    var prev = startingLocation

    for target in travelGuide.targetDestinations {
        guard let loc = target.location else { continue }
        let segLen = simd_length(loc - prev)
        path.append(loc)
        travelled += segLen
        prev = loc

        if target.inPlace {
            break
        }

        if travelled >= withinDistance { break }
    }
    return path
}

private func getExistingPath(
    animationSequence: [AnimationSequenceElement],
    startingLocation: simd_float3 = .zero,
    entityWorldOrientation: simd_quatf
) -> [simd_float3]? {
    var path: [simd_float3] = []
    var currentPos = startingLocation
    path.append(currentPos)

    for elem in animationSequence {
        if let delta = elem.deltaLocation {
            let worldDelta = entityWorldOrientation.act(delta)
            currentPos += worldDelta
            path.append(currentPos)
        }
    }

    if path.count <= 1 {
        AppLogger.shared.error("Error: No path found")
        return nil
    }

    return path
}

private func frechetDistance(
    _ p: [simd_float3],
    _ q: [simd_float3]
) -> Float {
    let m = p.count, n = q.count
    precondition(m > 0 && n > 0)

    var dp = Array(repeating: Array(repeating: Float.infinity, count: n), count: m)

    dp[0][0] = simd_length(p[0] - q[0])

    for j in 1..<n {
        let d = simd_length(p[0] - q[j])
        dp[0][j] = max(dp[0][j - 1], d)
    }
    for i in 1..<m {
        let d = simd_length(p[i] - q[0])
        dp[i][0] = max(dp[i - 1][0], d)
    }
    for i in 1..<m {
        for j in 1..<n {
            let d = simd_length(p[i] - q[j])
            dp[i][j] = max(
                min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]),
                d)
        }
    }
    return dp[m - 1][n - 1] // â† maximum leash length
}

@inline(__always)
private func dist2(_ a: simd_float3, _ b: simd_float3) -> Float {
    let d = a - b
    return simd_dot(d, d)
}

@inline(__always)
private func totalArcLen(_ p: [simd_float3]) -> Float {
    zip(p, p.dropFirst()).reduce(0) { $0 + simd_length($1.1 - $1.0) }
}


private func detectOvershootBeyondInPlaceDestination(_ guide: TravelGuide) -> Bool {
    guard
        let target        = guide.targetDestinations.first(where: { $0.inPlace && $0.location != nil }),
        let destLocation  = target.location
    else { return false }          // no inâ€‘place target â†’ nothing to check

    var reachedDestination = false

    for waypoint in guide.estPathway {
        guard let wpLoc = waypoint.location else { continue }

        if !reachedDestination {
            if simd_length(wpLoc - destLocation) <= idlePositionAccuracy {
                reachedDestination = true
            }
            continue
        }

        if simd_length(wpLoc - destLocation) > idlePositionAccuracy {
            return true
        }
    }
    return false
}

==== AnimLibS/Brain/Walk/2-ExtendWalkSequence.swift ====


import CoreLib

let fullStepCount = 2



func extendInitWalkSequence(
    currentAnimationSequence: inout [AnimationSequenceElement],
    initAnimationSequenceIndex: Int,
    keepExistingElements: Bool = true,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    if printBrainSystem {
        AppLogger.shared.anim("ðŸ§  Extending Init Walk Sequence â€“ keepExistingElements = \(keepExistingElements)")
    }

    if keepExistingElements {
        if countFullSteps(after: initAnimationSequenceIndex,
                          in: currentAnimationSequence,
                          dataManager: dataManager) >= fullStepCount,
            styleGuide.targets[0].isNew == false

        {
            if printBrainSystem {
                AppLogger.shared.anim("ðŸ§  Already have \(fullStepCount) full steps after index \(initAnimationSequenceIndex) and style guide is not new.")
            }
            return
        }

        appendMissingSteps(to: &currentAnimationSequence,
                           styleGuide: &styleGuide,
                           dataManager: dataManager)
    } else {
        replaceTailThenAppend(to: &currentAnimationSequence,
                              initIdx: initAnimationSequenceIndex,
                              styleGuide: &styleGuide,
                              dataManager: dataManager)
    }
}


private func appendMissingSteps(
    to sequence: inout [AnimationSequenceElement],
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    guard let lastElement = sequence.last,
          let endPoseIndex = lastElement.endPoseIndex
    else {
        AppLogger.shared.error("Error: Sequence is empty or last element has nil endPoseIndex.")
        return
    }

    let animationName = lastElement.animationName
    guard let animDataPoint = dataManager.getAnimDataPoint(for: animationName) else {
        AppLogger.shared.error("Error: Animation data not found for \(animationName).")
        return
    }
    guard
        let styleTarget = styleGuide.targets.first,
        let newAnimDataPoint = dataManager.getAnimDataPoint(for: styleTarget.animationName)
    else {
        AppLogger.shared.error("Error: StyleGuide has no targets.")
        return
    }

    let currentIsLoopWalk = animDataPoint.isLoop && animDataPoint.moveList == [.walk]
    let switchingToNewWalkingLoopStyle = styleTarget.isNew && newAnimDataPoint.isLoop && newAnimDataPoint.moveList == [.walk]


    if currentIsLoopWalk == false, switchingToNewWalkingLoopStyle == false {
        guard endPoseIndex < animDataPoint.criticalPoses.count else {
            AppLogger.shared.error("Error: endPoseIndex \(endPoseIndex) is out of bounds for animation \(animationName).")
            return
        }
        let startCriticalPoseName = animDataPoint.criticalPoses[endPoseIndex].poseName
        guard
            let allMatches = dataManager.getIndicesOfCriticalPose(
                for: styleTarget.animationName,
                matching: startCriticalPoseName
            ),
            let startIndex = allMatches.first
        else {
            AppLogger.shared.error("Error: No matching critical pose found for \(startCriticalPoseName) in style animation \(styleTarget.animationName).")
            return
        }
        

        extendWithCurrentWalkLoop(into: &sequence,
                                  styleAnimationName: styleTarget.animationName,
                                  startPoseIndex: startIndex,
                                  styleGuide: &styleGuide,
                                  dataManager: dataManager)
        return
    }
    

    guard let currentExtension = buildWalkSequenceExtension(
        animationName: animationName,
        startPoseIndex: endPoseIndex,
        fullStepCount: fullStepCount,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Failed to build extension for \(animationName).")
        return
    }

    if !switchingToNewWalkingLoopStyle {
        appendElements(currentExtension, to: &sequence, logSuffix: "(no transition)")
        return
    }

    if printBrainSystem {
        AppLogger.shared.anim("ðŸ§  Transitioning to new style \(styleTarget.animationName)")
    }
    let endPoseName = lastElement.endPoseName
    guard
        let indices = dataManager.getIndicesOfCriticalPose(
            for: styleTarget.animationName,
            matching: endPoseName
        ),
        let startPoseIndex = indices.first
    else {
        AppLogger.shared.error("Error: No matching critical pose found for \(endPoseName) in style animation \(styleTarget.animationName).")
        return
    }

    transitionToNewStyle(
        currentExtension: currentExtension, // put in only the blend-in portion
        newAnimationName: styleTarget.animationName,
        startPoseIndex: startPoseIndex,
        sequence: &sequence,
        styleGuide: &styleGuide,
        fullStepCount: fullStepCount, // for looping animation. uses max available array of walk critical poses for non-looping walks
        dataManager: dataManager
    )
}


private func replaceTailThenAppend(
    to sequence: inout [AnimationSequenceElement],
    initIdx: Int,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    var trimStart = initIdx + 1
    let initElement = sequence[initIdx]

    if !initElement.endPoseName.isStepFirstPose,
       let stepID = getStepID(for: initElement, dataManager: dataManager)
    {
        while trimStart < sequence.count,
              getStepID(for: sequence[trimStart], dataManager: dataManager) == stepID
        {
            trimStart += 1
        }
    }

    if let initAnimData = dataManager.getAnimDataPoint(for: initElement.animationName),
       !(initAnimData.isLoop && initAnimData.moveList == [.walk])
    {
        while trimStart < sequence.count {
            if let ad = dataManager.getAnimDataPoint(for: sequence[trimStart].animationName),
               !(ad.isLoop && ad.moveList == [.walk])
            {
                trimStart += 1
            } else {
                break
            }
        }
    }

    if trimStart < sequence.count {
        sequence.removeSubrange(trimStart...)
    }

    appendMissingSteps(to: &sequence,
                       styleGuide: &styleGuide,
                       dataManager: dataManager)
}


private func extendWithCurrentWalkLoop(
    into sequence: inout [AnimationSequenceElement],
    styleAnimationName: String,
    startPoseIndex: Int,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    guard let styleAnimData = dataManager.getAnimDataPoint(for: styleAnimationName),
          styleAnimData.isLoop, styleAnimData.moveList == [.walk]
    else {
        AppLogger.shared.error("Error: Style animation \(styleAnimationName) is not a looping walk.")
        return
    }
    guard let ext = buildWalkSequenceExtension(
        animationName: styleAnimationName,
        startPoseIndex: startPoseIndex,
        fullStepCount: fullStepCount,
        dataManager: dataManager
    )
    else {
        AppLogger.shared.error("Error: Could not build extension for style animation \(styleAnimationName).")
        return
    }
    appendElements(ext, to: &sequence, logSuffix: "(transition)")
    styleGuide.targets[0].isNew = false
}

func transitionToNewStyle(
    currentExtension: [AnimationSequenceElement], // this is only the current sequence portion that goes into blendTree
    newAnimationName styleAnimationName: String,
    startPoseIndex: Int,
    sequence: inout [AnimationSequenceElement],
    styleGuide: inout StyleGuide,
    fullStepCount: Int,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    guard let targetExtension = buildWalkSequenceExtension(
        animationName: styleAnimationName,
        startPoseIndex: startPoseIndex,
        fullStepCount: fullStepCount, // uses it for looping animation
        dataManager: dataManager
    )
    else {
        AppLogger.shared.error("Error: Failed to build extension for new style \(styleAnimationName).")
        return .failed
    }
    guard let blended = attachBlendInSequence(
        origExtension: currentExtension,
        targetExtension: targetExtension,
        dataManager: dataManager
    )
    else {
        AppLogger.shared.error("Error: Failed to create blend for transition to \(styleAnimationName).")
        return .failed
    }
    appendElements(blended, to: &sequence, logSuffix: "(blend to \(styleAnimationName))")
    styleGuide.targets[0].isNew = false
    
      return  .done
}


private func appendElements(_ elements: [AnimationSequenceElement],
                            to sequence: inout [AnimationSequenceElement],
                            logSuffix: String)
{
    guard !elements.isEmpty else { return }
    sequence.append(contentsOf: elements)
    if printBrainSystem {
        AppLogger.shared.anim("Appended \(elements.count) elements \(logSuffix)")
    }
}

private func countFullSteps(after idx: Int,
                            in sequence: [AnimationSequenceElement],
                            dataManager: DataManager) -> Int
{
    guard idx < sequence.count else { return 0 }
    var prevID: Int? = nil, steps = 0
    for i in (idx + 1) ..< sequence.count {
        guard let id = getStepID(for: sequence[i], dataManager: dataManager) else { continue }
        if prevID == nil { prevID = id }
        if id != prevID { steps += 1; prevID = id }
        if steps >= fullStepCount { break }
    }
    return steps
}

private func getStepID(for elem: AnimationSequenceElement,
                       dataManager: DataManager) -> Int?
{
    guard let ad = dataManager.getAnimDataPoint(for: elem.animationName) else { return nil }
    return ad.criticalPoses[elem.startPoseIndex].stepID
}


private func buildWalkSequenceExtension(
    animationName: String,
    startPoseIndex: Int,
    fullStepCount: Int,
    dataManager: DataManager
) -> [AnimationSequenceElement]? {
    var combinedExtendedSequence: [AnimationSequenceElement] = []

    var index = startPoseIndex

    guard
        let animDataPoint = dataManager.getAnimDataPoint(for: animationName)
    else {
        AppLogger.shared.error("Error: [4] Animation data point not found for \(animationName).")
        return nil
    }

    if startPoseIndex == animDataPoint.criticalPoses.count - 1 {
        if animDataPoint.isLoop {
            index = 0
        } else {
            AppLogger.shared.error("Error: startPoseIndex is the last element and animation is not looping.")
            return nil
        }
    }

    var allIndices: [Int] = []

    if animDataPoint.isLoop, animDataPoint.moveList == [.walk] {
        if let _allIndices = dataManager.getIndicesForNextFullSteps(
            animationName: animationName,
            currentIndexIncl: index,
            fullStepCount: fullStepCount
        ),
            _allIndices.count > 1
        {
            allIndices = _allIndices
        } else {
            AppLogger.shared.error("Error: Could not find indices for next full steps for \(animationName).")
            return nil
        }
        let lastPoseIndex = allIndices.last! + 1
        guard
            lastPoseIndex < animDataPoint.criticalPoses.count
        else {
            AppLogger.shared.error("Error: Invalid last pose index for \(animationName).")
            return nil
        }

        allIndices.append(lastPoseIndex)

    } else if animDataPoint.criticalPoses[index].poseName.moveType == .walk {
        var i = index
        while i < animDataPoint.criticalPoses.count,
              animDataPoint.criticalPoses[i].poseName.moveType == .walk
        {
            allIndices.append(i)
            i += 1
        }

        if allIndices.count < 2 {
            AppLogger.shared.error("Error: Not enough walk poses found in nonâ€‘looping \(animationName).")
            return nil
        }
    } else {
        AppLogger.shared.error("Error: Animation \(animationName) does not have walk in it.")
        return nil
    }

    guard let extendedSequence = constructAnimationSequenceForGivenAnimation(
        animationName: animationName,
        startCriticalPoseIndex: allIndices.first!,
        endCriticalPoseIndex: allIndices.last!,
        isFilledOut: false,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Could not construct extended animation sequence for \(animationName).")
        return nil
    }

    combinedExtendedSequence.append(contentsOf: extendedSequence)

    return combinedExtendedSequence
}

private func attachBlendInSequence(
    origExtension: [AnimationSequenceElement],
    targetExtension: [AnimationSequenceElement],
    dataManager: DataManager
) -> [AnimationSequenceElement]? {
    if printBrainSystem {
        AppLogger.shared.anim("ðŸ§  Attaching blend in sequence")
    }
    var targetExtension = targetExtension
    var origExtension = origExtension

    if targetExtension.count > origExtension.count {
        targetExtension = Array(targetExtension.prefix(origExtension.count))
    }

    if origExtension.count > targetExtension.count {
        origExtension = Array(origExtension.prefix(targetExtension.count))
    }

    guard origExtension.count == targetExtension.count else {
        AppLogger.shared.error("Error: Mismatch in element count between original and target extension sequences.")
        return nil
    }

    var blendedSequence: [AnimationSequenceElement] = []
    let totalBlendSteps = origExtension.count
    let frameRate = frameRate
    var fromEffectiveDuration: Float = 0.0

    for i in 0 ..< totalBlendSteps {
        let origElement = origExtension[i]
        var targetElement = targetExtension[i] // Create a mutable copy of target element

        if origElement.startPoseName != targetElement.startPoseName ||
            origElement.endPoseName != targetElement.endPoseName
        {
            AppLogger.shared.error("Error: startPoseNames and endPoseNames do not match at index \(i). Orig: Starting with \(origElement.startPoseName) and ending with \(origElement.endPoseName). Target: Starting with \(targetElement.startPoseName) and ending with \(targetElement.endPoseName).")
            return nil
        }

        guard let origFrameCount = calculateAnimationElementFrameCount(
            element: origElement,
            dataManager: dataManager
        ),
            let targetFrameCount = calculateAnimationElementFrameCount(
                element: targetElement,
                dataManager: dataManager
            )
        else {
            AppLogger.shared.error("Error: frameCount is nil for one of the elements at index \(i).")
            return nil
        }

        let targetWeight = totalBlendSteps > 1 ? Float(i) / Float(totalBlendSteps - 1) : 0.5
        let effectiveDuration = targetWeight * Float(targetFrameCount) / frameRate +
            (1 - targetWeight) * Float(origFrameCount) / frameRate

        let adjustedOrigSpeed = effectiveDuration * frameRate / Float(origFrameCount)
        let adjustedTargetSpeed = effectiveDuration * frameRate / Float(targetFrameCount)

        var updatedOrigElement = origElement
        updatedOrigElement.speed = adjustedOrigSpeed

        targetElement.speed = adjustedTargetSpeed

        let toEffectiveDuration = fromEffectiveDuration + effectiveDuration

        let blendInfo = BlendInfo(
            jointIndices: nil, // Adjust as needed.
            ownBlendWeightType: .decreasing,
            otherBlendWeightType: .increasing,
            isAdditive: false,
            blendFunction: .crossFade,
            blendType: .sCurve,
            fromEffectiveSeriesDuration: Double(fromEffectiveDuration),
            toEffectiveSeriesDuration: Double(toEffectiveDuration),
            totalEffectiveSeriesDuration: -1 // Will be updated later.
        )

        let blendNode = BlendNode(
            blendElement: updatedOrigElement,
            blendInfo: blendInfo
        )

        targetElement.blendTree = BlendTree(blendNodes: [blendNode])

        blendedSequence.append(targetElement)

        fromEffectiveDuration = toEffectiveDuration
    }

    let finalTotalDuration = fromEffectiveDuration
    for index in blendedSequence.indices {
        if var blendTree = blendedSequence[index].blendTree {
            for nodeIndex in blendTree.blendNodes.indices {
                blendTree.blendNodes[nodeIndex].blendInfo.totalEffectiveSeriesDuration = Double(finalTotalDuration)
            }
            blendedSequence[index].blendTree = blendTree
        }
    }

    return blendedSequence
}

==== AnimLibS/Brain/Walk/6-walkToIdle.swift ====



import CoreLib
import RealityKit
import simd

let reachedIdleLocationThreshold: Float = 0.20 // â† magicâ€‘number tweakable

func attemptTransitionToIdle(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    travelGuide: TravelGuide,
    entityWorldTransform: Transform,
    threshold: Float,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome? {
    let targetPattern: [MoveType] = [.walk, .transition, .idle]
    let idleTransitionCandidates = transitionCandidates(targetPattern: targetPattern, dataManager: dataManager)
    
    if
        let chosenIdleClip = shouldTransitionToIdleNow(
            animationSequence: animationSequence,
            currentIdx: initIndex,
            travelGuide: travelGuide,
            idleCandidates: idleTransitionCandidates,
            entityWorldTransform: entityWorldTransform,
            threshold: threshold,
            dataManager: dataManager
        ),
        let indices = dataManager.getIndicesOfCriticalPose(
            for: chosenIdleClip,
            matching: animationSequence[initIndex].endPoseName
        ),
        let startPoseIndex = indices.first
    {
        if printBrainSystem {
            AppLogger.shared.anim("ðŸ§  Transitioning to idle now. Chosen idle clip: \(chosenIdleClip)")
        }
        
        let isSuccess = attachIdleSequence(
            animationSequence: &animationSequence,
            initIdx: initIndex,
            idleAnimName: chosenIdleClip,
            startPoseIndex: startPoseIndex,
            dataManager: dataManager
        )
        
        if isSuccess == .done,
           initIndex + 1 < animationSequence.count
        {
            var inertialElement = animationSequence[initIndex + 1]
            guard let frameCount = calculateAnimationElementFrameCount(
                element: inertialElement,
                dataManager: dataManager
            ) else {
                AppLogger.shared.error("Failed to fetch frameCount for transitional idle.")
                return .failed
            }
            
            let unit = InertialUnit(
                boneIndices: nil,
                blendFrames: frameCount,
                isReverse: false
            )
            if inertialElement.inertialUnits == nil { inertialElement.inertialUnits = [] }
            inertialElement.inertialUnits!.append(unit)
            animationSequence[initIndex + 1] = inertialElement
            return .done
        }
    }
    return nil
}

func idleTravelTarget(in travelGuide: TravelGuide) -> TravelTarget? {
    travelGuide.targetDestinations.first { $0.inPlace }
}

func distanceFromProjectedEndToIdle(
    animationSequence: [AnimationSequenceElement],
    startElementIndex: Int,
    travelGuide: TravelGuide,
    entityPosition: SIMD3<Float>,
    entityWorldOrientation: simd_quatf,
    dataManager: DataManager
) -> Float? {
    guard
        let idleLoc = idleTravelTarget(in: travelGuide)?.location,
        let projectedEnd = projectedEndLocation(
            animationSequence: animationSequence,
            startElementIndex: startElementIndex,
            entityPosition: entityPosition,
            entityWorldOrientation: entityWorldOrientation,
            dataManager: dataManager)
    else {
        AppLogger.shared.error("Error: No idle location found or projected end location could not be computed.")
        return nil
    }

    return simd_length(projectedEnd - idleLoc)
}

func startWalkPoseName(beforeTransitionIn animName: String,
                       dataManager: DataManager) -> CriticalPoseName?
{
    guard let dp = dataManager.getAnimDataPoint(for: animName) else { return nil }

    var prev: CriticalPoseName?
    for pose in dp.criticalPoses {
        if pose.poseName.moveType == .transition { return prev }
        prev = pose.poseName
    }
    return nil
}

func chooseIdleTransitionClip(
    currentElement: AnimationSequenceElement,
    idleCandidates: [String],
    dataManager: DataManager
) -> String? {
    for name in idleCandidates {
        if let walkPose = startWalkPoseName(beforeTransitionIn: name,
                                            dataManager: dataManager),
            walkPose == currentElement.endPoseName
        {
            return name
        }
    }
    return nil
}


func shouldTransitionToIdleNow(
    animationSequence: [AnimationSequenceElement],
    currentIdx: Int,
    travelGuide: TravelGuide,
    idleCandidates: [String],
    entityWorldTransform: Transform,
    threshold: Float = reachedIdleLocationThreshold,
    dataManager: DataManager
) -> String? /* returns chosen clip or nil */ {
    let entityPosition: SIMD3<Float> = entityWorldTransform.translation
    let entityWorldOrientation: simd_quatf = entityWorldTransform.rotation
    let currentElement = animationSequence[currentIdx]

    guard let idleLoc = idleTravelTarget(in: travelGuide)?.location else { return nil }

    for animName in idleCandidates {
        guard let animationDataPoint = dataManager.getAnimDataPoint(for: animName) else { continue }

        guard let firstTransitionIdx = animationDataPoint.criticalPoses.firstIndex(where: { $0.poseName.moveType == .transition }) else { continue }

        guard let matchIdx = animationDataPoint.criticalPoses[..<firstTransitionIdx].firstIndex(where: { $0.poseName == currentElement.endPoseName }) else { continue }

        var localÎ” = SIMD3<Float>(repeating: 0)
        var localRot = simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0))

        var lastTransitionIdx = firstTransitionIdx
        while lastTransitionIdx + 1 < animationDataPoint.criticalPoses.count,
              animationDataPoint.criticalPoses[lastTransitionIdx + 1].poseName.moveType == .transition
        {
            lastTransitionIdx += 1
        }

        for idx in matchIdx ... lastTransitionIdx {
            let pose = animationDataPoint.criticalPoses[idx]
            localÎ” += pose.deltaLocation
            localRot = localRot * pose.deltaRotation
        }

        let worldÎ” = entityWorldOrientation.act(localÎ”)
        let predictedWorldPos = entityPosition + worldÎ”

        let worldDist = simd_length(predictedWorldPos - idleLoc)
        if worldDist <= reachedIdleLocationThreshold {
            return animName // âœ” found a viable clip
        }
    }

    return nil
}

func attachIdleSequence(
    animationSequence: inout [AnimationSequenceElement],
    initIdx: Int,
    idleAnimName: String,
    startPoseIndex: Int,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    guard let idleSeq = constructAnimationSequenceForGivenAnimation(
        animationName: idleAnimName,
        startCriticalPoseIndex: startPoseIndex,
        endCriticalPoseIndex: nil,
        isFilledOut: false,
        dataManager: dataManager)
    else {
        AppLogger.shared.error("Error: Failed to build idle transition sequence for \(idleAnimName)")
        return .failed
    }

    animationSequence.removeSubrange(initIdx + 1 ..< animationSequence.count)
    animationSequence.append(contentsOf: idleSeq)
    
    return .done
}

func projectedEndLocation(
    animationSequence: [AnimationSequenceElement],
    startElementIndex: Int,
    entityPosition: SIMD3<Float>,
    entityWorldOrientation: simd_quatf,
    dataManager: DataManager
) -> SIMD3<Float>? {
    var localÎ” = SIMD3<Float>(repeating: 0)

    for idx in startElementIndex ..< animationSequence.count {
        if let Î´ = animationSequence[idx].deltaLocation {
            localÎ” += Î´
        } else {
            guard let ad = dataManager.getAnimDataPoint(for: animationSequence[idx].animationName)
            else { return nil }
            localÎ” += ad.criticalPoses[animationSequence[idx].startPoseIndex].deltaLocation
        }
    }

    let worldÎ” = entityWorldOrientation.act(localÎ”)
    return entityPosition + worldÎ”
}


func transitionCandidates(targetPattern: [MoveType], dataManager: DataManager) -> [String] {
    return dataManager.animationDataIndex.values.compactMap { dataPoint in
        dataPoint.moveList == targetPattern ? dataPoint.animationName : nil
    }
}

==== AnimLibS/Components/BrainComponent.swift ====


import CoreLib
import Foundation
import RealityKit

public struct BrainComponent: RealityKit.Component {
    var animationSequence: [AnimationSequenceElement] = []
    var blendingAnimationSequence: [AnimationSequenceElement] = []
    var isNewSegment: Bool = false // DEBUG, to drop later
    public init() {}
}

public class BrainSystem: RealityKit.System {
    @MainActor private static let query = animationComponentQuery

    public required init(scene: RealityKit.Scene) {}


    public func update(context: SceneUpdateContext) {
        let characters = context.entities(matching: Self.query, updatingSystemWhen: .rendering)
        
        for character in characters {
            guard
                var brainComponent = character.components[BrainComponent.self],
                var eventComponent = character.components[EventComponent.self],
                let dataCenterComponent = character.components[DataCenterComponent.self]
            else { continue }
            
            if printBrainSystem { AppLogger.shared.anim("ðŸ§  ----------- Brain system is running for \(character.name) at \((dataCenterComponent.gameTime * 10000).rounded() / 10000): -------------") }
            
            let dataManager = dataCenterComponent.dataManager
            var currentAnimationSequence = brainComponent.animationSequence
            
            
            
            var brainDecisionState = BrainDecisionState.decideState(&eventComponent, currentAnimationSequence, dataManager)
            
            switch brainDecisionState {
            case .noDecisionNeeded:
                if printBrainSystem { AppLogger.shared.anim("ðŸ§  No need to decide on next animation.") }
                
            case .decideFresh:
                if printBrainSystem { AppLogger.shared.anim("ðŸ§  DecideFresh: Should decide on next animation. The sequence is empty.") }
                let targetAnimations: [String: [Int]] = [defaultAnimation: [1, 2, 3]] // TODO: choose animation dynamically later
                
                for targetAnimation in targetAnimations.keys {
                    guard let animDataPointTarget = dataCenterComponent.dataManager.getAnimDataPoint(for: targetAnimation) else { continue }
                    
                    guard let currentAnimationSequenceComp = constructAnimationSequenceForGivenAnimation(
                        animationName: targetAnimation,
                        startCriticalPoseIndex: 0,
                        endCriticalPoseIndex:nil, // if optional, search till the end or completes full loop,
                        isFilledOut: true,
                        dataManager: dataManager
                    ) else {
                        AppLogger.shared.error("ðŸ§  Error: Could not construct animation sequence for \(targetAnimation).")
                        continue
                    }
                    currentAnimationSequence = currentAnimationSequenceComp
                    
                    break
                }
                
                eventComponent.eventCache.removeAll()
                
            case .extendCurrentPlan, .createNewPlan:
                if printBrainSystem { AppLogger.shared.anim("ðŸ§  Should decide on next animation given \(brainDecisionState).") }
                
                var initAnimationSequenceIndex = brainDecisionState == .createNewPlan ?
                    currentAnimationSequence.startIndex :
                    currentAnimationSequence.count - 1
                
                guard currentAnimationSequence.indices.contains(initAnimationSequenceIndex) else {
                    // Handle the error case
                    AppLogger.shared.error("ðŸ§  Error: currentAnimationSequence is empty. Should not happen in .extendCurrentPlan, .createNewPlan.")
                    brainDecisionState = .decideFresh
                    break
                }
                
                let isSuccess = buildAnimationSequence(
                    entity: character,   //Debug: to delete //ðŸ‘€

                    currentAnimationSequence: &currentAnimationSequence,
                    initAnimationSequenceIndex: &initAnimationSequenceIndex,
                    styleGuide: &eventComponent.styleGuide,
                    travelGuide: &eventComponent.travelGuide,
                    eventComponent: eventComponent, //debug: to delete ðŸ‘€
                    dataManager: dataManager
                )
                
                if isSuccess == .done {
                    eventComponent.eventCache.removeAll()
                }
                    
                if printBrainSystem {
                    if isSuccess == .done{
                        AppLogger.shared.debug("ðŸ§  Animation sequence successfully built for \(brainDecisionState).")
                        
                    } else if isSuccess == .tooEarly {
                        AppLogger.shared.anim("ðŸ§  Too early to build animation sequence. Continue with existing sequence.")
                    } else if isSuccess == .alreadyReady {
                        AppLogger.shared.anim("ðŸ§  Next element already ready to play. Continue with existing sequence.")
                    } else {
                        AppLogger.shared.error("ðŸ§  Error: Failed to build animation sequence. Continue with existing sequence.")
                    }
                }
            }
            
            brainComponent.animationSequence = currentAnimationSequence
            
            character.components.set(brainComponent)
            character.components.set(eventComponent)
        }
    }
}

enum BrainDecisionState {
    case noDecisionNeeded
    case decideFresh
    case extendCurrentPlan
    case createNewPlan
    
    @MainActor static func decideState(
        _ eventComponent: inout EventComponent,
        _ currentAnimationSequence: [AnimationSequenceElement],
        _ dataManager: DataManager
    ) -> BrainDecisionState {
        
        if currentAnimationSequence.isEmpty {
            return .decideFresh
        }
        
        let isTimeForNewPlan = checkIfNewPlan(eventComponent: eventComponent, currentAnimationSequence: currentAnimationSequence)
        if isTimeForNewPlan {
            return .createNewPlan
        }
        
        
        if currentAnimationSequence.count <= 1 {
            return .extendCurrentPlan
        }
        
        
        if let firstSection = currentAnimationSequence.first,
           let currentFrame = firstSection.currentFrame
        {
            let startPoseFrame = firstSection.startPoseFrame
            let totalFrames = currentAnimationSequence.reduce(0) { total, element in
                if let frameCount = calculateAnimationElementFrameCount(
                    element: element,
                    dataManager: dataManager
                ) {
                    return total + Int(frameCount)
                } else {
                    return total
                }
            }
                
            let adjustedFrames = totalFrames - Int(currentFrame - startPoseFrame)
                
            if adjustedFrames <= (Int(minBlendingFrameCount) + 1) { // +1 is for padding
                if printBrainSystem {
                    AppLogger.shared.anim("ðŸ§  Total frames left in the sequence is \(adjustedFrames). Sending order to .extendCurrentPlan")
                }
                return .extendCurrentPlan
            }
        }
            
        if currentAnimationSequence.isEmpty {
            AppLogger.shared.error("ðŸ§  Error: No more frames left in the sequence. Deciding on new animation: .decideFresh")
            return .decideFresh
        }
            
        return .noDecisionNeeded
    }
}

@MainActor
func checkIfNewPlan(eventComponent: EventComponent, currentAnimationSequence: [AnimationSequenceElement]) -> Bool {
    let hasNewEvent = eventComponent.eventCache.contains { $0.isNew }
    let isNewDestination = eventComponent.travelGuide.isNewDestination //does pathway contain new targets?

    guard hasNewEvent || isNewDestination else {
        return false
    }
    
    guard let currentElement = currentAnimationSequence.first else {
        return false
    }
    
    let currentMoveType = currentElement.startPoseName.moveType
    
    if mustFinishMoveTypes.contains(currentMoveType) /*|| currentElement.customAnimationInfo != nil*/ {
        return false
    }
    
    if printBrainSystem {
        if isNewDestination {
            AppLogger.shared.anim("ðŸ§  New move target found. Sending order to .createNewPlan")
        } else {
            AppLogger.shared.anim("ðŸ§  New event found. Sending order to .createNewPlan")
        }
    }
    
    return true
}

==== AnimLibS/Components/EventComponent.swift ====


import CoreLib
import Foundation
import joystickController
import RealityKit

public struct EventComponent: RealityKit.Component {
    var eventCache: [EventCacheElement] = []
    public let dataProvider: JoystickDataProvider
    var travelGuide: TravelGuide = .init()
    var styleGuide: StyleGuide = .init()

    var lastButtonState: Bool = false //    /// `true` while the action button was held *last* frame
    var currentGuideIndex: Int = -1 // Index into the list passed to `setAnimationStyleWithButton` (`â€‘1` â‡’ no guide chosen yet).

    public init(dataProvider: JoystickDataProvider) {
        self.dataProvider = dataProvider
        self.eventCache = []
        self.travelGuide = TravelGuide()
    }
}

public class EventSystem: RealityKit.System {
    @MainActor private static let query = animationComponentQuery

    public required init(scene: RealityKit.Scene) {}

    public static var dependencies: [SystemDependency] { [.before(BrainSystem.self)] }

    public func update(context: SceneUpdateContext) {
        let characters = context.entities(matching: Self.query, updatingSystemWhen: .rendering)

        for character in characters {
            if printEventSystem {
                AppLogger.shared.anim("========== EventSystem is running for \(character.name) =============")
            }

            guard var eventComponent = character.components[EventComponent.self] else { continue }

            let freshGuide = travelGuideFromJoystick(
                dataProvider: eventComponent.dataProvider,
                entityWorldTransform: character.transform,
                distance: 10
            )

            var mergedGuide = freshGuide
            if !eventComponent.travelGuide.estPathway.isEmpty {
                mergedGuide.estPathway = eventComponent.travelGuide.estPathway
            }
            eventComponent.travelGuide = mergedGuide

            if printEventSystem {
                if let first = mergedGuide.targetDestinations.first {
                    AppLogger.shared.anim("[EventSystem] TravelGuide First destination: inPlace: \(first.inPlace)  |  isNew: \(first.isNew)")
                } else {
                    AppLogger.shared.anim("TravelGuide: no destinations.")
                }
            }

            if let first = mergedGuide.targetDestinations.first {
                
                let previousTarget = eventComponent.styleGuide.targets.first
                
                let previousWasInPlace = previousTarget?.animationName == defaultIdleAnimation
                
                let baseAnim: String
                if let previous = previousTarget,
                   previousWasInPlace == first.inPlace
                {
                    baseAnim = previous.animationName
                } else {
                    baseAnim = first.inPlace ? defaultIdleAnimation : defaultWalkAnimation
                }
                
                let newIsNew: Bool
                if let previous = previousTarget,
                   previous.animationName == baseAnim,
                   previous.isNew == false
                {
                    newIsNew = false
                } else {
                    newIsNew = true
                }
                
                eventComponent.styleGuide = StyleGuide(targets: [
                    StyleTarget(style: "default",
                                baseAnimName: baseAnim,
                                isNew: newIsNew)
                ])
            }

            setAnimationStyleWithButton(
                styleGuides: styleGuides,
                eventComponent: &eventComponent,
                dataProvider: eventComponent.dataProvider
            )

            character.components.set(eventComponent)
        }
    }
}

struct EventCacheElement {
    let eventName: String
    let eventGameTime: Double
    let isNew: Bool
}

func MarkAllEventsOld(for eventComponent: inout EventComponent) {
    guard eventComponent.eventCache.last != nil else {
        if printEventSystem { AppLogger.shared.anim("No events to update.") }
        return
    }

    eventComponent.eventCache = eventComponent.eventCache.map { event in
        EventCacheElement(eventName: event.eventName, eventGameTime: event.eventGameTime, isNew: false)
    }
}

==== AnimLibS/Components/TravelComponent.swift ====


import CoreLib

import Inertialization
import RealityKit

enum animState {
    case animationPlaying
    case startingNewAnimation
}

func generateAnimDataForSequenceElement(
    animationSequenceElement: inout AnimationSequenceElement,
    lagAnimationSequenceElement: AnimationSequenceElement? = nil,
    leadAnimationSequenceElement: inout AnimationSequenceElement?,
    dataManager: DataManager
) {
    generateAnimDataForSequenceElementWoIntert(
        animationSequenceElement: &animationSequenceElement,
        dataManager: dataManager
    )

    populateInertialData(
        animationSequenceElement: &animationSequenceElement,
        lagAnimationSequenceElement: lagAnimationSequenceElement,
        leadAnimationSequenceElement: &leadAnimationSequenceElement,
        dataManager: dataManager
    )
}

func generateAnimDataForSequenceElementWoIntert(
    animationSequenceElement: inout AnimationSequenceElement,
    withInertialization: Bool = true,
    dataManager: DataManager
) {
    if let _ = animationSequenceElement.blendTree {
        if printAnimationSystem {
            AppLogger.shared.anim(" Blending animation sequence element: \(animationSequenceElement.animationName) with blend tree.")
        }
        blendRecursively(animationSequenceElement: &animationSequenceElement, dataManager: dataManager)
    } else {
        if printAnimationSystem {
            AppLogger.shared.anim("Populating animData for animation sequence element: \(animationSequenceElement.animationName)")
        }
        populateAnimDataWithAlterations(
            animationSequenceElement: &animationSequenceElement,
            dataManager: dataManager
        )
    }

    populateCirData(
        animationSequenceElement: &animationSequenceElement,
        dataManager: dataManager
    )
}

==== AnimLibS/AnimationTransforms/Transforms-To-Play/2-Alterations Data Functions/cirWalk-data.swift ====


import CoreLib
import RealityKit

func populateCirData(
    animationSequenceElement: inout AnimationSequenceElement,
    dataManager: DataManager
) {
    
    guard
        let animAlteration = animationSequenceElement.animAlteration,
        let walkCircleAlteration = animAlteration.walkCircleAlteration,
        let cirWalkDegree = walkCircleAlteration.cirWalkDegree,
        let cirBlendInfo = walkCircleAlteration.cirBlendInfo
    else {
        return
    }
    
    if printAnimationSystem {
        if let alt = animationSequenceElement.animAlteration {
            var msg = "animAlteration:\n"
            if let w = alt.walkCircleAlteration {
                msg += """
                ðŸŒ€ WalkCircleAlteration:
                  cirWalkDegree: \(String(format: "%.3f", w.cirWalkDegree ?? 0))
                  blendJoints: \(w.cirBlendInfo?.jointIndices ?? [])
                  ownBlendWeightType: \(w.cirBlendInfo?.ownBlendWeightType ?? .fixedAt100)
                  otherBlendWeightType: \(w.cirBlendInfo?.otherBlendWeightType ?? .fixedAt0)

                """
            }
            if let s = alt.strideLength {
                msg += "  strideLength: \(s)\n"
            }
            AppLogger.shared.anim(msg)
        } else {
            AppLogger.shared.anim("animAlteration: none")
        }
    }


    guard let animData = animationSequenceElement.animData
    else {
        AppLogger.shared.error("Error: No base transforms found for animationName: \(animationSequenceElement.animationName)")
        return
    }

    let baseTransforms = animData.animTransforms

    guard let (cirOffsetTransforms, boneIndices) = createCirWalkOffsetTransforms(
        animationSequenceElement: animationSequenceElement,
        changeInOrientationDegrees: cirWalkDegree,
        operationMode: .all,
        dataManager: dataManager
    )
    else {
        AppLogger.shared.error("Error: cir Walk animation creation failed for \(animationSequenceElement.animationName)")
        return
    }


    guard let updatedTransforms = addTwoTransforms(
        transformsMain: baseTransforms,
        transformsAdd: cirOffsetTransforms,
        jointIndicesAdd: boneIndices,
        blendWeightTypeAdd: cirBlendInfo.ownBlendWeightType,
        blendType: cirBlendInfo.blendType,
        fromEffectiveSeriesDuration: cirBlendInfo.fromEffectiveSeriesDuration,
        toEffectiveSeriesDuration: cirBlendInfo.toEffectiveSeriesDuration,
        totalEffectiveSeriesDuration: cirBlendInfo.totalEffectiveSeriesDuration,
        dataManager: dataManager,
        alphaForA: 1.0
    ) else {
        AppLogger.shared.error("Error: Failed to add CIR Walk offset transforms.")
        return
    }

    animationSequenceElement.animData!.animTransforms = updatedTransforms
}

==== AnimLibS/AnimationTransforms/Transforms-To-Play/2-Alterations Data Functions/matchTransform-data.swift ====


import CoreLib
import RealityKit

func adjustAnimDataWithMatchTransform(
    animationSequenceElement element: inout AnimationSequenceElement,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    guard
        let animAlteration = element.animAlteration,
        let matchTransform = animAlteration.matchTransformAlteration
    else { return .done}
    
    guard
        let animData = element.animData
    else {
        AppLogger.shared.error("Error: No transform data found for animationName: \(element.animationName) while doing match transform adjustments.")
        return .failed
    }
    
    var (startDeltaTransform, startIndices): ([Transform], [Int]) = ([Transform.identity], [])
    if let startPoseMatch = matchTransform.startPoseMatch {
        let poseName = element.startPoseName
        let baseFrame = element.startPoseFrame
        let animationName = element.animationName
        
        guard let (startDeltaTransformCalc, startIndicesCalc) =
            computeDeltaPoseTransform(
                animationName: animationName,
                poseName: poseName,
                baseFrame: baseFrame,
                poseMatch: startPoseMatch,
                dataManager: dataManager
            )
        else {
            AppLogger.shared.error("Error: [1] Failed to compute delta pose transform for start pose.")
            return .failed
        }
        (startDeltaTransform, startIndices) = (startDeltaTransformCalc, startIndicesCalc)
    }
    
    var (endDeltaTransform, endIndices): ([Transform], [Int]) = ([Transform.identity], [])
    if let endPoseMatch = matchTransform.endPoseMatch {
        let poseName = element.endPoseName
        guard let baseFrame = element.endPoseFrame else {
            AppLogger.shared.error("Error: No end pose frame found for animationName: \(element.animationName).")
            return .failed
        }
        let animationName = element.animationName
        
        guard let (endDeltaTransformCalc, endIndicesCalc) =
            computeDeltaPoseTransform(
                animationName: animationName,
                poseName: poseName,
                baseFrame: baseFrame,
                poseMatch: endPoseMatch,
                dataManager: dataManager
            )
        else {
            AppLogger.shared.error("Error: [2] Failed to compute delta pose transform for start pose.")
            return .failed
        }
        (endDeltaTransform, endIndices) = (endDeltaTransformCalc, endIndicesCalc)
    }
    
    
    mergeDeltaTransforms(
        startIndices: &startIndices,
        startTransforms: &startDeltaTransform,
        endIndices: &endIndices,
        endTransforms: &endDeltaTransform
    )
    
    let elementDuration = animData.animTimeArray.last ?? 0
        
    guard let finalTransforms = addTwoTransforms(
        transformsMain: animData.animTransforms,
        transformsAdd: [startDeltaTransform, endDeltaTransform],
        jointIndicesAdd: startIndices,
        blendWeightTypeAdd: .fixedAt100,
        blendType: .linear,
        fromEffectiveSeriesDuration: 0,
        toEffectiveSeriesDuration: Double(elementDuration),
        totalEffectiveSeriesDuration: Double(elementDuration),
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Failed to add delta transforms to animation data.")
        return .failed
    }
    
    element.animData!.animTransforms = finalTransforms
    
    return .done
}

private func computeDeltaPoseTransform(
    animationName: String,
    poseName: CriticalPoseName,
    baseFrame: Int,
    poseMatch: PoseMatchTransformAlteration,
    dataManager: DataManager
) -> (adjustedTransform: [Transform], indices: [Int])? {
    
    
    let referenceTransform: [Transform]
    if poseMatch.referenceTransformType == .none {
        if printBrainSystem {
            AppLogger.shared.debug("âš§ï¸ The pose does not require adjustment per the configuration: referenceTransformType: \(poseMatch.referenceTransformType).")
        }
        return ([],[])
    } else if poseMatch.referenceTransformType == .start {
        guard let animReferenceTransformCalc = dataManager.getAnimationTransformForFrame(
            for: poseMatch.startReferenceAnimFrameDict.animationName,
            atFrame: poseMatch.startReferenceAnimFrameDict.frame,
            accountForLooping: true
        ) else {
            AppLogger.shared.error("Error: No transform data found for animationName: \(poseMatch.startReferenceAnimFrameDict.animationName) at  frame: \(poseMatch.startReferenceAnimFrameDict.frame)")
            return nil
        }
        referenceTransform = animReferenceTransformCalc
    } else if poseMatch.referenceTransformType == .end {
        guard let animReferenceTransformCalc = dataManager.getAnimationTransformForFrame(
            for: poseMatch.endReferenceAnimFrameDict.animationName,
            atFrame: poseMatch.endReferenceAnimFrameDict.frame,
            accountForLooping: true
        ) else {
            AppLogger.shared.error("Error: No transform data found for animationName: \(poseMatch.endReferenceAnimFrameDict.animationName) at  frame: \(poseMatch.endReferenceAnimFrameDict.frame)")
            return nil
        }
        referenceTransform = animReferenceTransformCalc
    } else if poseMatch.referenceTransformType == .blendBeforeAndAfter {
        guard let animReferenceTransformCalc1 = dataManager.getAnimationTransformForFrame(
            for: poseMatch.startReferenceAnimFrameDict.animationName,
            atFrame: poseMatch.startReferenceAnimFrameDict.frame,
            accountForLooping: true
        ) else {
            AppLogger.shared.error("Error: No transform data found for animationName: \(poseMatch.startReferenceAnimFrameDict.animationName) at  frame: \(poseMatch.startReferenceAnimFrameDict.frame)")
            return nil
        }
        
        guard let animReferenceTransformCalc2 = dataManager.getAnimationTransformForFrame(
            for: poseMatch.endReferenceAnimFrameDict.animationName,
            atFrame: poseMatch.endReferenceAnimFrameDict.frame,
            accountForLooping: true
        ) else {
            AppLogger.shared.error("Error: No transform data found for animationName: \(poseMatch.endReferenceAnimFrameDict.animationName) at  frame: \(poseMatch.endReferenceAnimFrameDict.frame)")
            return nil
        }
        
        referenceTransform = blendTransforms(
            transformsA: animReferenceTransformCalc1,
            transformsB: animReferenceTransformCalc2,
            alpha: 0.5
        )
        
    } else {
        AppLogger.shared.error("Error: Invalid reference transform type \(poseMatch.referenceTransformType).")
        return nil
    }
    
    guard let baseTransform = dataManager.getAnimationTransformForFrame(
        for: animationName,
        atFrame: baseFrame,
        accountForLooping: true
    ) else {
        AppLogger.shared.error("Error: Could not retrieve baseTransformsFrame for frame \(baseFrame) in \(animationName).")
        return nil
    }
    
    let (poseAdjustment, baseSide) = determinePoseAdjustmentAndBaseSide(
        poseMatch: poseMatch,
        startPoseName: poseName
    )
    
    guard var (adjustedTransform, indices) = adjustPose(
        baseTransforms: baseTransform,
        referenceTransforms: referenceTransform,
        baseSide: baseSide,
        poseAdjustment: poseAdjustment,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Failed to adjust pose transforms.")
        return nil
    }
    
    let isSuccess = applyFeetRotationIfNeeded(
        currentTransforms: &adjustedTransform,
        currentIndices: &indices,
        poseMatch: poseMatch,
        dataManager: dataManager
    )
    if isSuccess != .done {
        AppLogger.shared.error("Error: Failed to apply foot rotation.")
        return nil
    }
    
    
    let filteredAdjTransform = filterTransforms(transforms: adjustedTransform, indices: indices)
    let filteredBaseTransform = filterTransforms(transforms: baseTransform, indices: indices)
    
    let deltaTransform = calculateDeltaTransforms(
        fromTransforms: filteredBaseTransform,
        toTransforms: filteredAdjTransform
    )
    
    return (deltaTransform, indices)
}

private func determinePoseAdjustmentAndBaseSide(
    poseMatch: PoseMatchTransformAlteration,
    startPoseName: CriticalPoseName
) -> (poseAdjustment: PoseAdjustment, baseSide: Side) {
    let baseSide = poseMatch.baseSide
    
    let poseType = startPoseName.poseType
    
    let poseAdjustment: PoseAdjustment
        
    switch poseType {
    case .toeOn, .footOff:
        poseAdjustment = .aboutToLiftFoot
            
    case .low, .other, .toeOff, .footOn, .toeHigh:
        poseAdjustment = .none
            
    case .high:
        poseAdjustment = .liftedFoot
            
    case .on, .w_ground, .aboutToBendKnees, .off:
        poseAdjustment = .plantedFeetIfPossible
    }
    
    return (poseAdjustment, baseSide)
}

private func applyFeetRotationIfNeeded(
    currentTransforms: inout [Transform],
    currentIndices: inout [Int],
    poseMatch: PoseMatchTransformAlteration,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    let baseSide = poseMatch.baseSide
    
    for footSide in [baseSide, baseSide.otherSide] {
        let animationStartDict = poseMatch.startReferenceAnimFrameDict
        let animationStart = animationStartDict.animationName
        let frameStart = animationStartDict.frame
        
        let footRotationType = footSide == poseMatch.baseSide ? poseMatch.sideFootRotationType : poseMatch.otherSideFootRotationType
                
        switch footRotationType {
        case .start:
            
            guard let startAnimReferenceTransform = dataManager.getAnimationTransformForFrame(
                for: animationStart,
                atFrame: frameStart,
                accountForLooping: true
            ) else {
                AppLogger.shared.error("Error: No transform data found for animationName: \(animationStart)")
                return .failed
            }
            
            if let (adjusted, adjIndices) = adjustPose(
                baseTransforms: currentTransforms,
                referenceTransforms: startAnimReferenceTransform,
                baseSide: footSide,
                poseAdjustment: .adjustFootRotation,
                dataManager: dataManager
            ) {
                currentTransforms = adjusted
                for idx in adjIndices {
                    if !currentIndices.contains(idx) {
                        currentIndices.append(idx)
                    }
                }
            } else {
                AppLogger.shared.error("Error: Could not adjust foot rotation (start).")
            }
            
        case .end:
            
            let animationEndDict = poseMatch.endReferenceAnimFrameDict
            let animationEnd = animationEndDict.animationName
            let frameEnd = animationEndDict.frame
            
            guard let endAnimReferenceTransform = dataManager.getAnimationTransformForFrame(
                for: animationEnd,
                atFrame: frameEnd,
                accountForLooping: true
            ) else {
                AppLogger.shared.error("Error: No transform data found for animationName: \(animationEnd)")
                return .failed
            }
            
            if let (adjusted, adjIndices) = adjustPose(
                baseTransforms: currentTransforms,
                referenceTransforms: endAnimReferenceTransform,
                baseSide: footSide,
                poseAdjustment: .adjustFootRotation,
                dataManager: dataManager
            ) {
                currentTransforms = adjusted
                for idx in adjIndices {
                    if !currentIndices.contains(idx) {
                        currentIndices.append(idx)
                    }
                }
            } else {
                AppLogger.shared.error("Error: Could not adjust foot rotation (end).")
            }
            
        default:
            break
        }
    }
    return .done
}

func mergeDeltaTransforms(
    startIndices: inout [Int],
    startTransforms: inout [Transform],
    endIndices: inout [Int],
    endTransforms: inout [Transform]
) {
    let startSet = Set(startIndices)
    let endSet = Set(endIndices)

    let endOnly = endSet.subtracting(startSet).sorted()
    for frame in endOnly {
        startIndices.append(frame)
        startTransforms.append(.identity)
    }

    let startOnly = startSet.subtracting(endSet).sorted()
    for frame in startOnly {
        endIndices.append(frame)
        endTransforms.append(.identity)
    }

    func sortByFrame(_ indices: inout [Int], _ transforms: inout [Transform]) {
        let paired = zip(indices, transforms)
            .sorted { $0.0 < $1.0 }
        indices = paired.map { $0.0 }
        transforms = paired.map { $0.1 }
    }

    sortByFrame(&startIndices, &startTransforms)
    sortByFrame(&endIndices, &endTransforms)
}

==== AnimLibS/AnimationTransforms/Transforms-To-Play/2-Alterations Data Functions/stride-data.swift ====


import CoreLib
import RealityKit

func adjustAnimDataWithStride(
    animationSequenceElement element: inout AnimationSequenceElement,
    dataManager: DataManager
) {
    guard
        let animAlteration = element.animAlteration,
        let targetStrideLength = animAlteration.strideLength
    else { return }

    guard
        let animDataOrig = element.animData
    else {
        AppLogger.shared.error("Error: No transform data found for animationName: \(element.animationName) while doing stride adjustments.")
        return
    }

    guard let stepData = dataManager.getStepData(for: element.animationName, criticalPoseIndex: element.startPoseIndex) else {
        AppLogger.shared.error("Error: No step data found for animationName: \(element.animationName)")
        return
    }
    let currentStrideLength: Float = length(stepData.stepLocation)

    let suffix = currentStrideLength < targetStrideLength ? "--strideMAX" : "--strideMIN"

    let strideAnimationName = "\(element.animationName)\(suffix)"
    guard
        let animDataStride = populateAnimDataWithOrig(
            animationName: strideAnimationName,
            startPoseIndex: element.startPoseIndex,
            animationSpeedMultiplier: element.speed * systemWideSpeedMultiplier,
            dataManager: dataManager
        )
    else {
        AppLogger.shared.error("Error: No transform data found for animationName: \(element.animationName)")
        return
    }

    guard let stepDataExtreme = dataManager.getStepData(for: strideAnimationName, criticalPoseIndex: element.startPoseIndex) else {
        AppLogger.shared.error("Error: No step data found for animationName: \(element.animationName)")
        return
    }
    let extremeStrideLength: Float = length(stepDataExtreme.stepLocation)

    if extremeStrideLength == currentStrideLength {
        AppLogger.shared.error("Error: Extreme stride length \(extremeStrideLength) equals current stride length \(currentStrideLength). Proceeding to populate animData without adjustments.")

        guard let animData = populateAnimDataWithOrig(
            animationName: element.animationName,
            startPoseIndex: element.startPoseIndex,
            animationSpeedMultiplier: element.speed,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("Error: Unable to populate anim data for: \(element.animationName) (no adjustments)")
            return
        }
        element.animData = animData
        return
    }

    var blendFactor: Float = Swift.abs(targetStrideLength - currentStrideLength) / Swift.abs(extremeStrideLength - currentStrideLength) // for stride data
    
    if blendFactor > 1 || blendFactor < 0 {
        blendFactor = min(max(blendFactor, 0), 1)
    }


    let blendInfo = BlendInfo(
        jointIndices: nil,
        ownBlendWeightType: .fixedAt(blendFactor),
        otherBlendWeightType: .fixedAt(1 - blendFactor),
        isAdditive: false,
        blendFunction: .crossFade,
        blendType: .linear,
        fromEffectiveSeriesDuration: 0,
        toEffectiveSeriesDuration: 1,
        totalEffectiveSeriesDuration: 1
    )

    guard let blendedTransformsComputed = blendWithTransforms(
        transformsA: animDataOrig.animTransforms,
        transformsB: animDataStride.animTransforms,
        jointIndicesB: blendInfo.jointIndices,
        blendWeightTypeA: blendInfo.otherBlendWeightType,
        blendWeightTypeB: blendInfo.ownBlendWeightType,
        blendType: blendInfo.blendType,
        fromEffectiveSeriesDuration: blendInfo.fromEffectiveSeriesDuration,
        toEffectiveSeriesDuration: blendInfo.toEffectiveSeriesDuration,
        totalEffectiveSeriesDuration: blendInfo.totalEffectiveSeriesDuration
    ) else {
        AppLogger.shared.error("Error: Failed to blend transforms.")
        return
    }



    guard
        let endPoseFrameOrig = element.endPoseFrame,
        let (elapsedTimeArrayOrig, frameIndicesOrig) = dataManager.calculateElapsedTimeArray(
            for: element.animationName,
            fromFrameIncl: element.startPoseFrame,
            toFrameIncl: endPoseFrameOrig,
            speed: element.speed * systemWideSpeedMultiplier
        )
    else {
        AppLogger.shared.error("Error: Failed to calculate elapsed time array for original animation.")
        return
    }

    guard
        let endPoseFrameOrig = element.endPoseFrame,
        let (elapsedTimeArrayStride, _) = dataManager.calculateElapsedTimeArray(
            for: strideAnimationName,
            fromFrameIncl: element.startPoseFrame,
            toFrameIncl: endPoseFrameOrig,
            speed: element.speed * systemWideSpeedMultiplier
        )
    else {
        AppLogger.shared.error("Error: Failed to calculate elapsed time array for original animation.")
        return
    }

    guard elapsedTimeArrayOrig.count == elapsedTimeArrayStride.count else {
        AppLogger.shared.error("Error: Mismatched elapsed time array lengths. Original count: \(elapsedTimeArrayOrig.count), Stride count: \(elapsedTimeArrayStride.count)")
        return
    }
    let selectedTimes: [Float] = zip(elapsedTimeArrayOrig, elapsedTimeArrayStride)
        .map { origTime, strideTime in
            origTime * (1 - blendFactor) + strideTime * blendFactor
        }


    let animData = AnimData(
        animTransforms: blendedTransformsComputed,
        animTimeArray: selectedTimes,
        frameArray: frameIndicesOrig
    )

    element.animData = animData
}

==== AnimLibS/AnimationTransforms/Transforms-To-Play/2-apply-alterations-pre-blend.swift ====

import CoreLib
import RealityKit

func populateAnimDataWithAlterations(
    animationSequenceElement: inout AnimationSequenceElement,
    dataManager: DataManager
) {
    
    guard let animData = populateAnimDataWithOrig(
        animationName: animationSequenceElement.animationName,
        startPoseIndex: animationSequenceElement.startPoseIndex,
        animationSpeedMultiplier: animationSequenceElement.speed,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Unable to populate anim data for: \(animationSequenceElement.animationName) (no adjustments)")
        return
    }
    
    animationSequenceElement.animData = animData
    
    guard let animAlteration = animationSequenceElement.animAlteration else {
        if printAnimationSystem {
            AppLogger.shared.anim("populating anim data without adjustments for \(animationSequenceElement.animationName) from \(animationSequenceElement.startPoseName)[\(animationSequenceElement.startPoseFrame)] to \(animationSequenceElement.endPoseName)[\(animationSequenceElement.endPoseFrame ?? 0)]")
        }
        return
    }

    if animAlteration.strideLength != nil {
        adjustAnimDataWithStride(
            animationSequenceElement: &animationSequenceElement,
            dataManager: dataManager
        )
    }
    
    if animAlteration.matchTransformAlteration != nil {
        adjustAnimDataWithMatchTransform(
            animationSequenceElement: &animationSequenceElement,
            dataManager: dataManager
        )
    }
    
    return
}

==== AnimLibS/Brain/BrainAnimationSequence.swift ====

import CoreLib
import RealityKit

enum buildAnimationSequenceOutcome {
    case tooEarly
    case done
    case alreadyReady
    case failed
}

@MainActor // Debug: to delete //ðŸ‘€
func buildAnimationSequence(
    entity: Entity, // Debug: to delete //ðŸ‘€
    currentAnimationSequence: inout [AnimationSequenceElement],
    initAnimationSequenceIndex: inout Int,
    styleGuide: inout StyleGuide,
    travelGuide: inout TravelGuide,
    eventComponent: EventComponent?, // Debug: to delete //ðŸ‘€
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    var isSuccess: buildAnimationSequenceOutcome = .failed

    guard let transitionableIndex = findNextTransitionableCurrentSequenceIndex(
        currentIndex: initAnimationSequenceIndex,
        animationSequence: currentAnimationSequence,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("ðŸ§  Error: No animation segments after custom animation segments.")
        return .failed
    }

    guard transitionableIndex == 0 else {
        AppLogger.shared.anim("ðŸ§  Too early to transition. Skipping buildAnimationSequence.")
        return .tooEarly
    }

    if transitionableIndex + 1 < currentAnimationSequence.count,
       currentAnimationSequence[transitionableIndex + 1].isReadyToPlay == true,
       styleGuide.targets[0].isNew == false
    {
        AppLogger.shared.anim("ðŸ§  Next element already ready to play. Skipping buildAnimationSequence.")
        return .alreadyReady
    }

    let initAnimationSequenceElement = currentAnimationSequence[transitionableIndex]
    
    
    guard
        let currentFrame = initAnimationSequenceElement.currentFrame,
        let endPoseFrame = initAnimationSequenceElement.endPoseFrame
    else {
        AppLogger.shared.error("ðŸ§  Error: Current frame or end pose frame is nil.")
        return .failed
    }
    
    

    let initMoveType = initAnimationSequenceElement.endPoseName.moveType
    
    if let firstTargetDestination = travelGuide.targetDestinations.first {
        AppLogger.shared.anim("ðŸ§  TravelGuide First Destination: inPlace: \(firstTargetDestination.inPlace)  |  isNew: \(firstTargetDestination.isNew)")
    } else {
        AppLogger.shared.anim("ðŸ§  TravelGuide: no destinations.")
    }

    switch initMoveType {
    case .walk:
        
        guard initAnimationSequenceElement.isNearEndOfSegment() else {
            if printBrainSystem {
                AppLogger.shared.anim("Too early to construct walkâ€‘toâ€‘walk transition; segment not yet close to the end.")
            }
            return .tooEarly
        }

        AppLogger.shared.anim("Current move type is walk.")
        isSuccess = constructWalkSequence(
            animationSequence: &currentAnimationSequence,
            initIndex: transitionableIndex,
            styleGuide: &styleGuide,
            travelGuide: &travelGuide,
            entityWorldTransform: entity.transform,
            dataManager: dataManager
        )
        return isSuccess

    case .idle:
        AppLogger.shared.anim("Current move type is idle.")
        isSuccess = constructIdleSequence(
            animationSequence: &currentAnimationSequence,
            initIndex: transitionableIndex,
            styleGuide: &styleGuide,
            travelGuide: &travelGuide,
            entityWorldTransform: entity.transform,
            dataManager: dataManager
        )
        return isSuccess

    case .transition:
        AppLogger.shared.anim("Current move type is transition.")
        return .failed

    case .other:
        AppLogger.shared.error("Error: Undetermined init move type.")
        return .failed
    }
    

}

func findNextTransitionableCurrentSequenceIndex(
    currentIndex: Int?,
    animationSequence: [AnimationSequenceElement],
    dataManager: DataManager
) -> Int? {
    var index = currentIndex

    while let idx = index, idx < animationSequence.count {
        let currentElement = animationSequence[idx]
        let animationName = currentElement.animationName

        if currentElement.endPoseName.moveType != .transition {
            if printBrainSystem {
                AppLogger.shared.anim("Found non-transition segment at index \(idx): \(animationName) (endPose \(currentElement.endPoseName)).")
            }
            break
        }
        else {
            index = idx + 1
        }
    }

    if let finalIndex = index, finalIndex >= animationSequence.count {
        AppLogger.shared.error("Error: [2] Index \(finalIndex) is out of bounds. Returning nil.")
        return nil
    }

    return index
}

==== AnimLibS/Brain/Idle/0-IdleSequence.swift ====


import CoreLib
import RealityKit
import simd


func constructIdleSequence(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    styleGuide: inout StyleGuide,
    travelGuide: inout TravelGuide,
    entityWorldTransform: Transform,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    if printBrainSystem { AppLogger.shared.anim("ðŸ§  Constructing idle sequence") }

    let currentElement = animationSequence[initIndex]


    var nextMoveType: MoveType? = .idle
    if travelGuide.targetDestinations.count > 0, travelGuide.targetDestinations[0].inPlace == false {
        nextMoveType = .walk
    } else if travelGuide.targetDestinations.count == 0 {
        AppLogger.shared.error("ðŸ§  Error: No destinations found.")
    }

    AppLogger.shared.anim("ðŸ§  Currently in Idle. Next move type is \(String(describing: nextMoveType)).")

    let isNearEndOfSequence = (animationSequence.count == 1 && currentElement.isNearEndOfSegment())

    let isNewOrientation = !validateIdleAlignment(travelGuide: travelGuide, entityWorldTransform: entityWorldTransform)


    let animStyle = styleGuide.targets[0]
    let needToTransition = animStyle.isNew || isNewOrientation || nextMoveType != .idle

    guard isNearEndOfSequence || needToTransition else {
        AppLogger.shared.anim("ðŸ§  Too early to construct idle sequence. Neither of conditions are true: isNearEndOfSequence: \(isNearEndOfSequence), animStyle.isNew: \(animStyle.isNew), isNewOrientation: \(isNewOrientation), nextMoveType: \(String(describing: nextMoveType)).")
        return .tooEarly
    }


    if needToTransition == false {
        let extensionResult = extendAnimationSequence(
            animationSequence: &animationSequence,
            isFilledOut: false,
            dataManager: dataManager
        )
        if extensionResult == .done {
            AppLogger.shared.debug("âš§ï¸ Extended sequence without transitions.")
            animationSequence[initIndex + 1].isReadyToPlay = true
            return .done
        }
    }


    guard let (lastIndexBeforeTransition, transitionFrame) = findTransitionStart(
        from: initIndex,
        in: &animationSequence,
        dataManager: dataManager,
        printBrainSystem: printBrainSystem
    ) else {
        AppLogger.shared.error("ðŸ§  Error: Failed to find lastIndexBeforeTransition.")
        return .failed
    }

    let startAnimationName = animationSequence[lastIndexBeforeTransition].animationName



    let transitionID: String
    let endAnimationName: String
    let endCriticalPoseIndex: Int

    if nextMoveType == .idle {
        AppLogger.shared.anim("ðŸ§  Constructing Idle To Idle sequence.")

        guard let (_transitionID, _endAnimationName, _endCriticalPoseIndex) = determineIdleToIdleTransitionAndTarget(
            lastElementBelforeTransition: animationSequence[lastIndexBeforeTransition],
            animStyle: animStyle,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("ðŸ§  Error: Failed to build idle to idle sequence.")
            return .failed
        }
        (transitionID, endAnimationName, endCriticalPoseIndex) = (_transitionID, _endAnimationName, _endCriticalPoseIndex)
    } else if nextMoveType == .walk {
        AppLogger.shared.anim("ðŸ§  Constructing Idle To Walk sequence.")

        guard let (_transitionID, _endAnimationName, _endCriticalPoseIndex) = determineIdleToWalkTransitionAndTarget(
            lastElementBelforeTransition: animationSequence[lastIndexBeforeTransition],
            animStyle: animStyle,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("ðŸ§  Error: Failed to build idle to idle sequence.")
            return .failed
        }
        (transitionID, endAnimationName, endCriticalPoseIndex) = (_transitionID, _endAnimationName, _endCriticalPoseIndex)
    } else {
        AppLogger.shared.error("ðŸ§  Error: Invalid move type \(String(describing: nextMoveType)).")
        return .failed
    }



    let buildResult = buildTransitionSequence(
        animationSequence: &animationSequence,
        lastIndexBeforeTransition: lastIndexBeforeTransition,
        transitionFrame: transitionFrame,
        transitionID: transitionID,
        startAnimationName: startAnimationName,
        endAnimationName: endAnimationName,
        endCriticalPoseIndex: endCriticalPoseIndex,
        styleGuide: &styleGuide,
        dataManager: dataManager
    )

    guard buildResult == .done else {
        AppLogger.shared.error("ðŸ§  Error: Failed to build transition sequence.")
        return .failed
    }


    assignInertialInfoForIdle(
        animationSequence: &animationSequence,
        initIndex: initIndex,
        dataManager: dataManager
    )


    for i in initIndex + 1 ..< animationSequence.count {
        animationSequence[i].isFilledOut = true
    }

    animationSequence[initIndex + 1].isReadyToPlay = true

    if !styleGuide.targets.isEmpty {
        styleGuide.targets[0].isNew = false
    }

    return .done
}


private func determineIdleToWalkTransitionAndTarget(
    lastElementBelforeTransition element: AnimationSequenceElement,
    animStyle: StyleTarget,
    dataManager: DataManager
) -> (transitionID: String, endAnimationName: String, endCriticalPoseIndex: Int)? {
    let endAnimation: String
    if let newAnimDataPoint = dataManager.getAnimDataPoint(for: animStyle.animationName),
       newAnimDataPoint.moveList.contains(.walk)
    {
        endAnimation = animStyle.animationName
    } else {
        AppLogger.shared.error("ðŸ§  Error: The move target \(animStyle.animationName) is not a Walk animation. Reverting to default walk animation")
        endAnimation = defaultWalkAnimation
    }

    guard let startCriticalPoseIndex = element.endPoseIndex else {
        AppLogger.shared.error("ðŸ§  Error: endPoseIndex is nil for \(element.animationName).")
        return nil
    }

    guard
        let (transitionID, endPoseIdx) =
        selectIdleToWalkTransitionAndEndAnimations(
            startAnimationName: element.animationName,
            startCriticalPoseIndex: startCriticalPoseIndex,
            endAnimationName: endAnimation,
            endCriticalPoseIndex: nil,
            dataManager: dataManager
        )
    else {
        AppLogger.shared.error("ðŸ§  Error: Failed to select transition and end animations for idle-to-walk sequence.")
        return nil
    }

    return (transitionID, endAnimation, endPoseIdx)
}


private func determineIdleToIdleTransitionAndTarget(
    lastElementBelforeTransition: AnimationSequenceElement,
    animStyle: StyleTarget,
    dataManager: DataManager
) -> (transitionID: String, endAnimationName: String, endCriticalPoseIndex: Int)? {
    if printBrainSystem { AppLogger.shared.anim("ðŸ§  The move target is Idle") }

    let startElement = lastElementBelforeTransition
    let startAnimationName = startElement.animationName
    guard let startAnimeDataPoint = dataManager.getAnimDataPoint(for: startAnimationName) else {
        AppLogger.shared.error("ðŸ§  Error: Animation data point not found for \(startAnimationName).")
        return nil
    }

    let endAnimationName: String

    if animStyle.isNew {
        endAnimationName = animStyle.animationName
    } else if startAnimeDataPoint.isLoop {
        endAnimationName = startAnimationName
    } else {
        endAnimationName = defaultIdleAnimation
    }

    guard let startCriticalPoseIndex = startElement.endPoseIndex else {
        AppLogger.shared.error("ðŸ§  Error: endPoseIndex is nil for \(startAnimationName).")
        return nil
    }

    guard let (transitionID, endAnimationName, endCriticalPoseIndex) = selectIdleToIdleTransitionAndEndAnimations(
        startAnimationName: startAnimationName,
        startCriticalPoseIndex: startCriticalPoseIndex,
        endAnimationDict: [endAnimationName: nil], // animationÂ â†’Â criticalPoseIdx
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("ðŸ§  Error: Failed to select transition and end animations.")
        return nil
    }

    return (transitionID, endAnimationName, endCriticalPoseIndex)
}

func findTransitionStart(
    from initIndex: Int,
    in animationSequence: inout [AnimationSequenceElement],
    dataManager: DataManager,
    printBrainSystem: Bool = printBrainSystem
) -> (startIndex: Int, transitionFrame: Int)? {
    let originalCount = animationSequence.count

    for idx in initIndex ..< originalCount {
        guard let endFrame = animationSequence[idx].endPoseFrame else {
            AppLogger.shared.error("ðŸ§  Error: endPoseFrame is nil for index \(idx).")
            return nil
        }
        let footBones: Set<ExplicitBoneName> = [.leftFoot, .rightFoot]
        if footBones.contains(animationSequence[idx].endPoseName.groundBone) {
            if printBrainSystem {
                AppLogger.shared.anim("ðŸ§  Transition point found at index \(idx), frame \(endFrame)")
            }
            return (idx, endFrame)
        }
    }

    if printBrainSystem {
        AppLogger.shared.debug("ðŸ§  No both-feet-grounded in existing elements; extending idle sequence once")
    }
    let extensionResult = extendAnimationSequence(
        animationSequence: &animationSequence,
        isFilledOut: false,
        dataManager: dataManager
    )
    guard extensionResult == .done else {
        AppLogger.shared.error("ðŸ§  Error: Failed to extend the animation sequence.")
        return nil
    }

    for idx in originalCount ..< animationSequence.count {
        guard let endFrame = animationSequence[idx].endPoseFrame else {
            AppLogger.shared.error("ðŸ§  Error: endPoseFrame is nil for index \(idx).")
            return nil
        }
        if animationSequence[idx].endPoseName.bothFeet == .ground {
            if printBrainSystem {
                AppLogger.shared.anim("ðŸ§  Transition point found at index \(idx), frame \(endFrame)")
            }
            return (idx, endFrame)
        }
    }

    AppLogger.shared.error("ðŸ§  Error: No both-feet-grounded element found even after one extension.")
    return nil
}


private func buildTransitionSequence(
    animationSequence: inout [AnimationSequenceElement],
    lastIndexBeforeTransition: Int,
    transitionFrame: Int,
    transitionID: String,
    startAnimationName: String,
    endAnimationName: String,
    endCriticalPoseIndex: Int,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {

    guard
        let endAnimDP = dataManager.getAnimDataPoint(for: endAnimationName),
        endCriticalPoseIndex < endAnimDP.criticalPoses.count
    else {
        AppLogger.shared.error("ðŸ§  Error: Animation data point not found for \(endAnimationName).")
        return .failed
    }
    let frameForEndAnimation = endAnimDP.criticalPoses[endCriticalPoseIndex].frame

    guard let transitionSequenceData = dataManager.getTransitionSequence(sequenceID: transitionID) else {
        AppLogger.shared.error("ðŸ§  Error: Transition sequence not found for \(transitionID).")
        return .failed
    }

    AppLogger.shared.anim("ðŸ§  Transition sequence: \(transitionID) / \(startAnimationName) / \(endAnimationName)")
    guard let transitionSequence = buildIdleToIdleTransitionSequence(
        transitionID: transitionID,
        startAnimationName: startAnimationName,
        frameForStartAnimation: transitionFrame,
        endAnimationName: endAnimationName,
        frameForEndAnimation: frameForEndAnimation,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("ðŸ§  Error: Transition sequence not found for \(transitionID).")
        return .failed
    }

    let spliceIdx = lastIndexBeforeTransition + 1
    if spliceIdx < animationSequence.count {
        animationSequence.removeSubrange(spliceIdx ..< animationSequence.count)
    }

    if transitionSequenceData.transitionType == .idleToIdle {
        animationSequence.append(contentsOf: transitionSequence)


        guard let endAnimSeq = constructAnimationSequenceForGivenAnimation(
            animationName: endAnimationName,
            startCriticalPoseIndex: endCriticalPoseIndex,
            endCriticalPoseIndex: nil, // Search to end / full loop
            isFilledOut: false,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("ðŸ§  Error: Failed to construct animation sequence for \(endAnimationName).")
            return .failed
        }
        animationSequence.append(contentsOf: endAnimSeq)

        return .done
    }


    else if transitionSequenceData.transitionType == .idleToWalk {


        let lastNonWalkIdx = transitionSequence.lastIndex(where: {
            $0.startPoseName.moveType != .walk
        })

        let idleToWalkElements: [AnimationSequenceElement]
        let walkElements: [AnimationSequenceElement]

        if let n = lastNonWalkIdx {
            idleToWalkElements = Array(transitionSequence[...n])
            walkElements = (n + 1 < transitionSequence.count)
                ? Array(transitionSequence[(n + 1)...])
                : []
        } else {
            idleToWalkElements = []
            walkElements = transitionSequence
        }

        animationSequence.append(contentsOf: idleToWalkElements)

        guard let lastPoseName = animationSequence.last?.endPoseName else {
            AppLogger.shared.error("ðŸ§  Error: Unable to determine last endPoseName for transition sequence.")
            return .failed
        }
        guard let matchingIndices = dataManager.getIndicesOfCriticalPose(
            for: endAnimationName,
            matching: lastPoseName
        ),
            let newStartPoseIndex = matchingIndices.first
        else {
            AppLogger.shared.error(
                "ðŸ§  Error: No matching critical pose '\(lastPoseName)' found in \(endAnimationName)."
            )
            return .failed
        }

        let outcome = transitionToNewStyle(
            currentExtension: walkElements, // this is only the current sequence portion that goes into blendTree
            newAnimationName: endAnimationName,
            startPoseIndex: newStartPoseIndex,
            sequence: &animationSequence,
            styleGuide: &styleGuide,
            fullStepCount: fullStepCount,
            dataManager: dataManager
        )
        return outcome
    } else {
        AppLogger.shared.error("ðŸ§  Error: Unknown transition type \(transitionSequenceData.transitionType).")
        return .failed
    }
}

==== AnimLibS/Brain/Idle/3-build-transition.swift ====


import CoreLib
import Foundation
import RealityKit

func buildIdleToIdleTransitionSequence(
    transitionID: String,
    startAnimationName: String,
    frameForStartAnimation: Int,
    endAnimationName: String,
    frameForEndAnimation: Int,
    dataManager: DataManager
) -> [AnimationSequenceElement]? {
    if printBrainSystem {
        AppLogger.shared.debug("ðŸ§  Building transition sequence out of Idle for \(transitionID).")
    }
    guard let transitionSequence = dataManager.getTransitionSequence(sequenceID: transitionID) else {
        AppLogger.shared.error("ðŸ§  Error: Transition sequence not found for \(transitionID).")
        return nil
    }
    let transitionAnimName = transitionSequence.animationName
    
    if printBrainSystem {
        AppLogger.shared.debug("ðŸ§  Transition type is \(transitionSequence.transitionType) and subtype is \(transitionSequence.transitionSubType).")
    }

    guard let transitionAnimationDataPoint = dataManager.getAnimDataPoint(for: transitionAnimName) else {
        AppLogger.shared.error("ðŸ§  Error: Animation data point not found for \(transitionAnimName).")
        return nil
    }


    guard
        let firstPose = transitionSequence.transitionPoses.first,
        let lastPose = transitionSequence.transitionPoses.last,
        let firstTransitionPose = transitionSequence.transitionPoses.first(where: { $0.transitionPoseType == .firstTransitionPose }),
        let lastTransitionPose = transitionSequence.transitionPoses.first(where: { $0.transitionPoseType == .lastTransitionPose })
    else {
        AppLogger.shared.error("ðŸ§  Error: Transition poses (.firstTransitionPose / .lastTransitionPose) missing in \(transitionID).")
        return nil
    }


    guard
        let availableBefore = dataManager.addFrames(
            animationName: transitionAnimName,
            frameA: firstPose.frame,
            frameB: firstTransitionPose.frame
        ),
        let availableAfter = dataManager.addFrames(
            animationName: transitionAnimName,
            frameA: lastTransitionPose.frame,
            frameB: lastPose.frame
        )
    else {
        AppLogger.shared.error("ðŸ§  Error computing clipâ€‘in/out frames for \(transitionAnimName).")
        return nil
    }

    let framesBefore = min(30, availableBefore)
    let framesAfter = min(30, availableAfter)

    guard
        let firstSequenceFrame = addFramesLooping(
            animationName: transitionAnimName,
            currentFrame: firstTransitionPose.frame,
            frameCountToAdd: -framesBefore,
            dataManager: dataManager
        ),
        let lastSequenceFrame = addFramesLooping(
            animationName: transitionAnimName,
            currentFrame: lastTransitionPose.frame,
            frameCountToAdd: framesAfter,
            dataManager: dataManager
        )
    else {
        AppLogger.shared.error("ðŸ§  Internal error computing clipâ€‘in/out frames for \(transitionAnimName)")
        return nil
    }
    
    AppLogger.shared.debug("âš§ï¸ Clip-in/out frames for \(transitionAnimName): \(firstSequenceFrame) / \(lastSequenceFrame), and \(framesBefore) / \(framesAfter) frames available and first transition pose frame is \(firstTransitionPose.frame) and last transition pose frame is \(lastTransitionPose.frame).")
    

    guard
        let firstCriticalPoseIndex = dataManager.preceedingCriticalPose(
            animationName: transitionAnimName,
            frameIncl: firstSequenceFrame
        ),
        let lastCriticalPoseIndex = dataManager.followingCriticalPose(
            animationName: transitionAnimName,
            frameIncl: lastSequenceFrame
        )
    else {
        AppLogger.shared.error("ðŸ§  Error deriving criticalâ€‘pose indices for clipâ€‘in/out in \(transitionAnimName).")
        return nil
    }


    guard var sequence = constructAnimationSequenceForGivenAnimation(
        animationName: transitionAnimName,
        startCriticalPoseIndex: firstCriticalPoseIndex,
        endCriticalPoseIndex: lastCriticalPoseIndex,
        isFilledOut: false,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("ðŸ§  Error constructing animation sequence for \(transitionAnimName).")
        return nil
    }

    let firstIndex = 0
    let lastIndex = max(0, sequence.count - 1)

    sequence[firstIndex].lateStartFrame = firstSequenceFrame
    sequence[lastIndex].earlyStopFrame = lastSequenceFrame


    var adjustedTransitionPoses = transitionSequence.transitionPoses

    if let precedingIdx = dataManager.preceedingCriticalPose(
        animationName: transitionAnimName,
        frameIncl: firstPose.frame
    ) {
        let newFrame = transitionAnimationDataPoint.criticalPoses[precedingIdx].frame
        adjustedTransitionPoses[0].frame = newFrame
    }


    if let lastIdx = adjustedTransitionPoses
        .firstIndex(where: { $0.transitionPoseType == .lastTransitionPose }),
        let followingIdx = dataManager.followingCriticalPose(
            animationName: transitionAnimName,
            frameIncl: lastTransitionPose.frame
        )
    {
        let newFrame = transitionAnimationDataPoint.criticalPoses[followingIdx].frame
        adjustedTransitionPoses[lastIdx].frame = newFrame // â† only the genuine lastâ€‘transition pose
    }

    let startReferenceDict = AnimFrameDict(animationName: startAnimationName, frame: frameForStartAnimation)
    let endReferenceDict = AnimFrameDict(animationName: endAnimationName, frame: frameForEndAnimation)


    for i in 0 ..< sequence.count {
        var elem = sequence[i]

        guard let startMeta = adjustedTransitionPoses.first(where: { $0.frame == elem.startPoseFrame }),
              let endMeta = adjustedTransitionPoses.first(where: { $0.frame == elem.endPoseFrame })
        else {
            continue
        }

        let startAlter = PoseMatchTransformAlteration(
            startReferenceAnimFrameDict: startReferenceDict,
            endReferenceAnimFrameDict: endReferenceDict,
            poseAdjustment: startMeta.poseAdjustment,
            baseSide: startMeta.poseAdjustmentSide,
            referenceTransformType: startMeta.referenceTransformType,
            sideFootRotationType: startMeta.sideFootRotationType,
            otherSideFootRotationType: startMeta.otherSideFootRotationType
        )

        let endAlter = PoseMatchTransformAlteration(
            startReferenceAnimFrameDict: startReferenceDict,
            endReferenceAnimFrameDict: endReferenceDict,
            poseAdjustment: endMeta.poseAdjustment,
            baseSide: endMeta.poseAdjustmentSide,
            referenceTransformType: endMeta.referenceTransformType,
            sideFootRotationType: endMeta.sideFootRotationType,
            otherSideFootRotationType: endMeta.otherSideFootRotationType
        )

        elem.animAlteration = AnimAlteration(
            walkCircleAlteration: nil,
            strideLength: nil,
            matchTransformAlteration: MatchTransformAlteration(
                startPoseMatch: startAlter,
                endPoseMatch: endAlter
            )
        )
        sequence[i] = elem
    }

    return sequence
}

==== AnimLibS/Brain/Walk/2-ExtendWalkSequence.swift ====


import CoreLib

let fullStepCount = 2



func extendInitWalkSequence(
    currentAnimationSequence: inout [AnimationSequenceElement],
    initAnimationSequenceIndex: Int,
    keepExistingElements: Bool = true,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    if printBrainSystem {
        AppLogger.shared.anim("ðŸ§  Extending Init Walk Sequence â€“ keepExistingElements = \(keepExistingElements)")
    }

    if keepExistingElements {
        if countFullSteps(after: initAnimationSequenceIndex,
                          in: currentAnimationSequence,
                          dataManager: dataManager) >= fullStepCount,
            styleGuide.targets[0].isNew == false

        {
            if printBrainSystem {
                AppLogger.shared.anim("ðŸ§  Already have \(fullStepCount) full steps after index \(initAnimationSequenceIndex) and style guide is not new.")
            }
            return
        }

        appendMissingSteps(to: &currentAnimationSequence,
                           styleGuide: &styleGuide,
                           dataManager: dataManager)
    } else {
        replaceTailThenAppend(to: &currentAnimationSequence,
                              initIdx: initAnimationSequenceIndex,
                              styleGuide: &styleGuide,
                              dataManager: dataManager)
    }
}


private func appendMissingSteps(
    to sequence: inout [AnimationSequenceElement],
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    guard let lastElement = sequence.last,
          let endPoseIndex = lastElement.endPoseIndex
    else {
        AppLogger.shared.error("Error: Sequence is empty or last element has nil endPoseIndex.")
        return
    }

    let animationName = lastElement.animationName
    guard let animDataPoint = dataManager.getAnimDataPoint(for: animationName) else {
        AppLogger.shared.error("Error: Animation data not found for \(animationName).")
        return
    }
    guard
        let styleTarget = styleGuide.targets.first,
        let newAnimDataPoint = dataManager.getAnimDataPoint(for: styleTarget.animationName)
    else {
        AppLogger.shared.error("Error: StyleGuide has no targets.")
        return
    }

    let currentIsLoopWalk = animDataPoint.isLoop && animDataPoint.moveList == [.walk]
    let switchingToNewWalkingLoopStyle = styleTarget.isNew && newAnimDataPoint.isLoop && newAnimDataPoint.moveList == [.walk]


    if currentIsLoopWalk == false, switchingToNewWalkingLoopStyle == false {
        guard endPoseIndex < animDataPoint.criticalPoses.count else {
            AppLogger.shared.error("Error: endPoseIndex \(endPoseIndex) is out of bounds for animation \(animationName).")
            return
        }
        let startCriticalPoseName = animDataPoint.criticalPoses[endPoseIndex].poseName
        guard
            let allMatches = dataManager.getIndicesOfCriticalPose(
                for: styleTarget.animationName,
                matching: startCriticalPoseName
            ),
            let startIndex = allMatches.first
        else {
            AppLogger.shared.error("Error: No matching critical pose found for \(startCriticalPoseName) in style animation \(styleTarget.animationName).")
            return
        }
        

        extendWithCurrentWalkLoop(into: &sequence,
                                  styleAnimationName: styleTarget.animationName,
                                  startPoseIndex: startIndex,
                                  styleGuide: &styleGuide,
                                  dataManager: dataManager)
        return
    }
    

    guard let currentExtension = buildWalkSequenceExtension(
        animationName: animationName,
        startPoseIndex: endPoseIndex,
        fullStepCount: fullStepCount,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Failed to build extension for \(animationName).")
        return
    }

    if !switchingToNewWalkingLoopStyle {
        appendElements(currentExtension, to: &sequence, logSuffix: "(no transition)")
        return
    }

    if printBrainSystem {
        AppLogger.shared.anim("ðŸ§  Transitioning to new style \(styleTarget.animationName)")
    }
    let endPoseName = lastElement.endPoseName
    guard
        let indices = dataManager.getIndicesOfCriticalPose(
            for: styleTarget.animationName,
            matching: endPoseName
        ),
        let startPoseIndex = indices.first
    else {
        AppLogger.shared.error("Error: No matching critical pose found for \(endPoseName) in style animation \(styleTarget.animationName).")
        return
    }

    transitionToNewStyle(
        currentExtension: currentExtension, // put in only the blend-in portion
        newAnimationName: styleTarget.animationName,
        startPoseIndex: startPoseIndex,
        sequence: &sequence,
        styleGuide: &styleGuide,
        fullStepCount: fullStepCount, // for looping animation. uses max available array of walk critical poses for non-looping walks
        dataManager: dataManager
    )
}


private func replaceTailThenAppend(
    to sequence: inout [AnimationSequenceElement],
    initIdx: Int,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    var trimStart = initIdx + 1
    let initElement = sequence[initIdx]

    if !initElement.endPoseName.isStepFirstPose,
       let stepID = getStepID(for: initElement, dataManager: dataManager)
    {
        while trimStart < sequence.count,
              getStepID(for: sequence[trimStart], dataManager: dataManager) == stepID
        {
            trimStart += 1
        }
    }

    if let initAnimData = dataManager.getAnimDataPoint(for: initElement.animationName),
       !(initAnimData.isLoop && initAnimData.moveList == [.walk])
    {
        while trimStart < sequence.count {
            if let ad = dataManager.getAnimDataPoint(for: sequence[trimStart].animationName),
               !(ad.isLoop && ad.moveList == [.walk])
            {
                trimStart += 1
            } else {
                break
            }
        }
    }

    if trimStart < sequence.count {
        sequence.removeSubrange(trimStart...)
    }

    appendMissingSteps(to: &sequence,
                       styleGuide: &styleGuide,
                       dataManager: dataManager)
}


private func extendWithCurrentWalkLoop(
    into sequence: inout [AnimationSequenceElement],
    styleAnimationName: String,
    startPoseIndex: Int,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    guard let styleAnimData = dataManager.getAnimDataPoint(for: styleAnimationName),
          styleAnimData.isLoop, styleAnimData.moveList == [.walk]
    else {
        AppLogger.shared.error("Error: Style animation \(styleAnimationName) is not a looping walk.")
        return
    }
    guard let ext = buildWalkSequenceExtension(
        animationName: styleAnimationName,
        startPoseIndex: startPoseIndex,
        fullStepCount: fullStepCount,
        dataManager: dataManager
    )
    else {
        AppLogger.shared.error("Error: Could not build extension for style animation \(styleAnimationName).")
        return
    }
    appendElements(ext, to: &sequence, logSuffix: "(transition)")
    styleGuide.targets[0].isNew = false
}

func transitionToNewStyle(
    currentExtension: [AnimationSequenceElement], // this is only the current sequence portion that goes into blendTree
    newAnimationName styleAnimationName: String,
    startPoseIndex: Int,
    sequence: inout [AnimationSequenceElement],
    styleGuide: inout StyleGuide,
    fullStepCount: Int,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    guard let targetExtension = buildWalkSequenceExtension(
        animationName: styleAnimationName,
        startPoseIndex: startPoseIndex,
        fullStepCount: fullStepCount, // uses it for looping animation
        dataManager: dataManager
    )
    else {
        AppLogger.shared.error("Error: Failed to build extension for new style \(styleAnimationName).")
        return .failed
    }
    guard let blended = attachBlendInSequence(
        origExtension: currentExtension,
        targetExtension: targetExtension,
        dataManager: dataManager
    )
    else {
        AppLogger.shared.error("Error: Failed to create blend for transition to \(styleAnimationName).")
        return .failed
    }
    appendElements(blended, to: &sequence, logSuffix: "(blend to \(styleAnimationName))")
    styleGuide.targets[0].isNew = false
    
      return  .done
}

==== AnimLibS/SettingsAndDataStructs/AnimationSettings.swift ====

import CoreLib
import Foundation
import RealityKit
import simd

func buildWalkTransitionalSequence(
    currentAnimationSequence: inout [AnimationSequenceElement],
    initAnimationSequenceIndex: Int,
    transitionalAnimationNames: inout [String],
    dataManager: DataManager
) {
    if printBrainSystem { AppLogger.shared.anim("ðŸ§  Building walk transitional sequence. Candidates: \(transitionalAnimationNames).") }
    


let frameRate: Float = 60

let minSequenceLengthFrames = 120

let minBlendingFrameCount: Float = 15

let withinEndFrameCount = 3


let dataExportJsonPath = "/Users/nata/GitHub/NextTaleApp/NataRestart/ExportData/exportFromXCode.json"

let systemWideSpeedMultiplier: Float = 1


let printEventSystem = false
let printBrainSystem = true
let printAnimationSystem = true
let printTravelSystem = false
let printPlot = false // required printTravelSystem = true


let defaultAnimation =  "01001_1_Move_WalkFast_M" //"01001_7_Move_WalkSlow_M_2L"//"01003_2_02_Relax_Walk"  // "01003_5_20_Thinking_Walk"

let defaultIdleAnimation = "01001_2_Stand_Looking_M"
let defaultWalkAnimation = "01001_7_Move_WalkSlow_M_2L"

@MainActor let mustFinishMoveTypes: [MoveType] = [.transition]

@MainActor let startTransitionPoseTypeForWalk: PoseType = .low

let footRollAngleMin = Float.pi/6
let footRollAngleMax = Float.pi * 2/3
let footRollQuatMin = simd_quatf(angle: footRollAngleMin, axis: SIMD3<Float>(1, 0, 0)) // 30 degrees = pi / 6
let footRollQuatMax = simd_quatf(angle: footRollAngleMax, axis: SIMD3<Float>(1, 0, 0)) // 120 degrees = pi * 2/3

let calfRollQuatMax = simd_quatf(angle: -Float.pi/36, axis: SIMD3<Float>(1, 0, 0)) // -5 degrees = -pi/36 radians
let calfRollQuatMaxForLiftedFoot = simd_quatf(angle: -Float.pi/18, axis: SIMD3<Float>(1, 0, 0)) // -10 degrees = -pi/18 radians

let raiseOtherToebaseBy: SIMD3<Float> = .init(0, 0, 1)


let identityTransform = Transform(
    scale: SIMD3<Float>(1, 1, 1), // No scaling
    rotation: simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0)), // No rotation
    translation: SIMD3<Float>(0, 0, 0) // No translation
)

@MainActor public let animationComponentQuery = EntityQuery(where:
    .has(BrainComponent.self) &&
        .has(TravelComponent.self) &&
        .has(AnimationComponent.self)
)

==== AnimLibS/SettingsAndDataStructs/StyleGuide.swift ====


struct StyleGuide {
    var targets: [StyleTarget] = [.init(style: "default", baseAnimName: "01003_2_02_Relax_Walk", isNew: false)]
}

struct StyleTarget {
    var style: String
    var animationName: String
    var isNew: Bool

    init(style: String, baseAnimName: String, isNew: Bool) {
        self.style = style
        self.animationName = baseAnimName
        self.isNew = isNew
    }
}

let styleGuides: [StyleGuide] = [
    StyleGuide(targets: [
        .init(style: "default",
              baseAnimName: "01003_5_20_Thinking_Walk",
              isNew: false)
    ]),
    StyleGuide(targets: [
        .init(style: "default",
              baseAnimName: "01003_2_02_Relax_Walk",
              isNew: false)
    ]),
    StyleGuide(targets: [
        .init(style: "default",
              baseAnimName: "01001_1_Move_WalkFast_M",
              isNew: false)
    ])
]

==== AnimLibS/SettingsAndDataStructs/TravelGuide.swift ====

import CoreLib
import joystickController
import simd

struct TravelGuide {
    var targetDestinations: [TravelTarget] = [] //  this is what we want to achieve.
    var estPathway: [TravelTarget] = [] //calculated based on available animations. Way-points expressed in world coordinates.

    var isNewDestination: Bool {
        return targetDestinations.contains(where: { $0.isNew })
    }

    var veerOffPathDeltaThreshold: Float = 0.1
    var radiusThreshold: Float = 4
}

extension TravelGuide {
    func constructPathwayCurve() -> [SIMD3<Float>] {
        guard let startLocation = targetDestinations.first?.location else { return [] }
        var curvePoints: [SIMD3<Float>] = []
        for target in targetDestinations {
            guard let loc = target.location else { continue }
            if simd_length(loc - startLocation) > radiusThreshold {
                break
            }
            curvePoints.append(loc)
        }
        return curvePoints
    }
    
    func distanceToPathway(from point: SIMD3<Float>) -> (distance: Float, projection: SIMD3<Float>) {
        let curvePoints = constructPathwayCurve()
        
        guard !curvePoints.isEmpty else {
            return (simd_length(point), SIMD3<Float>(repeating: 0))
        }
        if dataManager.getAnimDataPoint(for: step1animationNameMIN) == nil {
            adjustStrideForWalkAnimationMIN(animationName: step1animationName,
                                            dataManager: dataManager)
        }
    }
    
    guard let stride1Data = dataManager.getStepData(
        for: step1animationName,
        criticalPoseIndex: step1CriticalPoseIndex
    )
    else {
        return
    }
    let maxStride1 = stride1Data.maxStride
    let minStride1 = stride1Data.minStride
    
    
    var stride2Data: StepData?
    var maxStride2: Float?
    var minStride2: Float?
    if let secondOccurrenceIndex = animationSequence[animationSequence.index(after: firstOccurrenceIndex)...]
        .firstIndex(where: { elem in
            guard elem.startPoseName.isStepFirstPose,
                  let dp = dataManager.getAnimDataPoint(for: elem.animationName),
                  dp.criticalPoses[elem.startPoseIndex].stepID != nil // â† NEW filter
            else { return false }
            return true
        })
    {
        let step2animationName = animationSequence[secondOccurrenceIndex].animationName
        let step2CriticalPoseIndex = animationSequence[secondOccurrenceIndex].startPoseIndex
        let step2animationNameMAX = "\(step2animationName)--strideMAX"
        let step2animationNameMIN = "\(step2animationName)--strideMIN"
            
        if let dp2 = dataManager.getAnimDataPoint(for: step2animationName),
           dp2.criticalPoses[step2CriticalPoseIndex].stepID != nil
        {
            if dataManager.getAnimDataPoint(for: step2animationNameMAX) == nil {
                adjustStrideForWalkAnimationMAX(animationName: step2animationName,
                                                dataManager: dataManager)
            }
            if dataManager.getAnimDataPoint(for: step2animationNameMIN) == nil {
                adjustStrideForWalkAnimationMIN(animationName: step2animationName,
                                                dataManager: dataManager)
            }
        }
            
        guard let stride2DataCalc = dataManager.getStepData(for: step2animationName, criticalPoseIndex: step2CriticalPoseIndex) else {
            return
        }
        
        if curvePoints.count == 1 {
            let singlePoint = curvePoints[0]
            return (simd_length(point - singlePoint), singlePoint)
        }
        
        func distanceFromPointToSegment(point: SIMD3<Float>, a: SIMD3<Float>, b: SIMD3<Float>) -> (distance: Float, projection: SIMD3<Float>) {
            let ab = b - a
            let t = simd_dot(point - a, ab) / simd_dot(ab, ab)
            let clampedT = max(0, min(1, t))
            let proj = a + clampedT * ab
            let dist = simd_length(point - proj)
            return (dist, proj)
        }
        
        var minDistance: Float = .greatestFiniteMagnitude
        var bestProjection = SIMD3<Float>(repeating: 0)
        
        for i in 0 ..< (curvePoints.count - 1) {
            let a = curvePoints[i]
            let b = curvePoints[i + 1]
            let result = distanceFromPointToSegment(point: point, a: a, b: b)
            if result.distance < minDistance {
                minDistance = result.distance
                bestProjection = result.projection
            }
        }
        return (minDistance, bestProjection)
    }
    
    func calculatePathCorrectionQuaternion(endLocation: SIMD3<Float>) -> simd_quatf {
        let (minDistance, bestProjection) = distanceToPathway(from: endLocation)
        let threshold = veerOffPathDeltaThreshold
        
        if minDistance > threshold {
            let fromVector = simd_normalize(endLocation)
            let toVector = simd_normalize(bestProjection)
            let dotProd = simd_dot(fromVector, toVector)
            let clampedDot = max(-1, min(1, dotProd))
            let angle = acos(clampedDot)
            if angle.isNaN || angle < 0.0001 {
                return simd_quatf(angle: 0, axis: SIMD3<Float>(0, 0, 1))
            } else {
                let axis = simd_normalize(simd_cross(fromVector, toVector))
                return simd_quatf(angle: angle, axis: axis)
            }
        } else {
            return simd_quatf(angle: 0, axis: SIMD3<Float>(0, 0, 1))
        }
    }
    
    func distanceAfterPathCorrection(location: SIMD3<Float>, using correctionQuaternion: simd_quatf) -> Float {
        let rotationMatrix = simd_matrix3x3(correctionQuaternion)
        let correctedLocation = rotationMatrix * location
        let (distanceAfterCorrection, _) = distanceToPathway(from: correctedLocation)
        return distanceAfterCorrection
    }
}

struct TravelTarget {
    var priority: Double = 0.5
    var urgency: Double = 0.5
    var inPlace: Bool = true
    var location: SIMD3<Float>?
    var rotation: simd_quatf?
    
    var areaScope: areaScope = .point
    var isTransit: Bool = false
    var id: String?
    var isNew: Bool = false
    
    init(priority: Double = 0.5,
         urgency: Double = 0.5,
         inPlace: Bool = true,
         location: SIMD3<Float>,
         rotation: simd_quatf,
         areaScope: areaScope = .point,
         isTransit: Bool = false,
         id: String,
         isNew: Bool = false)
    {
        self.priority = priority
        self.urgency = urgency
        self.inPlace = inPlace
        self.location = location
        self.rotation = rotation
        self.areaScope = areaScope
        self.isTransit = isTransit
        self.id = id
        self.isNew = isNew
    }

    init(priority: Double = 0.5,
         urgency: Double = 0.5,
         inPlace: Bool = true,
         areaScope: areaScope = .point,
         isTransit: Bool = false,
         isNew: Bool = false)
    {
        self.priority = priority
        self.urgency = urgency
        self.inPlace = inPlace
        self.areaScope = areaScope
        self.isTransit = isTransit
        self.id = nil
        self.location = nil
        self.rotation = nil
        self.isNew = isNew
    }

    if element.animAlteration == nil {
        element.animAlteration = AnimAlteration(
            walkCircleAlteration: WalkCircleAlteration(
                cirWalkDegree: cirDeg,
                cirBlendInfo: blend
            ),
            strideLength: nil
        )
    } else {
        element.animAlteration?.walkCircleAlteration =
            WalkCircleAlteration(cirWalkDegree: cirDeg, cirBlendInfo: blend)
    }

    if let dL = element.deltaLocation { element.deltaLocation = deltaQuat.act(dL) }
    if let dR = element.deltaRotation { element.deltaRotation = deltaQuat * dR }
    
    enum areaScope {
        case point
        case circle
        case rectangle
    }
}

==== joystickControllerS/ExternalDataProtocol.swift ====


import SwiftUI 

public protocol JoystickDataProvider {
    var joystickMagnitude: CGFloat { get }
    var joystickAngle: Angle { get }
    var joystickIsTouching: Bool { get }
    var cameraYaw: Angle { get }
    var isHoldingButton: Bool { get }
}

==== joystickControllerS/UI/ActionButtonView.swift ====


import SwiftUI

public struct ActionButtonView: View {
    public var onPressStart: (() -> Void)?
    public var onPressEnd:   (() -> Void)?
    
    @State private var isPressed = false
    
    private let size: CGFloat = 80
    
    public init(onPressStart: (() -> Void)? = nil,
                onPressEnd:   (() -> Void)? = nil)
    {
        self.onPressStart = onPressStart
        self.onPressEnd   = onPressEnd
    }
    
    public var body: some View {
        Circle()
            .fill(Color.blue.opacity(isPressed ? 0.6 : 0.8))
            .frame(width: size, height: size)
            .overlay(
                Circle().stroke(Color.white, lineWidth: 4)
            )
            .shadow(radius: 8)
            .gesture(
                DragGesture(minimumDistance: 0)
                    .onChanged { _ in
                        if !isPressed {
                            isPressed = true
                            onPressStart?()
                        }
                    }
                    .onEnded { _ in
                        isPressed = false
                        onPressEnd?()
                    }
            )
            .accessibilityLabel("Action button")
    }
}

==== joystickControllerS/UI/JoystickController.swift ====

import SwiftUI

public struct JoystickView: View {
    public var onChange: ((CGFloat, Angle) -> Void)?
    
    public var onEnd: (() -> Void)?

    @State private var joystickPosition: CGSize = .zero
    @State private var isDragging: Bool = false
    
    private let radius: CGFloat = 85

    public init(onChange: ((CGFloat, Angle) -> Void)? = nil,
                onEnd: (() -> Void)? = nil)
    {
        self.onChange = onChange
        self.onEnd = onEnd
    }
    
    public var body: some View {
        ZStack {
            Circle()
                .fill(Color.gray.opacity(0.3))
                .frame(width: 170, height: 170)
            
            Circle()
                .fill(Color(red: 81/255, green: 156/255, blue: 72/255))
                .frame(width: 90, height: 90)
                .overlay(
                    Circle()
                        .stroke(Color(red: 60/255, green: 115/255, blue: 53/255), lineWidth: 3)
                )
                .overlay(
                    Circle()
                        .stroke(Color(red: 136/255, green: 219/255, blue: 125/255), lineWidth: 9)
                )
                .shadow(color: Color(red: 0/255, green: 100/255, blue: 0/255).opacity(0.5),
                        radius: 9, x: 0, y: 9)
                .shadow(color: Color.black.opacity(0.3), radius: 2.5, x: 0, y: 2.5)
                .opacity(isDragging ? 0.7 : 1.0)
                .offset(joystickPosition)
                .gesture(
                    DragGesture()
                        .onChanged { value in
                            if !isDragging {
                                withAnimation { isDragging = true }
                            }
                            
                            let translation = value.translation
                            let distance = min(sqrt(translation.width * translation.width +
                                    translation.height * translation.height), radius)
                            
                            let rawAngle = atan2(translation.height, translation.width)
                            
                            var adjustedAngle = rawAngle + .pi/2
                            if adjustedAngle > .pi { adjustedAngle -= 2 * .pi }
                            if adjustedAngle <= -.pi { adjustedAngle += 2 * .pi }
                            
                            joystickPosition = CGSize(
                                width: distance * cos(rawAngle),
                                height: distance * sin(rawAngle)
                            )
                            
                            onChange?(distance/radius, Angle(radians: Double(adjustedAngle)))
                        }
                        .onEnded { _ in
                            withAnimation {
                                isDragging = false
                                joystickPosition = .zero
                            }
                            onEnd?()
                        }
                )
        }
    }
}

struct BlendTree: Equatable {
    var blendNodes: [BlendNode]
}

struct BlendNode: Equatable {
    var blendElement: AnimationSequenceElement
    var blendInfo: BlendInfo
}

struct AnimAlteration: Equatable {
    var walkCircleAlteration: WalkCircleAlteration?
    var strideLength: Float?
    var matchTransformAlteration: MatchTransformAlteration?
}

struct WalkCircleAlteration: Equatable {
    var cirWalkDegree: Float?
    var cirCoreBlendInfo: BlendInfo?
    var cirNonCoreBlendInfo: BlendInfo?
    var cirBlendInfo: BlendInfo?
    var startIsAltered: Bool {
        guard let degree = cirWalkDegree, degree != 0 else { return false }

        let infos = [cirCoreBlendInfo, cirNonCoreBlendInfo, cirBlendInfo]

        if infos.allSatisfy({ $0 == nil }) {
            return true
        }

        let isUnaltered = infos.compactMap { $0 }.allSatisfy {
            ($0.ownBlendWeightType == .increasing && $0.fromEffectiveSeriesDuration == 0)
                || $0.ownBlendWeightType == .fixedAt0
        }

        return !isUnaltered
    }

    var endIsAltered: Bool {
        guard let degree = cirWalkDegree, degree != 0 else { return false }

        let infos = [cirCoreBlendInfo, cirNonCoreBlendInfo, cirBlendInfo]

        if infos.allSatisfy({ $0 == nil }) {
            return false
        }

        let isUnaltered = infos.compactMap { $0 }.allSatisfy {
            ($0.ownBlendWeightType == .decreasing && $0.toEffectiveSeriesDuration == $0.totalEffectiveSeriesDuration)
                || $0.ownBlendWeightType == .fixedAt0
        }

        return !isUnaltered
    }
}

struct MatchTransformAlteration: Equatable {
    let startPoseMatch: PoseMatchTransformAlteration?
    let endPoseMatch: PoseMatchTransformAlteration?
}

struct PoseMatchTransformAlteration: Equatable {
    let startReferenceAnimFrameDict: AnimFrameDict
    let endReferenceAnimFrameDict: AnimFrameDict
    let poseAdjustment: PoseAdjustment
    let baseSide: Side // usually weight-leaning side
    let referenceTransformType: StartEndType
    let sideFootRotationType: StartEndType
    let otherSideFootRotationType: StartEndType
}

struct AnimFrameDict: Equatable {
    let animationName: String
    let frame: Int
}

struct InertialUnit: Equatable {
    var boneIndices: [Int]? // <-  if nill then all bones
    var blendFrames: Int // count of frames over blending interval (starting with ultimate start or end)
    var isReverse: Bool
}

private extension Array where Element == Int {
    func firstIndexGE(to x: Int) -> Int? { firstIndex(where: { $0 >= x }) }
    func lastIndexLE(to x: Int) -> Int? { lastIndex(where: { $0 <= x }) }
}
