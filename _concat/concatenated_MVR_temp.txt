==== AnimLibS/Brain/BrainAnimationSequence.swift ====

import CoreLib
import RealityKit

enum buildAnimationSequenceOutcome {
    case tooEarly
    case done
    case alreadyReady
    case failed
}

@MainActor // Debug: to delete //üëÄ
func buildAnimationSequence(
    entity: Entity, // Debug: to delete //üëÄ
    currentAnimationSequence: inout [AnimationSequenceElement],
    initAnimationSequenceIndex: inout Int,
    styleGuide: inout StyleGuide,
    travelGuide: inout TravelGuide,
    eventComponent: EventComponent?, // Debug: to delete //üëÄ
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    var isSuccess: buildAnimationSequenceOutcome = .failed

    guard let transitionableIndex = findNextTransitionableCurrentSequenceIndex(
        currentIndex: initAnimationSequenceIndex,
        animationSequence: currentAnimationSequence,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("üß† Error: No animation segments after custom animation segments.")
        return .failed
    }

    guard transitionableIndex == 0 else {
        AppLogger.shared.anim("üß† Too early to transition. Skipping buildAnimationSequence.")
        return .tooEarly
    }

    if transitionableIndex + 1 < currentAnimationSequence.count,
       currentAnimationSequence[transitionableIndex + 1].isReadyToPlay == true,
       styleGuide.targets[0].isNew == false
    {
        AppLogger.shared.anim("üß† Next element already ready to play. Skipping buildAnimationSequence.")
        return .alreadyReady
    }

    let initAnimationSequenceElement = currentAnimationSequence[transitionableIndex]
    
    
    guard
        let currentFrame = initAnimationSequenceElement.currentFrame,
        let endPoseFrame = initAnimationSequenceElement.endPoseFrame
    else {
        AppLogger.shared.error("üß† Error: Current frame or end pose frame is nil.")
        return .failed
    }
    
    

    let initMoveType = initAnimationSequenceElement.endPoseName.moveType
    
    if let firstTargetDestination = travelGuide.targetDestinations.first {
        AppLogger.shared.anim("üß† TravelGuide First Destination: inPlace: \(firstTargetDestination.inPlace)  |  isNew: \(firstTargetDestination.isNew)")
    } else {
        AppLogger.shared.anim("üß† TravelGuide: no destinations.")
    }

    switch initMoveType {
    case .walk:
        
        guard initAnimationSequenceElement.isNearEndOfSegment() else {
            if printBrainSystem {
                AppLogger.shared.anim("Too early to construct walk‚Äëto‚Äëwalk transition; segment not yet close to the end.")
            }
            return .tooEarly
        }

        AppLogger.shared.anim("Current move type is walk.")
        isSuccess = constructWalkSequence(
            animationSequence: &currentAnimationSequence,
            initIndex: transitionableIndex,
            styleGuide: &styleGuide,
            travelGuide: &travelGuide,
            entityWorldTransform: entity.transform,
            dataManager: dataManager
        )
        return isSuccess

    case .idle:
        AppLogger.shared.anim("Current move type is idle.")
        isSuccess = constructIdleSequence(
            animationSequence: &currentAnimationSequence,
            initIndex: transitionableIndex,
            styleGuide: &styleGuide,
            travelGuide: &travelGuide,
            entityWorldTransform: entity.transform,
            dataManager: dataManager
        )
        return isSuccess

    case .transition:
        AppLogger.shared.anim("Current move type is transition.")
        return .failed

    case .other:
        AppLogger.shared.error("Error: Undetermined init move type.")
        return .failed
    }
    

}

func findNextTransitionableCurrentSequenceIndex(
    currentIndex: Int?,
    animationSequence: [AnimationSequenceElement],
    dataManager: DataManager
) -> Int? {
    var index = currentIndex

    while let idx = index, idx < animationSequence.count {
        let currentElement = animationSequence[idx]
        let animationName = currentElement.animationName

        if currentElement.endPoseName.moveType != .transition {
            if printBrainSystem {
                AppLogger.shared.anim("Found non-transition segment at index \(idx): \(animationName) (endPose \(currentElement.endPoseName)).")
            }
            break
        }
        else {
            index = idx + 1
        }
    }

    if let finalIndex = index, finalIndex >= animationSequence.count {
        AppLogger.shared.error("Error: [2] Index \(finalIndex) is out of bounds. Returning nil.")
        return nil
    }

    return index
}

==== AnimLibS/Brain/Travel&StyleEvents.swift ====


import CoreLib
import Foundation
import joystickController
import RealityKit
import simd


func setAnimationStyleWithButton(
    styleGuides: [StyleGuide],
    eventComponent: inout EventComponent,
    dataProvider: JoystickDataProvider
) {
    let wasHolding = eventComponent.lastButtonState
    let isHolding = dataProvider.isHoldingButton
    defer { eventComponent.lastButtonState = isHolding }

    guard wasHolding, !isHolding else { return }

    let isIdle = eventComponent.travelGuide.targetDestinations.first?.inPlace ?? true
    let relevantMoveType: MoveType = isIdle ? .idle : .walk

    let filteredGuides = styleGuides.filter { guide in
        guard let firstTarget = guide.targets.first else { return false }
        return firstTarget.moveType == relevantMoveType
    }
    guard !filteredGuides.isEmpty else { return }

    let storedIndex = isIdle ? eventComponent.currentIdleGuideIndex : eventComponent.currentWalkGuideIndex
    let currentAnimName = eventComponent.styleGuide.targets.first?.animationName

    let matchedIndex = currentAnimName.flatMap { animName in
        filteredGuides.firstIndex(where: { $0.targets.first?.animationName == animName })
    }

    var currentIndex = matchedIndex ?? storedIndex
    if currentIndex < -1 || currentIndex >= filteredGuides.count {
        currentIndex = -1
    }

    let nextIndex = (currentIndex + 1) % filteredGuides.count

    if isIdle {
        eventComponent.currentIdleGuideIndex = nextIndex
    } else {
        eventComponent.currentWalkGuideIndex = nextIndex
    }

    var guide = filteredGuides[nextIndex]
    guide.targets = guide.targets.map { tgt in
        var t = tgt
        t.isNew = true
        return t
    }
    eventComponent.styleGuide = guide
}

func setAnimationStyleWithAIIdleSuggestion(
    eventComponent: inout EventComponent,
    dataProvider: JoystickDataProvider
) {
    guard let aiProvider = dataProvider as? AIIdleAnimationSuggestionProvider else { return }

    let isIdle = eventComponent.travelGuide.targetDestinations.first?.inPlace ?? true
    guard isIdle else { return }

    guard let requested = aiProvider.consumeAIIdleAnimationSuggestion() else { return }
    let animName = requested.trimmingCharacters(in: .whitespacesAndNewlines)
    guard !animName.isEmpty else { return }

    guard FlashAIIdleEmoteOptions.animationNames.contains(animName) else {
        AppLogger.shared.error("Ignored AI idle emote (not in allowed list): \(animName)")
        return
    }

    let current = eventComponent.styleGuide.targets.first
    if current?.animationName == animName, current?.moveType == .idle { return }

    eventComponent.styleGuide = StyleGuide(targets: [
        StyleTarget(
            style: "ai_idle_emote",
            baseAnimName: animName,
            isNew: true,
            moveType: .idle
        )
    ])
}


private func travelGuideFromJoystickTouching(fromJoystickAngle œÜ: Float,
                                             cameraYaw œà: Float,
                                             distance: Float = 10) -> TravelGuide
{
    let vCam = SIMD3<Float>(sin(œÜ), 0, -cos(œÜ)) * distance
    let sinœà = sin(œà), cosœà = cos(œà)
    let x = vCam.x * cosœà + vCam.z * sinœà // rotate by ‚Äìœà  (correct sign)
    let z = -vCam.x * sinœà + vCam.z * cosœà

    let target = TravelTarget(
        inPlace: false,
        location: SIMD3<Float>(x, 0, z),
        rotation: simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0)), // face forward
        areaScope: .point,
        isTransit: true,
        id: UUID().uuidString,
        isNew: true)

    return TravelGuide(targetDestinations: [target], estPathway: [])
}


private func travelGuideInPlace(entityWorldTransform: Transform) -> TravelGuide
{
    let target = TravelTarget(
        inPlace: true,
        location: entityWorldTransform.translation,
        rotation: entityWorldTransform.rotation,
        areaScope: .point,
        isTransit: false,
        id: UUID().uuidString,
        isNew: true)
    return TravelGuide(targetDestinations: [target], estPathway: [])
}


func travelGuideFromJoystick(
    dataProvider: JoystickDataProvider,
    entityWorldTransform: Transform,
    distance: Float = 10
) -> TravelGuide
{
    if dataProvider.joystickIsTouching
    {
        let œÜ = Float(dataProvider.joystickAngle.radians)
        let œà = Float(dataProvider.cameraYaw.radians)
        return travelGuideFromJoystickTouching(fromJoystickAngle: œÜ,
                                               cameraYaw: œà,
                                               distance: distance)
    }
    else
    {
        return travelGuideInPlace(entityWorldTransform: entityWorldTransform)
    }
}

==== AnimLibS/Brain/Idle/0-IdleSequence.swift ====


import CoreLib
import RealityKit
import simd


func constructIdleSequence(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    styleGuide: inout StyleGuide,
    travelGuide: inout TravelGuide,
    entityWorldTransform: Transform,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    if printBrainSystem { AppLogger.shared.anim("üß† Constructing idle sequence") }

    let currentElement = animationSequence[initIndex]


    var nextMoveType: MoveType? = .idle
    if travelGuide.targetDestinations.count > 0, travelGuide.targetDestinations[0].inPlace == false {
        nextMoveType = .walk
    } else if travelGuide.targetDestinations.count == 0 {
        AppLogger.shared.error("üß† Error: No destinations found.")
    }

    AppLogger.shared.anim("üß† Currently in Idle. Next move type is \(String(describing: nextMoveType)).")

    let isNearEndOfSequence = (animationSequence.count == 1 && currentElement.isNearEndOfSegment())

    let isNewOrientation = !validateIdleAlignment(travelGuide: travelGuide, entityWorldTransform: entityWorldTransform)


    let animStyle = styleGuide.targets[0]
    let needToTransition = animStyle.isNew || isNewOrientation || nextMoveType != .idle

    guard isNearEndOfSequence || needToTransition else {
        AppLogger.shared.anim("üß† Too early to construct idle sequence. Neither of conditions are true: isNearEndOfSequence: \(isNearEndOfSequence), animStyle.isNew: \(animStyle.isNew), isNewOrientation: \(isNewOrientation), nextMoveType: \(String(describing: nextMoveType)).")
        return .tooEarly
    }


    if needToTransition == false {
        let extensionResult = extendAnimationSequence(
            animationSequence: &animationSequence,
            isFilledOut: false,
            dataManager: dataManager
        )
        if extensionResult == .done {
            AppLogger.shared.debug("‚ößÔ∏è Extended sequence without transitions.")
            animationSequence[initIndex + 1].isReadyToPlay = true
            return .done
        }
    }


    guard let (lastIndexBeforeTransition, transitionFrame) = findTransitionStart(
        from: initIndex,
        in: &animationSequence,
        dataManager: dataManager,
        printBrainSystem: printBrainSystem
    ) else {
        AppLogger.shared.error("üß† Error: Failed to find lastIndexBeforeTransition.")
        return .failed
    }

    let startAnimationName = animationSequence[lastIndexBeforeTransition].animationName



    let transitionID: String
    let endAnimationName: String
    let endCriticalPoseIndex: Int

    if nextMoveType == .idle {
        AppLogger.shared.anim("üß† Constructing Idle To Idle sequence.")

        guard let (_transitionID, _endAnimationName, _endCriticalPoseIndex) = determineIdleToIdleTransitionAndTarget(
            lastElementBelforeTransition: animationSequence[lastIndexBeforeTransition],
            animStyle: animStyle,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("üß† Error: Failed to build idle to idle sequence.")
            return .failed
        }
        (transitionID, endAnimationName, endCriticalPoseIndex) = (_transitionID, _endAnimationName, _endCriticalPoseIndex)
    } else if nextMoveType == .walk {
        AppLogger.shared.anim("üß† Constructing Idle To Walk sequence.")

        guard let (_transitionID, _endAnimationName, _endCriticalPoseIndex) = determineIdleToWalkTransitionAndTarget(
            lastElementBelforeTransition: animationSequence[lastIndexBeforeTransition],
            animStyle: animStyle,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("üß† Error: Failed to build idle to idle sequence.")
            return .failed
        }
        (transitionID, endAnimationName, endCriticalPoseIndex) = (_transitionID, _endAnimationName, _endCriticalPoseIndex)
    } else {
        AppLogger.shared.error("üß† Error: Invalid move type \(String(describing: nextMoveType)).")
        return .failed
    }



    let buildResult = buildTransitionSequence(
        animationSequence: &animationSequence,
        lastIndexBeforeTransition: lastIndexBeforeTransition,
        transitionFrame: transitionFrame,
        transitionID: transitionID,
        startAnimationName: startAnimationName,
        endAnimationName: endAnimationName,
        endCriticalPoseIndex: endCriticalPoseIndex,
        styleGuide: &styleGuide,
        dataManager: dataManager
    )

    guard buildResult == .done else {
        AppLogger.shared.error("üß† Error: Failed to build transition sequence.")
        return .failed
    }


    assignInertialInfoForIdle(
        animationSequence: &animationSequence,
        initIndex: initIndex,
        dataManager: dataManager
    )


    for i in initIndex + 1 ..< animationSequence.count {
        animationSequence[i].isFilledOut = true
    }

    animationSequence[initIndex + 1].isReadyToPlay = true

    if !styleGuide.targets.isEmpty {
        styleGuide.targets[0].isNew = false
    }

    return .done
}


private func determineIdleToWalkTransitionAndTarget(
    lastElementBelforeTransition element: AnimationSequenceElement,
    animStyle: StyleTarget,
    dataManager: DataManager
) -> (transitionID: String, endAnimationName: String, endCriticalPoseIndex: Int)? {
    let endAnimation: String
    if let newAnimDataPoint = dataManager.getAnimDataPoint(for: animStyle.animationName),
       newAnimDataPoint.moveList.contains(.walk)
    {
        endAnimation = animStyle.animationName
    } else {
        AppLogger.shared.error("üß† Error: The move target \(animStyle.animationName) is not a Walk animation. Reverting to default walk animation")
        endAnimation = defaultWalkAnimation
    }

    guard let startCriticalPoseIndex = element.endPoseIndex else {
        AppLogger.shared.error("üß† Error: endPoseIndex is nil for \(element.animationName).")
        return nil
    }

    guard
        let (transitionID, endPoseIdx) =
        selectIdleToWalkTransitionAndEndAnimations(
            startAnimationName: element.animationName,
            startCriticalPoseIndex: startCriticalPoseIndex,
            endAnimationName: endAnimation,
            endCriticalPoseIndex: nil,
            dataManager: dataManager
        )
    else {
        AppLogger.shared.error("üß† Error: Failed to select transition and end animations for idle-to-walk sequence.")
        return nil
    }

    return (transitionID, endAnimation, endPoseIdx)
}


private func determineIdleToIdleTransitionAndTarget(
    lastElementBelforeTransition: AnimationSequenceElement,
    animStyle: StyleTarget,
    dataManager: DataManager
) -> (transitionID: String, endAnimationName: String, endCriticalPoseIndex: Int)? {
    if printBrainSystem { AppLogger.shared.anim("üß† The move target is Idle") }

    let startElement = lastElementBelforeTransition
    let startAnimationName = startElement.animationName
    guard let startAnimeDataPoint = dataManager.getAnimDataPoint(for: startAnimationName) else {
        AppLogger.shared.error("üß† Error: Animation data point not found for \(startAnimationName).")
        return nil
    }

    let endAnimationName: String

    if animStyle.isNew {
        endAnimationName = animStyle.animationName
    } else if startAnimeDataPoint.isLoop {
        endAnimationName = startAnimationName
    } else {
        endAnimationName = defaultIdleAnimation
    }

    guard let startCriticalPoseIndex = startElement.endPoseIndex else {
        AppLogger.shared.error("üß† Error: endPoseIndex is nil for \(startAnimationName).")
        return nil
    }

    guard let (transitionID, endAnimationName, endCriticalPoseIndex) = selectIdleToIdleTransitionAndEndAnimations(
        startAnimationName: startAnimationName,
        startCriticalPoseIndex: startCriticalPoseIndex,
        endAnimationDict: [endAnimationName: nil], // animation¬†‚Üí¬†criticalPoseIdx
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("üß† Error: Failed to select transition and end animations.")
        return nil
    }

    return (transitionID, endAnimationName, endCriticalPoseIndex)
}

func findTransitionStart(
    from initIndex: Int,
    in animationSequence: inout [AnimationSequenceElement],
    dataManager: DataManager,
    printBrainSystem: Bool = printBrainSystem
) -> (startIndex: Int, transitionFrame: Int)? {
    let originalCount = animationSequence.count

    for idx in initIndex ..< originalCount {
        guard let endFrame = animationSequence[idx].endPoseFrame else {
            AppLogger.shared.error("üß† Error: endPoseFrame is nil for index \(idx).")
            return nil
        }
        let footBones: Set<ExplicitBoneName> = [.leftFoot, .rightFoot]
        if footBones.contains(animationSequence[idx].endPoseName.groundBone) {
            if printBrainSystem {
                AppLogger.shared.anim("üß† Transition point found at index \(idx), frame \(endFrame)")
            }
            return (idx, endFrame)
        }
    }

    if printBrainSystem {
        AppLogger.shared.debug("üß† No both-feet-grounded in existing elements; extending idle sequence once")
    }
    let extensionResult = extendAnimationSequence(
        animationSequence: &animationSequence,
        isFilledOut: false,
        dataManager: dataManager
    )
    guard extensionResult == .done else {
        AppLogger.shared.error("üß† Error: Failed to extend the animation sequence.")
        return nil
    }

    for idx in originalCount ..< animationSequence.count {
        guard let endFrame = animationSequence[idx].endPoseFrame else {
            AppLogger.shared.error("üß† Error: endPoseFrame is nil for index \(idx).")
            return nil
        }
        if animationSequence[idx].endPoseName.bothFeet == .ground {
            if printBrainSystem {
                AppLogger.shared.anim("üß† Transition point found at index \(idx), frame \(endFrame)")
            }
            return (idx, endFrame)
        }
    }

    AppLogger.shared.error("üß† Error: No both-feet-grounded element found even after one extension.")
    return nil
}


private func buildTransitionSequence(
    animationSequence: inout [AnimationSequenceElement],
    lastIndexBeforeTransition: Int,
    transitionFrame: Int,
    transitionID: String,
    startAnimationName: String,
    endAnimationName: String,
    endCriticalPoseIndex: Int,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {

    guard
        let endAnimDP = dataManager.getAnimDataPoint(for: endAnimationName),
        endCriticalPoseIndex < endAnimDP.criticalPoses.count
    else {
        AppLogger.shared.error("üß† Error: Animation data point not found for \(endAnimationName).")
        return .failed
    }
    let frameForEndAnimation = endAnimDP.criticalPoses[endCriticalPoseIndex].frame

    guard let transitionSequenceData = dataManager.getTransitionSequence(sequenceID: transitionID) else {
        AppLogger.shared.error("üß† Error: Transition sequence not found for \(transitionID).")
        return .failed
    }

    AppLogger.shared.anim("üß† Transition sequence: \(transitionID) / \(startAnimationName) / \(endAnimationName)")
    guard let transitionSequence = buildIdleToIdleTransitionSequence(
        transitionID: transitionID,
        startAnimationName: startAnimationName,
        frameForStartAnimation: transitionFrame,
        endAnimationName: endAnimationName,
        frameForEndAnimation: frameForEndAnimation,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("üß† Error: Transition sequence not found for \(transitionID).")
        return .failed
    }

    let spliceIdx = lastIndexBeforeTransition + 1
    if spliceIdx < animationSequence.count {
        animationSequence.removeSubrange(spliceIdx ..< animationSequence.count)
    }

    if transitionSequenceData.transitionType == .idleToIdle {
        animationSequence.append(contentsOf: transitionSequence)


        guard let endAnimSeq = constructAnimationSequenceForGivenAnimation(
            animationName: endAnimationName,
            startCriticalPoseIndex: endCriticalPoseIndex,
            endCriticalPoseIndex: nil, // Search to end / full loop
            isFilledOut: false,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("üß† Error: Failed to construct animation sequence for \(endAnimationName).")
            return .failed
        }
        animationSequence.append(contentsOf: endAnimSeq)

        return .done
    }


    else if transitionSequenceData.transitionType == .idleToWalk {


        let lastNonWalkIdx = transitionSequence.lastIndex(where: {
            $0.startPoseName.moveType != .walk
        })

        let idleToWalkElements: [AnimationSequenceElement]
        let walkElements: [AnimationSequenceElement]

        if let n = lastNonWalkIdx {
            idleToWalkElements = Array(transitionSequence[...n])
            walkElements = (n + 1 < transitionSequence.count)
                ? Array(transitionSequence[(n + 1)...])
                : []
        } else {
            idleToWalkElements = []
            walkElements = transitionSequence
        }

        animationSequence.append(contentsOf: idleToWalkElements)

        guard let lastPoseName = animationSequence.last?.endPoseName else {
            AppLogger.shared.error("üß† Error: Unable to determine last endPoseName for transition sequence.")
            return .failed
        }
        guard let matchingIndices = dataManager.getIndicesOfCriticalPose(
            for: endAnimationName,
            matching: lastPoseName
        ),
            let newStartPoseIndex = matchingIndices.first
        else {
            AppLogger.shared.error(
                "üß† Error: No matching critical pose '\(lastPoseName)' found in \(endAnimationName)."
            )
            return .failed
        }

        let outcome = transitionToNewStyle(
            currentExtension: walkElements, // this is only the current sequence portion that goes into blendTree
            newAnimationName: endAnimationName,
            startPoseIndex: newStartPoseIndex,
            sequence: &animationSequence,
            styleGuide: &styleGuide,
            fullStepCount: fullStepCount,
            dataManager: dataManager
        )
        return outcome
    } else {
        AppLogger.shared.error("üß† Error: Unknown transition type \(transitionSequenceData.transitionType).")
        return .failed
    }
}

==== AnimLibS/Brain/Idle/1-eval-orientation.swift ====



import CoreLib
import RealityKit
import simd

let idlePositionAccuracy: Float = 0.15 // metres
let idleOrientationAccuracyDeg: Float = 6      // degrees (‚âà¬†0.105‚ÄØrad)

func validateIdleAlignment(
    travelGuide: TravelGuide,
    entityWorldTransform: Transform,
    positionAccuracy: Float = idlePositionAccuracy,
    orientationAccuracyDeg: Float = idleOrientationAccuracyDeg      // degrees (‚âà¬†0.105‚ÄØrad)
) -> Bool {

    guard
        let target = travelGuide.targetDestinations.first,      // pathway is ordered
        target.inPlace,
        let targetLoc = target.location
    else {
        return true
    }

    let posDelta = simd_length(entityWorldTransform.translation - targetLoc)
    let posOK    = posDelta <= positionAccuracy

    var rotOK = true
    if let targetRot = target.rotation {

        func forwardXZ(_ q: simd_quatf) -> SIMD2<Float> {
            let fwd3 = q.act(SIMD3<Float>(0, 0, 1))          // world‚Äëspace ‚Äúforward‚Äù
            let v     = SIMD2<Float>(fwd3.x, fwd3.z)
            let len   = simd_length(v)
            return len > 0.0001 ? v / len : SIMD2<Float>(0, 0)
        }

        let f1 = forwardXZ(entityWorldTransform.rotation)
        let f2 = forwardXZ(targetRot)

        // Clamp dot to guard against small numerical errors.
        let dot = max(-1.0, min( 1.0, simd_dot(f1, f2)))
        let yawDiff = acos(dot)                       // radians

        rotOK = yawDiff <= orientationAccuracyDeg * .pi / 180
    }

    return posOK && rotOK
}

==== AnimLibS/Brain/Idle/2-pick-transition.swift ====


import CoreLib
import RealityKit
import simd


func selectIdleToIdleTransitionAndEndAnimations(
    startAnimationName: String,
    startCriticalPoseIndex: Int,
    endAnimationDict: [String: Int?]?, // animation¬†‚Üí¬†criticalPoseIdx?
    dataManager: DataManager
) -> (String, String, Int)? { // (transitionID, endAnim, idx)
    let transitionType: TransitionType = .idleToIdle
    let transitionSubType: TransitionSubType = .legOff

    guard
        let startAnimDataPoint = dataManager.getAnimDataPoint(for: startAnimationName),
        startCriticalPoseIndex >= 0,
        startCriticalPoseIndex < startAnimDataPoint.criticalPoses.count
    else {
        AppLogger.shared.error("Error: selectTransitionAndEndAnimations: Invalid start animation ‚Äò\(startAnimationName)‚Äô or pose index¬†\(startCriticalPoseIndex).")
        return nil
    }

    let startCriticalPose = startAnimDataPoint.criticalPoses[startCriticalPoseIndex]
    let footOnGroundStart = startCriticalPose.poseName.sideOnGround

    guard
        let startGlobals = startCriticalPose.globalTransform,
        let leftStart = startGlobals[.leftFoot]?.location,
        let rightStart = startGlobals[.rightFoot]?.location
    else {
        AppLogger.shared.error("Error: selectTransitionAndEndAnimations: startCriticalPose has no globalTransform.")
        return nil
    }

    guard startCriticalPose.poseName.moveType == .idle else {
        AppLogger.shared.error("Error: in builing IdleToIdle transition sequence, startCriticalPose is not idle but \(startCriticalPose.poseName.moveType): \(startCriticalPose.poseName).")
        return nil
    }

    var candidatesEndAnims: [(name: String, index: Int?)] = []

    if let dict = endAnimationDict, dict.isEmpty == false {
        for (name, poseIdxOpt) in dict { // explicit list supplied
            candidatesEndAnims.append((name, poseIdxOpt))
        }
    } else {
        candidatesEndAnims.append((defaultIdleAnimation, nil))
    }

    var overallBest: (sequenceID: String, endAnim: String, endPoseIdx: Int, totalScore: Float)?

    for (endAnimationName, explicitPoseIdx) in candidatesEndAnims {
        guard let endAnimDataPoint = dataManager.getAnimDataPoint(for: endAnimationName) else {
            AppLogger.shared.error("Error: selectTransitionAndEndAnimations: No data for end animation ‚Äò\(endAnimationName)‚Äô.¬†Skipping‚Ä¶")
            continue
        }

        let resolvedEndPoses: [CriticalPose] = {
            if let idx = explicitPoseIdx,
               idx >= 0, idx < endAnimDataPoint.criticalPoses.count
            {
                return [endAnimDataPoint.criticalPoses[idx]]
            }
            if !endAnimDataPoint.isLoop, let first = endAnimDataPoint.criticalPoses.first {
                return [first]
            }
            var poses = endAnimDataPoint.criticalPoses.filter { $0.poseName.bothFeet == .ground }
            if poses.isEmpty {
                poses = endAnimDataPoint.criticalPoses.filter { $0.poseName.bothLegs == .ground }
            }
            if poses.isEmpty {
                poses = endAnimDataPoint.criticalPoses.filter { $0.poseName.poseType != .high }
            }
            if poses.isEmpty, let first = endAnimDataPoint.criticalPoses.first {
                poses = [first]
            }
            return poses
        }()

        if resolvedEndPoses.isEmpty {
            AppLogger.shared.error("Error: selectTransitionAndEndAnimations: No landing poses in ‚Äò\(endAnimationName)‚Äô.¬†Skipping‚Ä¶")
            continue
        }

        let transitionSequenceCandidates = dataManager.transitionSequences(
            transitionType: [transitionType],
            transitionSubType: [transitionSubType],
            footOnGroundStart: footOnGroundStart,
            footOnGroundEnd: resolvedEndPoses.first!.poseName.sideOnGround
        )

        if transitionSequenceCandidates.isEmpty { continue }

        let (sortedTransitions, startScores) = orderedTransitions(
            transitionCandidates: transitionSequenceCandidates,
            targetLeftFoot: leftStart,
            targetRightFoot: rightStart,
            startOrEnd: .start
        )

        AppLogger.shared.debug("‚ößÔ∏è Transition candidates sequence IDs and scores: \(sortedTransitions.map { $0.sequenceID }) \(startScores)")

        guard let (bestSeq, bestPose, total) = bestTransitionForEndPoses(
            candidates: sortedTransitions,
            startScores: startScores,
            endPoses: resolvedEndPoses
        ) else {
            continue // no viable pairing for this clip
        }

        guard let bestPoseIdx = dataManager.getIndexOfCriticalPose(for: endAnimationName, at: bestPose.frame) else {
            continue
        }

        if let current = overallBest {
            if total < current.totalScore {
                overallBest = (bestSeq.sequenceID, endAnimationName, bestPoseIdx, total)
            }
        } else {
            overallBest = (bestSeq.sequenceID, endAnimationName, bestPoseIdx, total)
        }
    }

    if let best = overallBest {
        return (best.sequenceID, best.endAnim, best.endPoseIdx)
    }

    AppLogger.shared.error("Error: selectTransitionAndEndAnimations: No usable transition found across \(candidatesEndAnims) end‚Äëclips.")
    return nil
}


func selectIdleToWalkTransitionAndEndAnimations(
    startAnimationName: String,
    startCriticalPoseIndex: Int,
    endAnimationName: String,
    endCriticalPoseIndex: Int?,
    dataManager: DataManager
) -> (String, Int)? {                                 // (transitionID, endPoseIdx)
    let transitionType: TransitionType = .idleToWalk

    guard
        let startAnim = dataManager.getAnimDataPoint(for: startAnimationName),
        startCriticalPoseIndex >= 0,
        startCriticalPoseIndex < startAnim.criticalPoses.count
    else {
        AppLogger.shared.error("Error: select IdleToWalk: bad start ‚Äò\(startAnimationName)‚Äô / index \(startCriticalPoseIndex)")
        return nil
    }

    let startPose         = startAnim.criticalPoses[startCriticalPoseIndex]
    let footOnGroundStart = startPose.poseName.sideOnGround

    guard
        let g          = startPose.globalTransform,
        let leftStartLocation  = g[.leftFoot]?.location,
        let rightStartLocation = g[.rightFoot]?.location
    else {
        AppLogger.shared.error("Error: select IdleToWalk: start pose lacks globals")
        return nil
    }

    guard startPose.poseName.moveType == .idle else {
        AppLogger.shared.error("Error: select IdleToWalk: start pose is not idle")
        return nil
    }

    guard let endAnim = dataManager.getAnimDataPoint(for: endAnimationName) else {
        AppLogger.shared.error("Error: select IdleToWalk: no data for end anim ‚Äò\(endAnimationName)‚Äô")
        return nil
    }

    let candidates = dataManager.transitionSequences(
        transitionType: [transitionType],
        footOnGroundStart: footOnGroundStart,
        footOnGroundEnd: nil
    )

    guard !candidates.isEmpty else {
        AppLogger.shared.error("Error: select IdleToWalk: no \(transitionType) sequences found")
        return nil
    }

    let (sorted, _) = orderedTransitions(
        transitionCandidates: candidates,
        targetLeftFoot:  leftStartLocation,
        targetRightFoot: rightStartLocation,
        startOrEnd:      .start
    )

    if let explicit = endCriticalPoseIndex,
       explicit >= 0, explicit < endAnim.criticalPoses.count,
       let best = sorted.first {
        return (best.sequenceID, explicit)
    }

    for transition in sorted {
        guard let exitName = transition.transitionPoses.last?.criticalPoseName else { continue }

        if let indices = dataManager.getIndicesOfCriticalPose(for: endAnimationName,
                                                              matching: exitName),
           let landing = indices.min() {                      // choose earliest
            return (transition.sequenceID, landing)
        }
    }

    if let best = sorted.first, !endAnim.criticalPoses.isEmpty {
        return (best.sequenceID, 0)
    }

    AppLogger.shared.error("Error: select IdleToWalk: no usable transition for \(endAnimationName)")
    return nil
}


private func bestTransitionForEndPoses(
    candidates: [TransitionSequence],
    startScores: [Float],
    endPoses: [CriticalPose]
) -> (TransitionSequence, CriticalPose, Float)? { // (seq, pose, totalScore)
    precondition(candidates.count == startScores.count, "Candidates & scores mis‚Äëaligned")

    var fallbackBest: (seq: TransitionSequence, pose: CriticalPose, total: Float)?

    for (idx, transition) in candidates.enumerated() {
        let startScore = startScores[idx]

        var bestEndScore: Float = .greatestFiniteMagnitude
        var bestPose: CriticalPose?

        for pose in endPoses {
            guard
                let g = pose.globalTransform,
                let l = g[.leftFoot]?.location,
                let r = g[.rightFoot]?.location
            else { continue }

            let targetVec = normalizedFootVector(leftFoot: l, rightFoot: r)
            let transVec = normalizedFootVector(
                leftFoot: transition.feetGlobalTransformEnd.leftFootTransform.translation,
                rightFoot: transition.feetGlobalTransformEnd.rightFootTransform.translation
            )
            let endScore = pow(distance(transVec, targetVec), 2)
            if endScore < bestEndScore {
                bestEndScore = endScore
                bestPose = pose
            }
        }

        guard let poseChosen = bestPose else { continue }

        if bestEndScore < startScore {
            return (transition, poseChosen, startScore + bestEndScore)
        }

        let total = startScore + bestEndScore
        if let cur = fallbackBest {
            if total < cur.total {
                fallbackBest = (transition, poseChosen, total)
            }
        } else {
            fallbackBest = (transition, poseChosen, total)
        }
    }

    if let best = fallbackBest {
        return (best.seq, best.pose, best.total)
    }
    return nil
}


private func orderedTransitions(
    transitionCandidates: [TransitionSequence],
    targetLeftFoot: SIMD3<Float>,
    targetRightFoot: SIMD3<Float>,
    startOrEnd: StartEndType
) -> (candidates: [TransitionSequence], scores: [Float]) {
    let targetVec = normalizedFootVector(leftFoot: targetLeftFoot, rightFoot: targetRightFoot)

    var scored: [(TransitionSequence, Float)] = []
    scored.reserveCapacity(transitionCandidates.count)

    for t in transitionCandidates {
        let feet = (startOrEnd == .start) ? t.feetGlobalTransformStart : t.feetGlobalTransformEnd
        let vec = normalizedFootVector(leftFoot: feet.leftFootTransform.translation,
                                       rightFoot: feet.rightFootTransform.translation)
        let s = pow(distance(vec, targetVec), 2)
        scored.append((t, s))
    }

    scored.sort { $0.1 < $1.1 }
    return (scored.map { $0.0 }, scored.map { $0.1 })
}

private func normalizedFootVector(leftFoot: SIMD3<Float>, rightFoot: SIMD3<Float>) -> SIMD3<Float> {
    rightFoot - leftFoot
}

==== AnimLibS/Brain/Idle/3-build-transition.swift ====


import CoreLib
import Foundation
import RealityKit

func buildIdleToIdleTransitionSequence(
    transitionID: String,
    startAnimationName: String,
    frameForStartAnimation: Int,
    endAnimationName: String,
    frameForEndAnimation: Int,
    dataManager: DataManager
) -> [AnimationSequenceElement]? {
    if printBrainSystem {
        AppLogger.shared.debug("üß† Building transition sequence out of Idle for \(transitionID).")
    }
    guard let transitionSequence = dataManager.getTransitionSequence(sequenceID: transitionID) else {
        AppLogger.shared.error("üß† Error: Transition sequence not found for \(transitionID).")
        return nil
    }
    let transitionAnimName = transitionSequence.animationName
    
    if printBrainSystem {
        AppLogger.shared.debug("üß† Transition type is \(transitionSequence.transitionType) and subtype is \(transitionSequence.transitionSubType).")
    }

    guard let transitionAnimationDataPoint = dataManager.getAnimDataPoint(for: transitionAnimName) else {
        AppLogger.shared.error("üß† Error: Animation data point not found for \(transitionAnimName).")
        return nil
    }


    guard
        let firstPose = transitionSequence.transitionPoses.first,
        let lastPose = transitionSequence.transitionPoses.last,
        let firstTransitionPose = transitionSequence.transitionPoses.first(where: { $0.transitionPoseType == .firstTransitionPose }),
        let lastTransitionPose = transitionSequence.transitionPoses.first(where: { $0.transitionPoseType == .lastTransitionPose })
    else {
        AppLogger.shared.error("üß† Error: Transition poses (.firstTransitionPose / .lastTransitionPose) missing in \(transitionID).")
        return nil
    }


    guard
        let availableBefore = dataManager.addFrames(
            animationName: transitionAnimName,
            frameA: firstPose.frame,
            frameB: firstTransitionPose.frame
        ),
        let availableAfter = dataManager.addFrames(
            animationName: transitionAnimName,
            frameA: lastTransitionPose.frame,
            frameB: lastPose.frame
        )
    else {
        AppLogger.shared.error("üß† Error computing clip‚Äëin/out frames for \(transitionAnimName).")
        return nil
    }

    let framesBefore = min(60, availableBefore)
    let framesAfter = min(60, availableAfter)

    guard
        let firstSequenceFrame = addFramesLooping(
            animationName: transitionAnimName,
            currentFrame: firstTransitionPose.frame,
            frameCountToAdd: -framesBefore,
            dataManager: dataManager
        ),
        let lastSequenceFrame = addFramesLooping(
            animationName: transitionAnimName,
            currentFrame: lastTransitionPose.frame,
            frameCountToAdd: framesAfter,
            dataManager: dataManager
        )
    else {
        AppLogger.shared.error("üß† Internal error computing clip‚Äëin/out frames for \(transitionAnimName)")
        return nil
    }
    
    AppLogger.shared.debug("‚ößÔ∏è Clip-in/out frames for \(transitionAnimName): \(firstSequenceFrame) / \(lastSequenceFrame), and \(framesBefore) / \(framesAfter) frames available and first transition pose frame is \(firstTransitionPose.frame) and last transition pose frame is \(lastTransitionPose.frame).")
    

    guard
        let firstCriticalPoseIndex = dataManager.preceedingCriticalPose(
            animationName: transitionAnimName,
            frameIncl: firstSequenceFrame
        ),
        let lastCriticalPoseIndex = dataManager.followingCriticalPose(
            animationName: transitionAnimName,
            frameIncl: lastSequenceFrame
        )
    else {
        AppLogger.shared.error("üß† Error deriving critical‚Äëpose indices for clip‚Äëin/out in \(transitionAnimName).")
        return nil
    }


    guard var sequence = constructAnimationSequenceForGivenAnimation(
        animationName: transitionAnimName,
        startCriticalPoseIndex: firstCriticalPoseIndex,
        endCriticalPoseIndex: lastCriticalPoseIndex,
        isFilledOut: false,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("üß† Error constructing animation sequence for \(transitionAnimName).")
        return nil
    }

    let firstIndex = 0
    let lastIndex = max(0, sequence.count - 1)

    sequence[firstIndex].lateStartFrame = firstSequenceFrame
    sequence[lastIndex].earlyStopFrame = lastSequenceFrame


    var adjustedTransitionPoses = transitionSequence.transitionPoses

    if let precedingIdx = dataManager.preceedingCriticalPose(
        animationName: transitionAnimName,
        frameIncl: firstPose.frame
    ) {
        let newFrame = transitionAnimationDataPoint.criticalPoses[precedingIdx].frame
        adjustedTransitionPoses[0].frame = newFrame
    }


    if let lastIdx = adjustedTransitionPoses
        .firstIndex(where: { $0.transitionPoseType == .lastTransitionPose }),
        let followingIdx = dataManager.followingCriticalPose(
            animationName: transitionAnimName,
            frameIncl: lastTransitionPose.frame
        )
    {
        let newFrame = transitionAnimationDataPoint.criticalPoses[followingIdx].frame
        adjustedTransitionPoses[lastIdx].frame = newFrame // ‚Üê only the genuine last‚Äëtransition pose
    }

    let startReferenceDict = AnimFrameDict(animationName: startAnimationName, frame: frameForStartAnimation)
    let endReferenceDict = AnimFrameDict(animationName: endAnimationName, frame: frameForEndAnimation)


    for i in 0 ..< sequence.count {
        var elem = sequence[i]

        guard let startMeta = adjustedTransitionPoses.first(where: { $0.frame == elem.startPoseFrame }),
              let endMeta = adjustedTransitionPoses.first(where: { $0.frame == elem.endPoseFrame })
        else {
            continue
        }

        let startAlter = PoseMatchTransformAlteration(
            startReferenceAnimFrameDict: startReferenceDict,
            endReferenceAnimFrameDict: endReferenceDict,
            poseAdjustment: startMeta.poseAdjustment,
            baseSide: startMeta.poseAdjustmentSide,
            referenceTransformType: startMeta.referenceTransformType,
            sideFootRotationType: startMeta.sideFootRotationType,
            otherSideFootRotationType: startMeta.otherSideFootRotationType
        )

        let endAlter = PoseMatchTransformAlteration(
            startReferenceAnimFrameDict: startReferenceDict,
            endReferenceAnimFrameDict: endReferenceDict,
            poseAdjustment: endMeta.poseAdjustment,
            baseSide: endMeta.poseAdjustmentSide,
            referenceTransformType: endMeta.referenceTransformType,
            sideFootRotationType: endMeta.sideFootRotationType,
            otherSideFootRotationType: endMeta.otherSideFootRotationType
        )

        elem.animAlteration = AnimAlteration(
            walkCircleAlteration: nil,
            strideLength: nil,
            matchTransformAlteration: MatchTransformAlteration(
                startPoseMatch: startAlter,
                endPoseMatch: endAlter
            )
        )
        sequence[i] = elem
    }

    return sequence
}

==== AnimLibS/Brain/Idle/4-inertial-units.swift ====


import CoreLib
import RealityKit

func assignInertialInfoForIdle(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    dataManager: DataManager
) {
    
    assignInertialInfoForIdleToIdle(
        animationSequence: &animationSequence,
        initIndex: initIndex,
        dataManager: dataManager
    )

}


func assignInertialInfoForIdleToIdle(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    dataManager: DataManager
) {
    guard animationSequence.indices.contains(initIndex + 1) else {
        AppLogger.shared.error("Error: Not enough elements in animation sequence for Idle inertial assignment.")
        return
    }

    for i in (initIndex + 1) ..< animationSequence.count {
        var current = animationSequence[i]
        let prevIdx = i - 1
        guard prevIdx >= 0 else { continue }
        let previous = animationSequence[prevIdx]

        guard current.startPoseName.moveType == .idle else { continue }

        var needsInertial = false

        if previous.animationName != current.animationName {
            needsInertial = true
            AppLogger.shared.debug("‚ößÔ∏è Adding inertial unit for different animation: \(previous.animationName) -> \(current.animationName)")
        } else {

            let startIdx = current.startPoseIndex

            if let predIdx = dataManager.getIndexWithOffset(
                animationName: current.animationName,
                currentIndex: startIdx,
                offset: -1
            ),
                let animDataPoint = dataManager.getAnimDataPoint(for: current.animationName)
            {
                let startFrame = current.effectiveStartFrame()

                let precedingFrame: Int = {
                    if let late = current.lateStartFrame {
                        return late == animDataPoint.criticalPoses.first!.frame
                            ? animDataPoint.criticalPoses.last!.frame // wrap
                            : late - 1
                    } else {
                        return animDataPoint.criticalPoses[predIdx].frame
                    }
                }()
                let prevEndFrame = previous.effectiveEndFrame()

                let isContiguous = (prevEndFrame == startFrame) ||
                    (prevEndFrame == precedingFrame)

                if !isContiguous {
                    needsInertial = true

                    AppLogger.shared.debug(
                        "‚ößÔ∏è Adding inertial unit for different pose: " +
                            "\(previous.endPoseFrame ?? -1) -> start\(startFrame) / pred \(precedingFrame)"
                    )
                }
            } else {
                AppLogger.shared.error("Error: Failed to resolve startIdx for idle inertial assignment.")
                needsInertial = true
            }
        }

        guard needsInertial else { continue }
        guard let frameCount = calculateAnimationElementFrameCount(
            element: current,
            dataManager: dataManager
        ) else {
            AppLogger.shared.error("Failed to fetch frameCount for idle inertial assignment.")
            continue
        }

        let unit = InertialUnit(
            boneIndices: nil, // all bones
            blendFrames: frameCount,
            isReverse: false // forward inertial blending
        )
        if current.inertialUnits == nil { current.inertialUnits = [] }
        current.inertialUnits!.append(unit)
        animationSequence[i] = current // write back
    }
}

private func assignIdleToWalkInertialInfo(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    dataManager: DataManager
) {
    guard animationSequence.indices.contains(initIndex + 1) else {
        AppLogger.shared.error("Error: [3] No next element found in the animation sequence.")
        return
    }

    for i in (initIndex + 1) ..< animationSequence.count {
        let current = animationSequence[i]
        let prevIndex = i - 1
        if prevIndex >= 0 {
            let previous = animationSequence[prevIndex]
            if current.startPoseName.moveType == .walk &&
                previous.animationName != current.animationName,
               current.blendTree == nil
            {
                guard let frameCount = calculateAnimationElementFrameCount(
                    element: current,
                    dataManager: dataManager
                ) else {
                    AppLogger.shared.error("Failed to fetch frameCount for transitional OUT.")
                    continue
                }
                let unit = InertialUnit(
                    boneIndices: nil, // inertialize all bones
                    blendFrames: frameCount,
                    isReverse: false // forward (regular) inertialization
                )
                var updated = current
                if updated.inertialUnits == nil { updated.inertialUnits = [] }
                updated.inertialUnits!.append(unit)
                animationSequence[i] = updated
            }
        }
    }
}

==== AnimLibS/Brain/Walk/0-WalkSequence.swift ====


import CoreLib
import RealityKit
import simd

func constructWalkSequence(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    styleGuide: inout StyleGuide,
    travelGuide: inout TravelGuide,
    entityWorldTransform: Transform,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    if printBrainSystem { AppLogger.shared.anim("üß† Constructing walk sequence") }
    
    let currentElement = animationSequence[initIndex]
    let isAlmostStepFirstPose = currentElement.endPoseName.isStepFirstPose
    
    
    let recalculatePath = validateExistingPath(
        animationSequence: animationSequence,
        travelGuide: travelGuide,
        startingLocation: .zero,
        entityWorldOrientation: entityWorldTransform.rotation,
        accuracy: travelGuide.veerOffPathDeltaThreshold
    )
    
    AppLogger.shared.debug("DEBUG: recalculatePath: \(recalculatePath), isStepFirstPose: \(isAlmostStepFirstPose), Style: \(styleGuide.targets[0].animationName) [new: \(styleGuide.targets[0].isNew)]")
    
    let keepExistingElements = (recalculatePath == false && styleGuide.targets[0].isNew == false)
    
    let lastIndex = animationSequence.count - 1
    if animationSequence[lastIndex].endPoseName.moveType == .walk {
        extendInitWalkSequence(
            currentAnimationSequence: &animationSequence,
            initAnimationSequenceIndex: initIndex,
            keepExistingElements: keepExistingElements,
            styleGuide: &styleGuide,
            dataManager: dataManager
        )
    }
    
    
    if let isSuccess = attemptTransitionToIdle(
        animationSequence: &animationSequence,
        initIndex: initIndex,
        travelGuide: travelGuide,
        entityWorldTransform: entityWorldTransform,
        threshold: reachedIdleLocationThreshold,
        dataManager: dataManager
    ) {
        return isSuccess
    }
    
    
    guard initIndex + 1 < animationSequence.count else {
        AppLogger.shared.error("üß† Error: [1] No next element found in the animation sequence.")
        return .failed
    }
    
    guard recalculatePath || isAlmostStepFirstPose else {
        if printBrainSystem {
            AppLogger.shared.anim("No need to adjust the walk sequence - we are mid-step and on the same pathway as before.")
        }
        return .tooEarly
    }
    
    

    
    guard var endLocation = getEndLocation(
        animationSequence: animationSequence,
        startElementIndex: initIndex + 1,
        travelGuide: travelGuide,
        characterOrientation: entityWorldTransform.rotation,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Correction quaternion not found.")
        return .failed
    }
    
    var deltaOrientationQuat = travelGuide.calculatePathCorrectionQuaternion(endLocation: endLocation)
    
    
    if var transitionalAnimationNames = determineWalkTransitionalAnimationCandidates(deltaOrientationQuat: deltaOrientationQuat) {
        if printBrainSystem {
            AppLogger.shared.anim("Rebuilding the init Sequence with a transitional animation.")
        }
        buildWalkTransitionalSequence(
            currentAnimationSequence: &animationSequence,
            initAnimationSequenceIndex: initIndex,
            transitionalAnimationNames: &transitionalAnimationNames,
            dataManager: dataManager
        )

        if let endLocationCalc = getEndLocation(
            animationSequence: animationSequence,
            startElementIndex: initIndex + 1,
            travelGuide: travelGuide,
            characterOrientation: entityWorldTransform.rotation,
            dataManager: dataManager
        ) { endLocation = endLocationCalc } else {
            AppLogger.shared.error("Error: Correction quaternion not found for transitional sequence.")
            return .failed
        }

        deltaOrientationQuat = travelGuide.calculatePathCorrectionQuaternion(endLocation: endLocation)
    }
    
    
    let (pathDistanceBeforeCorrection, _) = travelGuide.distanceToPathway(from: endLocation)
    
    var effectiveOrientationChange: simd_quatf?
    if pathDistanceBeforeCorrection > travelGuide.veerOffPathDeltaThreshold {
        if printBrainSystem {
            AppLogger.shared.anim("DEBUG: Pathway deviation is too large. Suggesting CIR adjustment.")
        }
        effectiveOrientationChange = calculateCirAdjustment(
            animationSequence: &animationSequence,
            startElementIndex: initIndex + 1,
            deltaOrientationQuat: deltaOrientationQuat,
            dataManager: dataManager
        )
    }
    

    let pathDistanceAfterCorrection: Float
    if let effectiveOrientationChange = effectiveOrientationChange {
        pathDistanceAfterCorrection = travelGuide.distanceAfterPathCorrection(location: endLocation, using: effectiveOrientationChange)
    } else {
        pathDistanceAfterCorrection = pathDistanceBeforeCorrection
    }

    if pathDistanceAfterCorrection > travelGuide.veerOffPathDeltaThreshold {
        if printBrainSystem {
            AppLogger.shared.anim("DEBUG: Pathway deviation is too large after correction. Suggesting stride adjustment.")
        }

        adjustStrideLength(
            animationSequence: &animationSequence,
            startElementIndex: initIndex + 1,
            pathDistanceAfterCorrection: pathDistanceAfterCorrection,
            travelGuide: travelGuide,
            dataManager: dataManager
        )
    }

    assignInertialInfoForWalk(
        animationSequence: &animationSequence,
        initIndex: initIndex,
        dataManager: dataManager
    )
    
    for i in initIndex + 1 ..< animationSequence.count {
        animationSequence[i].isFilledOut = true
    }
    
    animationSequence[initIndex + 1].isReadyToPlay = true
    
    if !styleGuide.targets.isEmpty {
        styleGuide.targets[0].isNew = false
    }

    return .done
}


func getEndLocation(
    animationSequence: [AnimationSequenceElement],
    startElementIndex: Int,
    travelGuide: TravelGuide,
    characterOrientation: simd_quatf = simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0)),
    dataManager: DataManager
) -> SIMD3<Float>? {
    var localDisplacement = SIMD3<Float>(repeating: 0)

    for idx in startElementIndex ..< animationSequence.count {
        guard let animDataPoint = dataManager.getAnimDataPoint(
            for: animationSequence[idx].animationName)
        else {
            AppLogger.shared.error(
                "Error: AnimDataPoint not found for \(animationSequence[idx].animationName).")
            return nil
        }

        let deltaLoc = animDataPoint
            .criticalPoses[animationSequence[idx].startPoseIndex]
            .deltaLocation

        localDisplacement += deltaLoc
    }

    let worldDisplacement = characterOrientation.act(localDisplacement)

    return worldDisplacement
}


extension AnimationSequenceElement {
    func remainingPlayableFrames() -> Int? {
        guard let current = currentFrame else { return nil }
        guard let effectiveEnd = earlyStopFrame ?? endPoseFrame else { return nil }
        return effectiveEnd - current // can be¬†‚â§¬†0 once we run out
    }
    
    func isNearEndOfSegment(systemMultiplier: Float = systemWideSpeedMultiplier) -> Bool {
        guard let left = remainingPlayableFrames() else { return false }
        return Float(left) <= max(3 * systemMultiplier, 2)
    }
}

==== AnimLibS/Brain/Walk/1-PathwayEval.swift ====


import CoreLib
import RealityKit
import simd

func validateExistingPath(
    animationSequence: [AnimationSequenceElement],
    travelGuide: TravelGuide,
    startingLocation: simd_float3 = .zero,
    entityWorldOrientation: simd_quatf,
    accuracy: Float = 0.2
) -> Bool {
    guard let existing = getExistingPath(
        animationSequence: animationSequence,
        startingLocation: startingLocation,
        entityWorldOrientation: entityWorldOrientation)
    else {
        AppLogger.shared.error("Error: No existing path found")
        return false
    }

    let needLen = totalArcLen(existing)
    guard let immediate = getImmediateTargetDestinations(
        travelGuide: travelGuide,
        withinDistance: needLen,
        startingLocation: startingLocation)
    else {
        AppLogger.shared.error("Error: No immediate path found")
        return false
    }

    let maxDev = frechetDistance(existing, immediate)
    let pathGood = maxDev <= accuracy

    let overshoots = detectOvershootBeyondInPlaceDestination(travelGuide)

    return pathGood && !overshoots
}

private func getImmediateTargetDestinations(
    travelGuide: TravelGuide,
    withinDistance: Float,
    startingLocation: simd_float3 = .zero
) -> [simd_float3]? {
    guard !travelGuide.targetDestinations.isEmpty else {
        AppLogger.shared.error("Error: No target destinations found")
        return nil
    }

    var path: [simd_float3] = [startingLocation]
    var travelled: Float = 0
    var prev = startingLocation

    for target in travelGuide.targetDestinations {
        guard let loc = target.location else { continue }
        let segLen = simd_length(loc - prev)
        path.append(loc)
        travelled += segLen
        prev = loc

        if target.inPlace {
            break
        }

        if travelled >= withinDistance { break }
    }
    return path
}

private func getExistingPath(
    animationSequence: [AnimationSequenceElement],
    startingLocation: simd_float3 = .zero,
    entityWorldOrientation: simd_quatf
) -> [simd_float3]? {
    var path: [simd_float3] = []
    var currentPos = startingLocation
    path.append(currentPos)

    for elem in animationSequence {
        if let delta = elem.deltaLocation {
            let worldDelta = entityWorldOrientation.act(delta)
            currentPos += worldDelta
            path.append(currentPos)
        }
    }

    if path.count <= 1 {
        AppLogger.shared.error("Error: No path found")
        return nil
    }

    return path
}

private func frechetDistance(
    _ p: [simd_float3],
    _ q: [simd_float3]
) -> Float {
    let m = p.count, n = q.count
    precondition(m > 0 && n > 0)

    var dp = Array(repeating: Array(repeating: Float.infinity, count: n), count: m)

    dp[0][0] = simd_length(p[0] - q[0])

    for j in 1..<n {
        let d = simd_length(p[0] - q[j])
        dp[0][j] = max(dp[0][j - 1], d)
    }
    for i in 1..<m {
        let d = simd_length(p[i] - q[0])
        dp[i][0] = max(dp[i - 1][0], d)
    }
    for i in 1..<m {
        for j in 1..<n {
            let d = simd_length(p[i] - q[j])
            dp[i][j] = max(
                min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]),
                d)
        }
    }
    return dp[m - 1][n - 1] // ‚Üê maximum leash length
}

@inline(__always)
private func dist2(_ a: simd_float3, _ b: simd_float3) -> Float {
    let d = a - b
    return simd_dot(d, d)
}

@inline(__always)
private func totalArcLen(_ p: [simd_float3]) -> Float {
    zip(p, p.dropFirst()).reduce(0) { $0 + simd_length($1.1 - $1.0) }
}


private func detectOvershootBeyondInPlaceDestination(_ guide: TravelGuide) -> Bool {
    guard
        let target        = guide.targetDestinations.first(where: { $0.inPlace && $0.location != nil }),
        let destLocation  = target.location
    else { return false }          // no in‚Äëplace target ‚Üí nothing to check

    var reachedDestination = false

    for waypoint in guide.estPathway {
        guard let wpLoc = waypoint.location else { continue }

        if !reachedDestination {
            if simd_length(wpLoc - destLocation) <= idlePositionAccuracy {
                reachedDestination = true
            }
            continue
        }

        if simd_length(wpLoc - destLocation) > idlePositionAccuracy {
            return true
        }
    }
    return false
}

==== AnimLibS/Brain/Walk/2-ExtendWalkSequence.swift ====


import CoreLib

let fullStepCount = 2



func extendInitWalkSequence(
    currentAnimationSequence: inout [AnimationSequenceElement],
    initAnimationSequenceIndex: Int,
    keepExistingElements: Bool = true,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    if printBrainSystem {
        AppLogger.shared.anim("üß† Extending Init Walk Sequence ‚Äì keepExistingElements = \(keepExistingElements)")
    }

    if keepExistingElements {
        if countFullSteps(after: initAnimationSequenceIndex,
                          in: currentAnimationSequence,
                          dataManager: dataManager) >= fullStepCount,
            styleGuide.targets[0].isNew == false

        {
            if printBrainSystem {
                AppLogger.shared.anim("üß† Already have \(fullStepCount) full steps after index \(initAnimationSequenceIndex) and style guide is not new.")
            }
            return
        }

        appendMissingSteps(to: &currentAnimationSequence,
                           styleGuide: &styleGuide,
                           dataManager: dataManager)
    } else {
        replaceTailThenAppend(to: &currentAnimationSequence,
                              initIdx: initAnimationSequenceIndex,
                              styleGuide: &styleGuide,
                              dataManager: dataManager)
    }
}


private func appendMissingSteps(
    to sequence: inout [AnimationSequenceElement],
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    guard let lastElement = sequence.last,
          let endPoseIndex = lastElement.endPoseIndex
    else {
        AppLogger.shared.error("Error: Sequence is empty or last element has nil endPoseIndex.")
        return
    }

    let animationName = lastElement.animationName
    guard let animDataPoint = dataManager.getAnimDataPoint(for: animationName) else {
        AppLogger.shared.error("Error: Animation data not found for \(animationName).")
        return
    }
    guard
        let styleTarget = styleGuide.targets.first,
        let newAnimDataPoint = dataManager.getAnimDataPoint(for: styleTarget.animationName)
    else {
        AppLogger.shared.error("Error: StyleGuide has no targets.")
        return
    }

    let currentIsLoopWalk = animDataPoint.isLoop && animDataPoint.moveList == [.walk]
    let switchingToNewWalkingLoopStyle = styleTarget.isNew && newAnimDataPoint.isLoop && newAnimDataPoint.moveList == [.walk]


    if currentIsLoopWalk == false, switchingToNewWalkingLoopStyle == false {
        guard endPoseIndex < animDataPoint.criticalPoses.count else {
            AppLogger.shared.error("Error: endPoseIndex \(endPoseIndex) is out of bounds for animation \(animationName).")
            return
        }
        let startCriticalPoseName = animDataPoint.criticalPoses[endPoseIndex].poseName
        guard
            let allMatches = dataManager.getIndicesOfCriticalPose(
                for: styleTarget.animationName,
                matching: startCriticalPoseName
            ),
            let startIndex = allMatches.first
        else {
            AppLogger.shared.error("Error: No matching critical pose found for \(startCriticalPoseName) in style animation \(styleTarget.animationName).")
            return
        }
        

        extendWithCurrentWalkLoop(into: &sequence,
                                  styleAnimationName: styleTarget.animationName,
                                  startPoseIndex: startIndex,
                                  styleGuide: &styleGuide,
                                  dataManager: dataManager)
        return
    }
    

    guard let currentExtension = buildWalkSequenceExtension(
        animationName: animationName,
        startPoseIndex: endPoseIndex,
        fullStepCount: fullStepCount,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Failed to build extension for \(animationName).")
        return
    }

    if !switchingToNewWalkingLoopStyle {
        appendElements(currentExtension, to: &sequence, logSuffix: "(no transition)")
        return
    }

    if printBrainSystem {
        AppLogger.shared.anim("üß† Transitioning to new style \(styleTarget.animationName)")
    }
    let endPoseName = lastElement.endPoseName
    guard
        let indices = dataManager.getIndicesOfCriticalPose(
            for: styleTarget.animationName,
            matching: endPoseName
        ),
        let startPoseIndex = indices.first
    else {
        AppLogger.shared.error("Error: No matching critical pose found for \(endPoseName) in style animation \(styleTarget.animationName).")
        return
    }

    transitionToNewStyle(
        currentExtension: currentExtension, // put in only the blend-in portion
        newAnimationName: styleTarget.animationName,
        startPoseIndex: startPoseIndex,
        sequence: &sequence,
        styleGuide: &styleGuide,
        fullStepCount: fullStepCount, // for looping animation. uses max available array of walk critical poses for non-looping walks
        dataManager: dataManager
    )
}


private func replaceTailThenAppend(
    to sequence: inout [AnimationSequenceElement],
    initIdx: Int,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    var trimStart = initIdx + 1
    let initElement = sequence[initIdx]

    if !initElement.endPoseName.isStepFirstPose,
       let stepID = getStepID(for: initElement, dataManager: dataManager)
    {
        while trimStart < sequence.count,
              getStepID(for: sequence[trimStart], dataManager: dataManager) == stepID
        {
            trimStart += 1
        }
    }

    if let initAnimData = dataManager.getAnimDataPoint(for: initElement.animationName),
       !(initAnimData.isLoop && initAnimData.moveList == [.walk])
    {
        while trimStart < sequence.count {
            if let ad = dataManager.getAnimDataPoint(for: sequence[trimStart].animationName),
               !(ad.isLoop && ad.moveList == [.walk])
            {
                trimStart += 1
            } else {
                break
            }
        }
    }

    if trimStart < sequence.count {
        sequence.removeSubrange(trimStart...)
    }

    appendMissingSteps(to: &sequence,
                       styleGuide: &styleGuide,
                       dataManager: dataManager)
}


private func extendWithCurrentWalkLoop(
    into sequence: inout [AnimationSequenceElement],
    styleAnimationName: String,
    startPoseIndex: Int,
    styleGuide: inout StyleGuide,
    dataManager: DataManager
) {
    guard let styleAnimData = dataManager.getAnimDataPoint(for: styleAnimationName),
          styleAnimData.isLoop, styleAnimData.moveList == [.walk]
    else {
        AppLogger.shared.error("Error: Style animation \(styleAnimationName) is not a looping walk.")
        return
    }
    guard let ext = buildWalkSequenceExtension(
        animationName: styleAnimationName,
        startPoseIndex: startPoseIndex,
        fullStepCount: fullStepCount,
        dataManager: dataManager
    )
    else {
        AppLogger.shared.error("Error: Could not build extension for style animation \(styleAnimationName).")
        return
    }
    appendElements(ext, to: &sequence, logSuffix: "(transition)")
    styleGuide.targets[0].isNew = false
}

func transitionToNewStyle(
    currentExtension: [AnimationSequenceElement], // this is only the current sequence portion that goes into blendTree
    newAnimationName styleAnimationName: String,
    startPoseIndex: Int,
    sequence: inout [AnimationSequenceElement],
    styleGuide: inout StyleGuide,
    fullStepCount: Int,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    guard let targetExtension = buildWalkSequenceExtension(
        animationName: styleAnimationName,
        startPoseIndex: startPoseIndex,
        fullStepCount: fullStepCount, // uses it for looping animation
        dataManager: dataManager
    )
    else {
        AppLogger.shared.error("Error: Failed to build extension for new style \(styleAnimationName).")
        return .failed
    }
    guard let blended = attachBlendInSequence(
        origExtension: currentExtension,
        targetExtension: targetExtension,
        dataManager: dataManager
    )
    else {
        AppLogger.shared.error("Error: Failed to create blend for transition to \(styleAnimationName).")
        return .failed
    }
    appendElements(blended, to: &sequence, logSuffix: "(blend to \(styleAnimationName))")
    styleGuide.targets[0].isNew = false
    
      return  .done
}


private func appendElements(_ elements: [AnimationSequenceElement],
                            to sequence: inout [AnimationSequenceElement],
                            logSuffix: String)
{
    guard !elements.isEmpty else { return }
    sequence.append(contentsOf: elements)
    if printBrainSystem {
        AppLogger.shared.anim("Appended \(elements.count) elements \(logSuffix)")
    }
}

private func countFullSteps(after idx: Int,
                            in sequence: [AnimationSequenceElement],
                            dataManager: DataManager) -> Int
{
    guard idx < sequence.count else { return 0 }
    var prevID: Int? = nil, steps = 0
    for i in (idx + 1) ..< sequence.count {
        guard let id = getStepID(for: sequence[i], dataManager: dataManager) else { continue }
        if prevID == nil { prevID = id }
        if id != prevID { steps += 1; prevID = id }
        if steps >= fullStepCount { break }
    }
    return steps
}

private func getStepID(for elem: AnimationSequenceElement,
                       dataManager: DataManager) -> Int?
{
    guard let ad = dataManager.getAnimDataPoint(for: elem.animationName) else { return nil }
    return ad.criticalPoses[elem.startPoseIndex].stepID
}


private func buildWalkSequenceExtension(
    animationName: String,
    startPoseIndex: Int,
    fullStepCount: Int,
    dataManager: DataManager
) -> [AnimationSequenceElement]? {
    var combinedExtendedSequence: [AnimationSequenceElement] = []

    var index = startPoseIndex

    guard
        let animDataPoint = dataManager.getAnimDataPoint(for: animationName)
    else {
        AppLogger.shared.error("Error: [4] Animation data point not found for \(animationName).")
        return nil
    }

    if startPoseIndex == animDataPoint.criticalPoses.count - 1 {
        if animDataPoint.isLoop {
            index = 0
        } else {
            AppLogger.shared.error("Error: startPoseIndex is the last element and animation is not looping.")
            return nil
        }
    }

    var allIndices: [Int] = []

    if animDataPoint.isLoop, animDataPoint.moveList == [.walk] {
        if let _allIndices = dataManager.getIndicesForNextFullSteps(
            animationName: animationName,
            currentIndexIncl: index,
            fullStepCount: fullStepCount
        ),
            _allIndices.count > 1
        {
            allIndices = _allIndices
        } else {
            AppLogger.shared.error("Error: Could not find indices for next full steps for \(animationName).")
            return nil
        }
        let lastPoseIndex = allIndices.last! + 1
        guard
            lastPoseIndex < animDataPoint.criticalPoses.count
        else {
            AppLogger.shared.error("Error: Invalid last pose index for \(animationName).")
            return nil
        }

        allIndices.append(lastPoseIndex)

    } else if animDataPoint.criticalPoses[index].poseName.moveType == .walk {
        var i = index
        while i < animDataPoint.criticalPoses.count,
              animDataPoint.criticalPoses[i].poseName.moveType == .walk
        {
            allIndices.append(i)
            i += 1
        }

        if allIndices.count < 2 {
            AppLogger.shared.error("Error: Not enough walk poses found in non‚Äëlooping \(animationName).")
            return nil
        }
    } else {
        AppLogger.shared.error("Error: Animation \(animationName) does not have walk in it.")
        return nil
    }

    guard let extendedSequence = constructAnimationSequenceForGivenAnimation(
        animationName: animationName,
        startCriticalPoseIndex: allIndices.first!,
        endCriticalPoseIndex: allIndices.last!,
        isFilledOut: false,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Could not construct extended animation sequence for \(animationName).")
        return nil
    }

    combinedExtendedSequence.append(contentsOf: extendedSequence)

    return combinedExtendedSequence
}

private func attachBlendInSequence(
    origExtension: [AnimationSequenceElement],
    targetExtension: [AnimationSequenceElement],
    dataManager: DataManager
) -> [AnimationSequenceElement]? {
    if printBrainSystem {
        AppLogger.shared.anim("üß† Attaching blend in sequence")
    }
    var targetExtension = targetExtension
    var origExtension = origExtension

    if targetExtension.count > origExtension.count {
        targetExtension = Array(targetExtension.prefix(origExtension.count))
    }

    if origExtension.count > targetExtension.count {
        origExtension = Array(origExtension.prefix(targetExtension.count))
    }

    guard origExtension.count == targetExtension.count else {
        AppLogger.shared.error("Error: Mismatch in element count between original and target extension sequences.")
        return nil
    }

    var blendedSequence: [AnimationSequenceElement] = []
    let totalBlendSteps = origExtension.count
    let frameRate = frameRate
    var fromEffectiveDuration: Float = 0.0

    for i in 0 ..< totalBlendSteps {
        let origElement = origExtension[i]
        var targetElement = targetExtension[i] // Create a mutable copy of target element

        if origElement.startPoseName != targetElement.startPoseName ||
            origElement.endPoseName != targetElement.endPoseName
        {
            AppLogger.shared.error("Error: startPoseNames and endPoseNames do not match at index \(i). Orig: Starting with \(origElement.startPoseName) and ending with \(origElement.endPoseName). Target: Starting with \(targetElement.startPoseName) and ending with \(targetElement.endPoseName).")
            return nil
        }

        guard let origFrameCount = calculateAnimationElementFrameCount(
            element: origElement,
            dataManager: dataManager
        ),
            let targetFrameCount = calculateAnimationElementFrameCount(
                element: targetElement,
                dataManager: dataManager
            )
        else {
            AppLogger.shared.error("Error: frameCount is nil for one of the elements at index \(i).")
            return nil
        }

        let targetWeight = totalBlendSteps > 1 ? Float(i) / Float(totalBlendSteps - 1) : 0.5
        let effectiveDuration = targetWeight * Float(targetFrameCount) / frameRate +
            (1 - targetWeight) * Float(origFrameCount) / frameRate

        let adjustedOrigSpeed = effectiveDuration * frameRate / Float(origFrameCount)
        let adjustedTargetSpeed = effectiveDuration * frameRate / Float(targetFrameCount)

        var updatedOrigElement = origElement
        updatedOrigElement.speed = adjustedOrigSpeed

        targetElement.speed = adjustedTargetSpeed

        let toEffectiveDuration = fromEffectiveDuration + effectiveDuration

        let blendInfo = BlendInfo(
            jointIndices: nil, // Adjust as needed.
            ownBlendWeightType: .decreasing,
            otherBlendWeightType: .increasing,
            isAdditive: false,
            blendFunction: .crossFade,
            blendType: .sCurve,
            fromEffectiveSeriesDuration: Double(fromEffectiveDuration),
            toEffectiveSeriesDuration: Double(toEffectiveDuration),
            totalEffectiveSeriesDuration: -1 // Will be updated later.
        )

        let blendNode = BlendNode(
            blendElement: updatedOrigElement,
            blendInfo: blendInfo
        )

        targetElement.blendTree = BlendTree(blendNodes: [blendNode])

        blendedSequence.append(targetElement)

        fromEffectiveDuration = toEffectiveDuration
    }

    let finalTotalDuration = fromEffectiveDuration
    for index in blendedSequence.indices {
        if var blendTree = blendedSequence[index].blendTree {
            for nodeIndex in blendTree.blendNodes.indices {
                blendTree.blendNodes[nodeIndex].blendInfo.totalEffectiveSeriesDuration = Double(finalTotalDuration)
            }
            blendedSequence[index].blendTree = blendTree
        }
    }

    return blendedSequence
}

==== AnimLibS/Brain/Walk/3-TranstionalSequence.swift ====


import CoreLib
import simd

func buildWalkTransitionalSequence(
    currentAnimationSequence: inout [AnimationSequenceElement],
    initAnimationSequenceIndex: Int,
    transitionalAnimationNames: inout [String],
    dataManager: DataManager
) {
    if printBrainSystem { AppLogger.shared.anim("üß† Building walk transitional sequence. Candidates: \(transitionalAnimationNames).") }
    

    let startIndex = initAnimationSequenceIndex + 1
    guard startIndex < currentAnimationSequence.count,
          let firstOccurrenceIndex = currentAnimationSequence[startIndex...]
        .firstIndex(where: { $0.startPoseName.isStepFirstPose  && $0.startPoseName.moveType == .walk})
    else {
        AppLogger.shared.error("Error: No step first pose found in the init animation sequence starting from index \(startIndex).")
        return
    }

    let transitionalStartIndex: Int
    if firstOccurrenceIndex != startIndex {
        transitionalStartIndex = firstOccurrenceIndex // new, earlier insert point
    } else {
        guard let secondOccurrence = currentAnimationSequence[currentAnimationSequence.index(after: firstOccurrenceIndex)...]
            .firstIndex(where: { $0.startPoseName.isStepFirstPose && $0.startPoseName.moveType == .walk})
        else {
            AppLogger.shared.error("Error: Only one step-first pose found in the init animation sequence starting from index \(initAnimationSequenceIndex).")
            return
        }
        transitionalStartIndex = secondOccurrence // keep legacy behaviour
    }

    let initElement = currentAnimationSequence[transitionalStartIndex]
    let startPoseName = initElement.startPoseName

    var smallestIndex = Int.max
    var chosenTransAnim: String?
    for candidate in transitionalAnimationNames {
        guard
            let indices = dataManager.getIndicesOfCriticalPose(for: candidate, matching: startPoseName),
            let index = indices.first
        else {
            transitionalAnimationNames.removeAll { $0 == candidate }
            continue // if the starting critical pose does not exist in target candidate, skip to the next candidate
        }
        if index < smallestIndex {
            smallestIndex = index
            chosenTransAnim = candidate
        }
    }

    guard
        let transitionalAnimationName = chosenTransAnim,
        smallestIndex != Int.max
    else {
        AppLogger.shared.error("Error: Could not determine a transitional animation to use.")
        return
    }

    if smallestIndex > 2 {
        AppLogger.shared.warning("WARNING: Starting transition from index \(smallestIndex) in \(transitionalAnimationName) ")
    }
    let startPoseIndex = smallestIndex

    AppLogger.shared.debug("DEBUG: Using transitional animation \(transitionalAnimationName) with startPoseIndex \(startPoseIndex) and startPoseName \(startPoseName).")

    guard let transitionalSequence = constructAnimationSequenceForGivenAnimation(
        animationName: transitionalAnimationName,
        startCriticalPoseIndex: startPoseIndex,
        endCriticalPoseIndex: nil, // if optional, search till the end or completes full loop,
        isFilledOut: false,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: Could not construct transitional animation sequence.")
        return
    }

    currentAnimationSequence.removeSubrange(transitionalStartIndex ..< currentAnimationSequence.count)
    currentAnimationSequence.append(contentsOf: transitionalSequence)
}

func determineWalkTransitionalAnimation(
    deltaOrientationQuat: simd_quatf
) -> String? {
    return nil
}

func determineWalkTransitionalAnimationCandidates(
    deltaOrientationQuat: simd_quatf
) -> [String]? {
    let angleInDegrees = deltaOrientationQuat.signedYawDeg

    if Swift.abs(angleInDegrees) <= 150.0 {
        return nil
    } else {
        return ["02001_5_MOB1_Walk_L_180", "02001_7_MOB1_Walk_R_180"] // ‚≠ïÔ∏è
    }
}

==== AnimLibS/Brain/Walk/4-StepAlterations.swift ====

import CoreLib
import simd

let maxCirDegree: Float = 40 // per step

private func computeBlendInfos(for element: AnimationSequenceElement, isFullStep: Bool = false, dataManager: DataManager) -> BlendInfo? {
    guard let frameCount = calculateAnimationElementFrameCount(
        element: element,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: No frame count found for element of \(element.animationName).")
        return nil
    }
    let elementDuration = Double(frameCount) * Double(frameRate)
    
    let ownBlendWeightType: BlendWeightType = isFullStep ? .fixedAt100 : .increasing
    let otherBlendWeightType: BlendWeightType = isFullStep ? .fixedAt0 : .decreasing
    let blendType: BlendType = isFullStep ? .linear : .fadeIn
    
    let coreBlendInfo = BlendInfo(
        jointIndices: getAllBoneIndicesFromTwistOperations(operations: CoreTwistOperations.operations, dataManager: dataManager), // this is for core cir bones, which will be blend eased in for partial step and just switched for full step. For non-core, we will take care with inertialization.
        ownBlendWeightType: ownBlendWeightType,
        otherBlendWeightType: otherBlendWeightType,
        isAdditive: true,
        blendFunction: .crossFade,
        blendType: blendType,
        fromEffectiveSeriesDuration: 0,
        toEffectiveSeriesDuration: elementDuration,
        totalEffectiveSeriesDuration: elementDuration
    )
    
    return coreBlendInfo
}


func calculateCirAdjustment(
    animationSequence: inout [AnimationSequenceElement],
    startElementIndex: Int,
    deltaOrientationQuat: simd_quatf,
    dataManager: DataManager
) -> simd_quatf {
    var fullStepCount = 0
    var hasPartialStep = false
    var previousStepID: Int?
    var index = startElementIndex
    
    while index < animationSequence.count {
        guard let animDataPoint = dataManager.getAnimDataPoint(for: animationSequence[index].animationName),
              let firstStepID = animDataPoint.criticalPoses[animationSequence[index].startPoseIndex].stepID
        else {
            index += 1
            continue
        }
    
        if !animationSequence[index].startPoseName.isStepFirstPose {
            hasPartialStep = true
        } else {
            fullStepCount += 1
        }
        previousStepID = firstStepID
        index += 1
        break
    }
    
    while index < animationSequence.count {
        guard let animDataPoint = dataManager.getAnimDataPoint(for: animationSequence[index].animationName),
              let currentStepID = animDataPoint.criticalPoses[animationSequence[index].startPoseIndex].stepID
        else {
            index += 1
            continue
        }
    
        if let prev = previousStepID, currentStepID != prev {
            fullStepCount += 1
        }
        previousStepID = currentStepID
        index += 1
    }
    
    let totalShare: Float = (hasPartialStep ? 0.25 : 0) + Float(fullStepCount)
    
    let potentialCirDeg: Float = maxCirDegree *
        (Float(fullStepCount) + (hasPartialStep ? 0.25 : 0.0))
    
    let deltaDeg = deltaOrientationQuat.signedYawDeg // still in ¬∞, keeps sign
    let fraction: Float = (deltaDeg == 0)
        ? 0
        : min(1, Swift.abs(potentialCirDeg) / Swift.abs(deltaDeg)) // compare apples to apples

    let identityQuat = simd_quatf(angle: 0, axis: simd_float3(0, 0, 1))
    let totalAdjustmentQuat = simd_slerp(identityQuat, deltaOrientationQuat, fraction)
    
    let perStepAdjustmentAngle = totalAdjustmentQuat.signedYawDeg / totalShare

    var effectiveAdjustmentAngle: Float = 0.0
    index = startElementIndex
    while index < animationSequence.count {
        guard
            let animDataPoint = dataManager.getAnimDataPoint(for: animationSequence[index].animationName),
            hasStepID(animDataPoint, poseIndex: animationSequence[index].startPoseIndex) // ELIGIBLE
        else {
            index += 1
            continue
        }
        let criticalPose = animDataPoint.criticalPoses[animationSequence[index].startPoseIndex]
        guard let currentStepID = criticalPose.stepID else {
            index += 1
            continue
        }
        
        let groupStepID = currentStepID
        let isPartialGroup = (index == startElementIndex && hasPartialStep)

        var groupApplied = false
        var groupAdjustmentAngle: Float = 0
        while index < animationSequence.count,
              let animDataPointInner = dataManager.getAnimDataPoint(for: animationSequence[index].animationName)
        {
            let innerCriticalPose = animDataPointInner.criticalPoses[animationSequence[index].startPoseIndex]
            guard let stepID = innerCriticalPose.stepID, stepID == groupStepID else { break }
            
            
            if isPartialGroup {
                if innerCriticalPose.poseName.poseType != .low {
                    if let cirBlendInfo = computeBlendInfos(
                        for: animationSequence[index],
                        isFullStep: false,
                        dataManager: dataManager
                    ) {
                        animationSequence[index].animAlteration = AnimAlteration(
                            walkCircleAlteration: WalkCircleAlteration(
                                cirWalkDegree: perStepAdjustmentAngle,
                                cirBlendInfo: cirBlendInfo
                            ),
                            strideLength: animationSequence[index].animAlteration?.strideLength
                        )
                        
                        let partialRad = (perStepAdjustmentAngle * 0.25) * (.pi / 180)
                        let partialQuat = simd_quatf(angle: partialRad, axis: deltaOrientationQuat.axis)

                        if let deltaLoc = animationSequence[index].deltaLocation {
                            animationSequence[index].deltaLocation = partialQuat.act(deltaLoc)
                        }

                        if let prevDeltaRot = animationSequence[index].deltaRotation {
                            animationSequence[index].deltaRotation = partialQuat * prevDeltaRot
                        }
                            
                    } else {
                        AppLogger.shared.error("Failed to compute blend infos for \(animationSequence[index].animationName)")
                    }
                    let q = simd_quatf(
                        angle: (perStepAdjustmentAngle * 0.25) * (.pi / 180),
                        axis: deltaOrientationQuat.axis
                    )
                    applyCirAdjustmentRecursively(
                        to: &animationSequence[index],
                        cirDeg: perStepAdjustmentAngle,
                        isFullStep: false,
                        deltaQuat: q,
                        dataManager: dataManager
                    )
                    groupApplied = true
                    groupAdjustmentAngle = perStepAdjustmentAngle * 0.25
                }
            } else {
                if let cirBlendInfo = computeBlendInfos(
                    for: animationSequence[index],
                    isFullStep: true,
                    dataManager: dataManager
                ) {
                    animationSequence[index].animAlteration = AnimAlteration(
                        walkCircleAlteration: WalkCircleAlteration(
                            cirWalkDegree: perStepAdjustmentAngle,
                            cirBlendInfo: cirBlendInfo
                        ),
                        strideLength: animationSequence[index].animAlteration?.strideLength
                    )
                    
                    let stepRad = perStepAdjustmentAngle * (.pi / 180)
                    let stepQuat = simd_quatf(angle: stepRad, axis: deltaOrientationQuat.axis)

                    if let deltaLoc = animationSequence[index].deltaLocation {
                        animationSequence[index].deltaLocation = stepQuat.act(deltaLoc)
                    }

                    if let prevDeltaRot = animationSequence[index].deltaRotation {
                        animationSequence[index].deltaRotation = stepQuat * prevDeltaRot
                    }
                } else {
                    AppLogger.shared.error("Failed to compute full‚Äëstep blend infos for \(animationSequence[index].animationName)")
                }
                let q = simd_quatf(
                    angle: perStepAdjustmentAngle * (.pi / 180),
                    axis: deltaOrientationQuat.axis
                )
                applyCirAdjustmentRecursively(
                    to: &animationSequence[index],
                    cirDeg: perStepAdjustmentAngle,
                    isFullStep: true,
                    deltaQuat: q,
                    dataManager: dataManager
                )
                groupApplied = true
                groupAdjustmentAngle = perStepAdjustmentAngle
            }
            index += 1
        }
        if groupApplied {
            effectiveAdjustmentAngle += groupAdjustmentAngle
        }
    }
    
    let effectiveAdjustmentQuat = simd_quatf(angle: effectiveAdjustmentAngle, axis: deltaOrientationQuat.axis)
    return effectiveAdjustmentQuat
}


func adjustStrideLength(
    animationSequence: inout [AnimationSequenceElement],
    startElementIndex: Int,
    pathDistanceAfterCorrection: Float,
    travelGuide: TravelGuide,
    dataManager: DataManager
) {
    guard let firstOccurrenceIndex = animationSequence[startElementIndex...]
        .firstIndex(where: { elem in
            guard elem.startPoseName.isStepFirstPose,
                  let animDataPoint = dataManager.getAnimDataPoint(for: elem.animationName),
                  animDataPoint.criticalPoses[elem.startPoseIndex].stepID != nil
            else { return false }
            return true
        })
    else {
        // this is not an error, since we may be in transitional sequence that does not allow for stride adjustmnet
        return
    }
    
    
    var lagStride: Float?
    if firstOccurrenceIndex > 0,
       let prevDataPoint = dataManager.getAnimDataPoint(for: animationSequence[firstOccurrenceIndex - 1].animationName),
       prevDataPoint.criticalPoses[animationSequence[firstOccurrenceIndex - 1].startPoseIndex].stepID != nil
    {
        lagStride = animationSequence[firstOccurrenceIndex - 1].animAlteration?.strideLength
    }
    
    let step1animationName = animationSequence[firstOccurrenceIndex].animationName
    let step1CriticalPoseIndex = animationSequence[firstOccurrenceIndex].startPoseIndex
    
    if let dp = dataManager.getAnimDataPoint(for: step1animationName),
       dp.criticalPoses[step1CriticalPoseIndex].stepID != nil
    {
        let step1animationNameMAX = "\(step1animationName)--strideMAX"
        let step1animationNameMIN = "\(step1animationName)--strideMIN"
    
        if dataManager.getAnimDataPoint(for: step1animationNameMAX) == nil {
            adjustStrideForWalkAnimationMAX(animationName: step1animationName,
                                            dataManager: dataManager)
        }
        if dataManager.getAnimDataPoint(for: step1animationNameMIN) == nil {
            adjustStrideForWalkAnimationMIN(animationName: step1animationName,
                                            dataManager: dataManager)
        }
    }
    
    guard let stride1Data = dataManager.getStepData(
        for: step1animationName,
        criticalPoseIndex: step1CriticalPoseIndex
    )
    else {
        return
    }
    let maxStride1 = stride1Data.maxStride
    let minStride1 = stride1Data.minStride
    
    
    var stride2Data: StepData?
    var maxStride2: Float?
    var minStride2: Float?
    if let secondOccurrenceIndex = animationSequence[animationSequence.index(after: firstOccurrenceIndex)...]
        .firstIndex(where: { elem in
            guard elem.startPoseName.isStepFirstPose,
                  let dp = dataManager.getAnimDataPoint(for: elem.animationName),
                  dp.criticalPoses[elem.startPoseIndex].stepID != nil // ‚Üê NEW filter
            else { return false }
            return true
        })
    {
        let step2animationName = animationSequence[secondOccurrenceIndex].animationName
        let step2CriticalPoseIndex = animationSequence[secondOccurrenceIndex].startPoseIndex
        let step2animationNameMAX = "\(step2animationName)--strideMAX"
        let step2animationNameMIN = "\(step2animationName)--strideMIN"
            
        if let dp2 = dataManager.getAnimDataPoint(for: step2animationName),
           dp2.criticalPoses[step2CriticalPoseIndex].stepID != nil
        {
            if dataManager.getAnimDataPoint(for: step2animationNameMAX) == nil {
                adjustStrideForWalkAnimationMAX(animationName: step2animationName,
                                                dataManager: dataManager)
            }
            if dataManager.getAnimDataPoint(for: step2animationNameMIN) == nil {
                adjustStrideForWalkAnimationMIN(animationName: step2animationName,
                                                dataManager: dataManager)
            }
        }
            
        guard let stride2DataCalc = dataManager.getStepData(for: step2animationName, criticalPoseIndex: step2CriticalPoseIndex) else {
            return
        }
        
        stride2Data = stride2DataCalc
        maxStride2 = stride2DataCalc.maxStride
        minStride2 = stride2DataCalc.minStride
    }
    
    if stride2Data == nil {
        guard let maxStride1 = maxStride1,
              let minStride1 = minStride1
        else {
            AppLogger.shared.error("Error: No max or min stride data found for \(step1animationName).")
            return
        }
        let originalStride1 = length(stride1Data.stepLocation)
        let adjustedStride1 = clamp(originalStride1 - pathDistanceAfterCorrection, min: minStride1, max: maxStride1)
        
        var index = firstOccurrenceIndex
        guard let firstAnimDataPoint = dataManager.getAnimDataPoint(for: animationSequence[index].animationName) else { return }
        let firstStepID = firstAnimDataPoint.criticalPoses[animationSequence[index].startPoseIndex].stepID
        
        while index < animationSequence.count {
            guard let animDataPoint = dataManager.getAnimDataPoint(for: animationSequence[index].animationName),
                  let poseStepID = animDataPoint.criticalPoses[animationSequence[index].startPoseIndex].stepID,
                  poseStepID == firstStepID
            else {
                index += 1
                continue
            }
            
            if animationSequence[index].animAlteration == nil {
                animationSequence[index].animAlteration = AnimAlteration(
                    walkCircleAlteration: WalkCircleAlteration(cirWalkDegree: 0, cirCoreBlendInfo: nil, cirNonCoreBlendInfo: nil),
                    strideLength: adjustedStride1
                )
            } else {
                animationSequence[index].animAlteration?.strideLength = adjustedStride1
            }
            
            if var deltaLoc = animationSequence[index].deltaLocation {
                let ratio = adjustedStride1 / originalStride1
                deltaLoc *= ratio
                animationSequence[index].deltaLocation = deltaLoc
            }
            
            index += 1
        }
        return
    }
    
    guard let stride2 = stride2Data else { return }
    
    guard let maxStride1 = maxStride1, let maxStride2 = maxStride2, let minStride1 = minStride1, let minStride2 = minStride2 else {
        AppLogger.shared.error("Error: No max or min stride data found for \(step1animationName) or second step animation).")
        return
    }
    
    let originalStride1 = length(stride1Data.stepLocation)
    let originalStride2 = length(stride2.stepLocation)
    
    let effectiveThreshold = min(travelGuide.veerOffPathDeltaThreshold, pathDistanceAfterCorrection)
    
    let lowerBound1 = minStride1 - originalStride1
    let upperBound1 = maxStride1 - originalStride1
    
    let lowerBound2 = effectiveThreshold + originalStride2 - maxStride2
    let upperBound2 = effectiveThreshold + originalStride2 - minStride2
    
    let dLower = max(lowerBound1, lowerBound2)
    let dUpper = min(upperBound1, upperBound2)
    
    if dLower > dUpper {
        let dCandidate = (dLower + dUpper) / 2.0
        let s1 = clamp(originalStride1 + dCandidate, min: minStride1, max: maxStride1) // ERROR: Value of optional type 'Float?' must be unwrapped to a value of type 'Float'
        let s2 = clamp(originalStride2 + (effectiveThreshold - dCandidate), min: minStride2, max: maxStride2)
        assignStrideLengths(animationSequence: &animationSequence,
                            dataManager: dataManager,
                            firstGroupStartIndex: firstOccurrenceIndex,
                            firstStride: s1,
                            secondStride: s2)
        return
    }
    
    func objective(_ d: Float) -> Float {
        let s1 = originalStride1 + d
        let s2 = originalStride2 + (effectiveThreshold - d)
        let strideDiffCost = Swift.abs(s2 - s1)
        if let lag = lagStride {
            return Swift.abs(s1 - lag) + strideDiffCost
        } else {
            return strideDiffCost
        }
    }
    
    var candidateDs = [Float]()
    candidateDs.append(dLower)
    candidateDs.append(dUpper)
    
    if let lag = lagStride {
        candidateDs.append(lag - originalStride1)
    }
    
    candidateDs.append((originalStride2 + effectiveThreshold - originalStride1) / 2.0)
    
    let feasibleCandidates = candidateDs.filter { $0 >= dLower && $0 <= dUpper }
    
    var bestD = feasibleCandidates.first ?? dLower
    var bestObjective = objective(bestD)
    for d in feasibleCandidates {
        let cost = objective(d)
        if cost < bestObjective {
            bestObjective = cost
            bestD = d
        }
    }
    
    let targetStride1 = originalStride1 + bestD
    let targetStride2 = originalStride2 + (effectiveThreshold - bestD)
    
    let clampedStride1 = clamp(targetStride1, min: minStride1, max: maxStride1)
    let clampedStride2 = clamp(targetStride2, min: minStride2, max: maxStride2)
    
    assignStrideLengths(animationSequence: &animationSequence,
                        dataManager: dataManager,
                        firstGroupStartIndex: firstOccurrenceIndex,
                        firstStride: clampedStride1,
                        secondStride: clampedStride2)
}

private func assignStrideLengthRecursively(to element: inout AnimationSequenceElement, stride: Float) {
    if element.animAlteration == nil {
        element.animAlteration = AnimAlteration(
            walkCircleAlteration: WalkCircleAlteration(cirWalkDegree: 0, cirCoreBlendInfo: nil, cirNonCoreBlendInfo: nil, cirBlendInfo: nil),
            strideLength: stride
        )
    } else {
        element.animAlteration?.strideLength = stride
    }
    
    if var tree = element.blendTree, !tree.blendNodes.isEmpty {
        assignStrideLengthRecursively(to: &tree.blendNodes[0].blendElement, stride: stride)
        element.blendTree = tree
    }
}

private func assignStrideLengths(
    animationSequence: inout [AnimationSequenceElement],
    dataManager: DataManager,
    firstGroupStartIndex: Int,
    firstStride: Float,
    secondStride: Float
) {
    var index = firstGroupStartIndex
    
    guard index < animationSequence.count,
          let firstAnimDataPoint = dataManager.getAnimDataPoint(for: animationSequence[index].animationName) else { return }
    let firstStepID = firstAnimDataPoint.criticalPoses[animationSequence[index].startPoseIndex].stepID
    
    let originalStride1 = length(
        dataManager.getStepData(
            for: animationSequence[firstGroupStartIndex].animationName,
            criticalPoseIndex: animationSequence[firstGroupStartIndex].startPoseIndex
        )!.stepLocation
    )
    
    while index < animationSequence.count {
        guard let animDataPoint = dataManager.getAnimDataPoint(for: animationSequence[index].animationName),
              let poseStepID = animDataPoint.criticalPoses[animationSequence[index].startPoseIndex].stepID,
              poseStepID == firstStepID
        else {
            index += 1
            continue
        }
        assignStrideLengthRecursively(to: &animationSequence[index], stride: firstStride)
        
        if var d = animationSequence[index].deltaLocation {
            d *= (firstStride / originalStride1)
            animationSequence[index].deltaLocation = d
        }
        
        index += 1
    }
    
    guard index < animationSequence.count,
          let secondAnimDataPoint = dataManager.getAnimDataPoint(for: animationSequence[index].animationName) else { return }
    let secondStepID = secondAnimDataPoint.criticalPoses[animationSequence[index].startPoseIndex].stepID
    
    let originalStride2 = length(
        dataManager.getStepData(
            for: animationSequence[index].animationName,
            criticalPoseIndex: animationSequence[index].startPoseIndex
        )!.stepLocation
    )
    
    while index < animationSequence.count {
        guard let animDataPoint = dataManager.getAnimDataPoint(for: animationSequence[index].animationName),
              let poseStepID = animDataPoint.criticalPoses[animationSequence[index].startPoseIndex].stepID,
              poseStepID == secondStepID
        else {
            index += 1
            continue
        }
        assignStrideLengthRecursively(to: &animationSequence[index], stride: secondStride)
        
        if var d = animationSequence[index].deltaLocation {
            d *= (secondStride / originalStride2)
            animationSequence[index].deltaLocation = d
        }
        
        index += 1
    }
}

private func clamp(_ value: Float, min minValue: Float, max maxValue: Float) -> Float {
    return Swift.max(minValue, Swift.min(maxValue, value))
}

private func hasStepID(_ adp: AnimDataPoint, poseIndex: Int) -> Bool {
    adp.criticalPoses[poseIndex].stepID != nil
}




private func applyCirAdjustmentRecursively(
    to element: inout AnimationSequenceElement,
    cirDeg: Float,
    isFullStep: Bool,
    deltaQuat: simd_quatf,
    dataManager: DataManager
) {
    guard let blend = computeBlendInfos(
        for: element,
        isFullStep: isFullStep,
        dataManager: dataManager
    ) else {
        AppLogger.shared.error("Error: cannot compute blend infos for \(element.animationName)")
        return
    }

    if element.animAlteration == nil {
        element.animAlteration = AnimAlteration(
            walkCircleAlteration: WalkCircleAlteration(
                cirWalkDegree: cirDeg,
                cirBlendInfo: blend
            ),
            strideLength: nil
        )
    } else {
        element.animAlteration?.walkCircleAlteration =
            WalkCircleAlteration(cirWalkDegree: cirDeg, cirBlendInfo: blend)
    }

    if let dL = element.deltaLocation { element.deltaLocation = deltaQuat.act(dL) }
    if let dR = element.deltaRotation { element.deltaRotation = deltaQuat * dR }
    
    if var tree = element.blendTree {
        for i in tree.blendNodes.indices {
            var child = tree.blendNodes[i].blendElement
            applyCirAdjustmentRecursively(
                to: &child,
                cirDeg: cirDeg,
                isFullStep: isFullStep,
                deltaQuat: deltaQuat,
                dataManager: dataManager
            )
            tree.blendNodes[i].blendElement = child
        }
        element.blendTree = tree
    }
}

==== AnimLibS/Brain/Walk/5-InertialUnits.swift ====

import CoreLib
import RealityKit

func assignInertialInfoForWalk(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    dataManager: DataManager
) {

    assignNonCoreCirInertialInfo(
        animationSequence: &animationSequence,
        initIndex: initIndex,
        dataManager: dataManager
    )

    assignWalkToWalkTransitionalInertialInfo(
        animationSequence: &animationSequence,
        initIndex: initIndex,
        dataManager: dataManager
    )
    
}




private func assignWalkToWalkTransitionalInertialInfo(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    dataManager: DataManager
) {
    guard animationSequence.indices.contains(initIndex + 1) else {
        AppLogger.shared.error("Error: [2] No next element found in the animation sequence.")
        return
    }

    for i in (initIndex + 1)..<animationSequence.count {
        guard i + 1 < animationSequence.count else { break }
        let current = animationSequence[i]
        let next = animationSequence[i + 1]

        if current.startPoseName.moveType == .walk,
           current.endPoseName.moveType == .walk,
           next.startPoseName.moveType == .walk,
           next.endPoseName.moveType == .transition
        {
            guard let frameCount = calculateAnimationElementFrameCount(
                element: current,
                dataManager: dataManager
            ) else {
                AppLogger.shared.error("Failed to fetch frameCount for transitional IN.")
                continue
            }
            let unit = InertialUnit(
                boneIndices: nil, // inertialize all bones
                blendFrames: frameCount,
                isReverse: true // reverse inertialization
            )
            var updated = current
            if updated.inertialUnits == nil { updated.inertialUnits = [] }
            updated.inertialUnits!.append(unit)
            animationSequence[i] = updated
        }

        let prevIndex = i - 1
        if prevIndex >= 0 {
            let previous = animationSequence[prevIndex]
            if previous.startPoseName.moveType == .transition,
               previous.endPoseName.moveType == .walk
            {
                guard let frameCount = calculateAnimationElementFrameCount(
                    element: current,
                    dataManager: dataManager
                ) else {
                    AppLogger.shared.error("Failed to fetch frameCount for transitional OUT.")
                    continue
                }
                let unit = InertialUnit(
                    boneIndices: nil, // inertialize all bones
                    blendFrames: frameCount,
                    isReverse: false // forward (regular) inertialization
                )
                var updated = current
                if updated.inertialUnits == nil { updated.inertialUnits = [] }
                updated.inertialUnits!.append(unit)
                animationSequence[i] = updated
            }
        }
    }
}



private func assignNonCoreCirInertialInfo(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    dataManager: DataManager
) {

    guard animationSequence.indices.contains(initIndex + 1) else {
        AppLogger.shared.error("Error: Not enough elements in animation sequence for walk inertial assignment.")
        return
    }

    for i in (initIndex + 1)..<animationSequence.count {
        let current = animationSequence[i]
        let previous = animationSequence[i - 1]

        let prevAlteration = previous.animAlteration?.walkCircleAlteration ?? WalkCircleAlteration(
            cirWalkDegree: 0,
            cirCoreBlendInfo: nil,
            cirNonCoreBlendInfo: nil,
            cirBlendInfo: nil
        )
        let currAlteration = current.animAlteration?.walkCircleAlteration ?? WalkCircleAlteration(
            cirWalkDegree: 0,
            cirCoreBlendInfo: nil,
            cirNonCoreBlendInfo: nil,
            cirBlendInfo: nil
        )

        if prevAlteration.cirWalkDegree != currAlteration.cirWalkDegree,
           prevAlteration.endIsAltered || currAlteration.startIsAltered
        {
            guard let frameCount = calculateAnimationElementFrameCount(
                element: current,
                dataManager: dataManager
            ) else {
                AppLogger.shared.error("Failed to fetch frame count for non-core cir inertial assignment.")
                continue
            }

            let boneIndices = getAllBoneIndicesFromTwistOperations(operations: NonCoreTwistOperations.operations, dataManager: dataManager)

            let unit = InertialUnit(
                boneIndices: boneIndices,
                blendFrames: frameCount,
                isReverse: false
            )

            var updated = current
            if updated.inertialUnits == nil { updated.inertialUnits = [] }
            updated.inertialUnits?.append(unit)
            animationSequence[i] = updated
        }
    }
}

==== AnimLibS/Brain/Walk/6-walkToIdle.swift ====



import CoreLib
import RealityKit
import simd

let reachedIdleLocationThreshold: Float = 0.20 // ‚Üê magic‚Äënumber tweakable

func attemptTransitionToIdle(
    animationSequence: inout [AnimationSequenceElement],
    initIndex: Int,
    travelGuide: TravelGuide,
    entityWorldTransform: Transform,
    threshold: Float,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome? {
    let targetPattern: [MoveType] = [.walk, .transition, .idle]
    let idleTransitionCandidates = transitionCandidates(targetPattern: targetPattern, dataManager: dataManager)
    
    if
        let chosenIdleClip = shouldTransitionToIdleNow(
            animationSequence: animationSequence,
            currentIdx: initIndex,
            travelGuide: travelGuide,
            idleCandidates: idleTransitionCandidates,
            entityWorldTransform: entityWorldTransform,
            threshold: threshold,
            dataManager: dataManager
        ),
        let indices = dataManager.getIndicesOfCriticalPose(
            for: chosenIdleClip,
            matching: animationSequence[initIndex].endPoseName
        ),
        let startPoseIndex = indices.first
    {
        if printBrainSystem {
            AppLogger.shared.anim("üß† Transitioning to idle now. Chosen idle clip: \(chosenIdleClip)")
        }
        
        let isSuccess = attachIdleSequence(
            animationSequence: &animationSequence,
            initIdx: initIndex,
            idleAnimName: chosenIdleClip,
            startPoseIndex: startPoseIndex,
            dataManager: dataManager
        )
        
        if isSuccess == .done,
           initIndex + 1 < animationSequence.count
        {
            var inertialElement = animationSequence[initIndex + 1]
            guard let frameCount = calculateAnimationElementFrameCount(
                element: inertialElement,
                dataManager: dataManager
            ) else {
                AppLogger.shared.error("Failed to fetch frameCount for transitional idle.")
                return .failed
            }
            
            let unit = InertialUnit(
                boneIndices: nil,
                blendFrames: frameCount,
                isReverse: false
            )
            if inertialElement.inertialUnits == nil { inertialElement.inertialUnits = [] }
            inertialElement.inertialUnits!.append(unit)
            animationSequence[initIndex + 1] = inertialElement
            return .done
        }
    }
    return nil
}

func idleTravelTarget(in travelGuide: TravelGuide) -> TravelTarget? {
    travelGuide.targetDestinations.first { $0.inPlace }
}

func distanceFromProjectedEndToIdle(
    animationSequence: [AnimationSequenceElement],
    startElementIndex: Int,
    travelGuide: TravelGuide,
    entityPosition: SIMD3<Float>,
    entityWorldOrientation: simd_quatf,
    dataManager: DataManager
) -> Float? {
    guard
        let idleLoc = idleTravelTarget(in: travelGuide)?.location,
        let projectedEnd = projectedEndLocation(
            animationSequence: animationSequence,
            startElementIndex: startElementIndex,
            entityPosition: entityPosition,
            entityWorldOrientation: entityWorldOrientation,
            dataManager: dataManager)
    else {
        AppLogger.shared.error("Error: No idle location found or projected end location could not be computed.")
        return nil
    }

    return simd_length(projectedEnd - idleLoc)
}

func startWalkPoseName(beforeTransitionIn animName: String,
                       dataManager: DataManager) -> CriticalPoseName?
{
    guard let dp = dataManager.getAnimDataPoint(for: animName) else { return nil }

    var prev: CriticalPoseName?
    for pose in dp.criticalPoses {
        if pose.poseName.moveType == .transition { return prev }
        prev = pose.poseName
    }
    return nil
}

func chooseIdleTransitionClip(
    currentElement: AnimationSequenceElement,
    idleCandidates: [String],
    dataManager: DataManager
) -> String? {
    for name in idleCandidates {
        if let walkPose = startWalkPoseName(beforeTransitionIn: name,
                                            dataManager: dataManager),
            walkPose == currentElement.endPoseName
        {
            return name
        }
    }
    return nil
}


func shouldTransitionToIdleNow(
    animationSequence: [AnimationSequenceElement],
    currentIdx: Int,
    travelGuide: TravelGuide,
    idleCandidates: [String],
    entityWorldTransform: Transform,
    threshold: Float = reachedIdleLocationThreshold,
    dataManager: DataManager
) -> String? /* returns chosen clip or nil */ {
    let entityPosition: SIMD3<Float> = entityWorldTransform.translation
    let entityWorldOrientation: simd_quatf = entityWorldTransform.rotation
    let currentElement = animationSequence[currentIdx]

    guard let idleLoc = idleTravelTarget(in: travelGuide)?.location else { return nil }

    for animName in idleCandidates {
        guard let animationDataPoint = dataManager.getAnimDataPoint(for: animName) else { continue }

        guard let firstTransitionIdx = animationDataPoint.criticalPoses.firstIndex(where: { $0.poseName.moveType == .transition }) else { continue }

        guard let matchIdx = animationDataPoint.criticalPoses[..<firstTransitionIdx].firstIndex(where: { $0.poseName == currentElement.endPoseName }) else { continue }

        var localŒî = SIMD3<Float>(repeating: 0)
        var localRot = simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0))

        var lastTransitionIdx = firstTransitionIdx
        while lastTransitionIdx + 1 < animationDataPoint.criticalPoses.count,
              animationDataPoint.criticalPoses[lastTransitionIdx + 1].poseName.moveType == .transition
        {
            lastTransitionIdx += 1
        }

        for idx in matchIdx ... lastTransitionIdx {
            let pose = animationDataPoint.criticalPoses[idx]
            localŒî += pose.deltaLocation
            localRot = localRot * pose.deltaRotation
        }

        let worldŒî = entityWorldOrientation.act(localŒî)
        let predictedWorldPos = entityPosition + worldŒî

        let worldDist = simd_length(predictedWorldPos - idleLoc)
        if worldDist <= reachedIdleLocationThreshold {
            return animName // ‚úî found a viable clip
        }
    }

    return nil
}

func attachIdleSequence(
    animationSequence: inout [AnimationSequenceElement],
    initIdx: Int,
    idleAnimName: String,
    startPoseIndex: Int,
    dataManager: DataManager
) -> buildAnimationSequenceOutcome {
    guard let idleSeq = constructAnimationSequenceForGivenAnimation(
        animationName: idleAnimName,
        startCriticalPoseIndex: startPoseIndex,
        endCriticalPoseIndex: nil,
        isFilledOut: false,
        dataManager: dataManager)
    else {
        AppLogger.shared.error("Error: Failed to build idle transition sequence for \(idleAnimName)")
        return .failed
    }

    animationSequence.removeSubrange(initIdx + 1 ..< animationSequence.count)
    animationSequence.append(contentsOf: idleSeq)
    
    return .done
}

func projectedEndLocation(
    animationSequence: [AnimationSequenceElement],
    startElementIndex: Int,
    entityPosition: SIMD3<Float>,
    entityWorldOrientation: simd_quatf,
    dataManager: DataManager
) -> SIMD3<Float>? {
    var localŒî = SIMD3<Float>(repeating: 0)

    for idx in startElementIndex ..< animationSequence.count {
        if let Œ¥ = animationSequence[idx].deltaLocation {
            localŒî += Œ¥
        } else {
            guard let ad = dataManager.getAnimDataPoint(for: animationSequence[idx].animationName)
            else { return nil }
            localŒî += ad.criticalPoses[animationSequence[idx].startPoseIndex].deltaLocation
        }
    }

    let worldŒî = entityWorldOrientation.act(localŒî)
    return entityPosition + worldŒî
}


func transitionCandidates(targetPattern: [MoveType], dataManager: DataManager) -> [String] {
    return dataManager.animationDataIndex.values.compactMap { dataPoint in
        dataPoint.moveList == targetPattern ? dataPoint.animationName : nil
    }
}

==== AnimLibS/Components/BrainComponent.swift ====


import CoreLib
import Foundation
import RealityKit

public struct BrainComponent: RealityKit.Component {
    var animationSequence: [AnimationSequenceElement] = []
    var blendingAnimationSequence: [AnimationSequenceElement] = []
    var isNewSegment: Bool = false // DEBUG, to drop later
    public init() {}
}

public class BrainSystem: RealityKit.System {
    @MainActor private static let query = animationComponentQuery

    public required init(scene: RealityKit.Scene) {}


    public func update(context: SceneUpdateContext) {
        let characters = context.entities(matching: Self.query, updatingSystemWhen: .rendering)
        
        for character in characters {
            guard
                var brainComponent = character.components[BrainComponent.self],
                var eventComponent = character.components[EventComponent.self],
                let dataCenterComponent = character.components[DataCenterComponent.self]
            else { continue }
            
            if printBrainSystem { AppLogger.shared.anim("üß† ----------- Brain system is running for \(character.name) at \((dataCenterComponent.gameTime * 10000).rounded() / 10000): -------------") }
            
            let dataManager = dataCenterComponent.dataManager
            var currentAnimationSequence = brainComponent.animationSequence
            
            
            
            var brainDecisionState = BrainDecisionState.decideState(&eventComponent, currentAnimationSequence, dataManager)
            
            switch brainDecisionState {
            case .noDecisionNeeded:
                if printBrainSystem { AppLogger.shared.anim("üß† No need to decide on next animation.") }
                
            case .decideFresh:
                if printBrainSystem { AppLogger.shared.anim("üß† DecideFresh: Should decide on next animation. The sequence is empty.") }
                let targetAnimations: [String: [Int]] = [defaultAnimation: [1, 2, 3]] // TODO: choose animation dynamically later
                
                for targetAnimation in targetAnimations.keys {
                    guard let animDataPointTarget = dataCenterComponent.dataManager.getAnimDataPoint(for: targetAnimation) else { continue }
                    
                    guard let currentAnimationSequenceComp = constructAnimationSequenceForGivenAnimation(
                        animationName: targetAnimation,
                        startCriticalPoseIndex: 0,
                        endCriticalPoseIndex:nil, // if optional, search till the end or completes full loop,
                        isFilledOut: true,
                        dataManager: dataManager
                    ) else {
                        AppLogger.shared.error("üß† Error: Could not construct animation sequence for \(targetAnimation).")
                        continue
                    }
                    currentAnimationSequence = currentAnimationSequenceComp
                    
                    break
                }
                
                eventComponent.eventCache.removeAll()
                
            case .extendCurrentPlan, .createNewPlan:
                if printBrainSystem { AppLogger.shared.anim("üß† Should decide on next animation given \(brainDecisionState).") }
                
                var initAnimationSequenceIndex = brainDecisionState == .createNewPlan ?
                    currentAnimationSequence.startIndex :
                    currentAnimationSequence.count - 1
                
                guard currentAnimationSequence.indices.contains(initAnimationSequenceIndex) else {
                    // Handle the error case
                    AppLogger.shared.error("üß† Error: currentAnimationSequence is empty. Should not happen in .extendCurrentPlan, .createNewPlan.")
                    brainDecisionState = .decideFresh
                    break
                }
                
                let isSuccess = buildAnimationSequence(
                    entity: character,   //Debug: to delete //üëÄ

                    currentAnimationSequence: &currentAnimationSequence,
                    initAnimationSequenceIndex: &initAnimationSequenceIndex,
                    styleGuide: &eventComponent.styleGuide,
                    travelGuide: &eventComponent.travelGuide,
                    eventComponent: eventComponent, //debug: to delete üëÄ
                    dataManager: dataManager
                )
                
                if isSuccess == .done {
                    eventComponent.eventCache.removeAll()
                }
                    
                if printBrainSystem {
                    if isSuccess == .done{
                        AppLogger.shared.debug("üß† Animation sequence successfully built for \(brainDecisionState).")
                        
                    } else if isSuccess == .tooEarly {
                        AppLogger.shared.anim("üß† Too early to build animation sequence. Continue with existing sequence.")
                    } else if isSuccess == .alreadyReady {
                        AppLogger.shared.anim("üß† Next element already ready to play. Continue with existing sequence.")
                    } else {
                        AppLogger.shared.error("üß† Error: Failed to build animation sequence. Continue with existing sequence.")
                    }
                }
            }
            
            brainComponent.animationSequence = currentAnimationSequence
            
            character.components.set(brainComponent)
            character.components.set(eventComponent)
        }
    }
}

enum BrainDecisionState {
    case noDecisionNeeded
    case decideFresh
    case extendCurrentPlan
    case createNewPlan
    
    @MainActor static func decideState(
        _ eventComponent: inout EventComponent,
        _ currentAnimationSequence: [AnimationSequenceElement],
        _ dataManager: DataManager
    ) -> BrainDecisionState {
        
        if currentAnimationSequence.isEmpty {
            return .decideFresh
        }
        
        let isTimeForNewPlan = checkIfNewPlan(eventComponent: eventComponent, currentAnimationSequence: currentAnimationSequence)
        if isTimeForNewPlan {
            return .createNewPlan
        }
        
        
        if currentAnimationSequence.count <= 1 {
            return .extendCurrentPlan
        }
        
        
        if let firstSection = currentAnimationSequence.first,
           let currentFrame = firstSection.currentFrame
        {
            let startPoseFrame = firstSection.startPoseFrame
            let totalFrames = currentAnimationSequence.reduce(0) { total, element in
                if let frameCount = calculateAnimationElementFrameCount(
                    element: element,
                    dataManager: dataManager
                ) {
                    return total + Int(frameCount)
                } else {
                    return total
                }
            }
                
            let adjustedFrames = totalFrames - Int(currentFrame - startPoseFrame)
                
            if adjustedFrames <= (Int(minBlendingFrameCount) + 1) { // +1 is for padding
                if printBrainSystem {
                    AppLogger.shared.anim("üß† Total frames left in the sequence is \(adjustedFrames). Sending order to .extendCurrentPlan")
                }
                return .extendCurrentPlan
            }
        }
            
        if currentAnimationSequence.isEmpty {
            AppLogger.shared.error("üß† Error: No more frames left in the sequence. Deciding on new animation: .decideFresh")
            return .decideFresh
        }
            
        return .noDecisionNeeded
    }
}

@MainActor
func checkIfNewPlan(eventComponent: EventComponent, currentAnimationSequence: [AnimationSequenceElement]) -> Bool {
    let hasNewEvent = eventComponent.eventCache.contains { $0.isNew }
    let isNewDestination = eventComponent.travelGuide.isNewDestination //does pathway contain new targets?

    guard hasNewEvent || isNewDestination else {
        return false
    }
    
    guard let currentElement = currentAnimationSequence.first else {
        return false
    }
    
    let currentMoveType = currentElement.startPoseName.moveType
    
    if mustFinishMoveTypes.contains(currentMoveType) /*|| currentElement.customAnimationInfo != nil*/ {
        return false
    }
    
    if printBrainSystem {
        if isNewDestination {
            AppLogger.shared.anim("üß† New move target found. Sending order to .createNewPlan")
        } else {
            AppLogger.shared.anim("üß† New event found. Sending order to .createNewPlan")
        }
    }
    
    return true
}

==== AnimLibS/Components/AnimationSystem.swift ====


import Combine
import CoreLib
import RealityKit
import SwiftUI

public struct AnimationComponent: RealityKit.Component {
    var animTime: Float = 0.0
    var lagAnimationSequenceElement: AnimationSequenceElement?
    var nextElementIsReady: Bool = false
    public init() {}
}

public struct AnimationSystem: RealityKit.System {
    @MainActor private static let query = animationComponentQuery
    
    public init(scene: RealityKit.Scene) {}
    
    public static var dependencies: [SystemDependency] { [ .before(TravelSystem.self)] }
    
    public func update(context: SceneUpdateContext) {
        for character in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {
            guard character.isEnabled else { continue } // TODO: run only for enabled characters. Add everywhere else.
            
            guard
                var brainComponent = character.components[BrainComponent.self],
                var animationComponent = character.components[AnimationComponent.self],
                let dataCenterComponent = character.components[DataCenterComponent.self]
            else {
                AppLogger.shared.error("Error: Failed to get brainComponent, animationComponent or skeletalPosesComponent")
                continue
            }

            var playbackState = character.components[AnimationPlaybackStateComponent.self] ?? AnimationPlaybackStateComponent()
            let didNotHavePlaybackStateYet = playbackState.currentAnimationName.isEmpty

            brainComponent.isNewSegment = false
            
            guard var skelPosesComponent = character.parentEntitySet().modelEntity.components[SkeletalPosesComponent.self]
            else {
                AppLogger.shared.error("Error: Missing SkeletalPosesComponent for \(character.name)")
                continue
            }
            
            if printAnimationSystem { AppLogger.shared.anim("üé• ---- Animation system is running for character: \(character.name) at \((dataCenterComponent.gameTime * 10000).rounded() / 10000) and deltaTime \((context.deltaTime * 10000).rounded() / 10000) ----") }
            
            var animationSequence = brainComponent.animationSequence
            let dataManager = dataCenterComponent.dataManager
            
            guard var animationSequenceElement = animationSequence.first else {
                AppLogger.shared.error("Error: Sequence is empty. Cannot create animation transforms.")
                continue
            }
            
            var animTime = animationComponent.animTime + Float(context.deltaTime)
            
            
            if let (newAnimationSequenceElement, newAnimTime) = advanceAnimationSequenceIfNeeded(
                for: character,
                brainComponent: &brainComponent,
                animationComponent: &animationComponent,
                currentAnimationElement: &animationSequenceElement,
                animTime: animTime,
                dataManager: dataManager
            ) {
                animationSequenceElement = newAnimationSequenceElement
                animTime = newAnimTime
                brainComponent.isNewSegment = true
                animationSequence = brainComponent.animationSequence
            }
                
            
            if animationSequenceElement.isPlaying == false {
                if animationSequenceElement.animData == nil {
                    let lagAnimationSequenceElement = animationComponent.lagAnimationSequenceElement
                    var leadAnimationSequenceElement: AnimationSequenceElement? = nil
                    if animationSequence.count > 1 {
                        leadAnimationSequenceElement = animationSequence[1]
                    }
                    
                    generateAnimDataForSequenceElement(
                        animationSequenceElement: &animationSequenceElement,
                        lagAnimationSequenceElement: lagAnimationSequenceElement,
                        leadAnimationSequenceElement: &leadAnimationSequenceElement,
                        dataManager: dataManager
                    )
                }
            } else {
                // if animation is marked Playing but has issues, drop the animationElement and log the error
                skipAnimationElementWithIssues(for: character, characterName: character.name, brainComponent: &brainComponent, animationSequenceElement: animationSequenceElement)
                
                if let newAnimationSequenceElement = animationSequence.first {
                    animationSequenceElement = newAnimationSequenceElement
                } else {
                    AppLogger.shared.error("Error: [2] Sequence is empty. Cannot create animation transforms.")
                    continue
                }
            }
            
            
            if let updatedAnimationSequenceElement = playAnimation(
                for: character,
                animationSequenceElement: &animationSequenceElement,
                animTime: animTime,
                &skelPosesComponent,
                dataManager
            ) {
                animationSequenceElement = updatedAnimationSequenceElement

                if printAnimationSystem {
                    AppLogger.shared.anim("üé• Playing \(animationSequenceElement.animationName) from \(animationSequenceElement.startPoseName) [\(animationSequenceElement.startPoseFrame ?? -1)] to \(animationSequenceElement.endPoseName) [\(animationSequenceElement.endPoseFrame ?? -1)], current frame: \(animationSequenceElement.currentFrame ?? -1) and animTime is \(animTime.rounding(to: 2)) out of \(animationSequenceElement.animData?.animTimeArray.last?.rounding(to: 2) ?? -1). ‚è≥\((dataCenterComponent.gameTime * 10000).rounded() / 10000)(Œî\((context.deltaTime * 10000).rounded() / 10000)).")
                }

            } else {
                AppLogger.shared.error("Error: Failed to play animation for \(character.name)")
            }

            let hudSnapshot = AnimationDebugBus.shared.snapshot()
            if hudSnapshot.isEnabled {
                let forceEmit =
                    didNotHavePlaybackStateYet ||
                    (playbackState.debugHUDGenerationSeen != hudSnapshot.generation)

                if forceEmit || brainComponent.isNewSegment {
                    let built = AnimationDebugHUDBuilder.signatureAndCard(
                        characterName: character.name,
                        element: animationSequenceElement,
                        gameTimeSeconds: Double(dataCenterComponent.gameTime)
                    )

                    if forceEmit || built.signature != playbackState.debugHUDLastSignature {
                        AnimationDebugBus.shared.emit(.card(built.card))
                        playbackState.debugHUDLastSignature = built.signature
                    }

                    playbackState.debugHUDGenerationSeen = hudSnapshot.generation
                }
            }

            playbackState.currentAnimationName = animationSequenceElement.animationName
            playbackState.currentMoveType = animationSequenceElement.endPoseName.moveType
            playbackState.currentFrame = animationSequenceElement.currentFrame ?? -1
            character.components.set(playbackState)


            brainComponent.animationSequence[0] = animationSequenceElement
            animationComponent.animTime = animTime
            character.components.set(animationComponent)
            character.components.set(brainComponent)
        }
    }
}

private func skipAnimationElementWithIssues(
    for character: Entity,
    characterName: String,
    brainComponent: inout BrainComponent,
    animationSequenceElement: AnimationSequenceElement
) {
    guard animationSequenceElement.isPlaying else { return }

    if animationSequenceElement.animData == nil {
        AppLogger.shared.error("Error: Animation data is still empty for \(characterName) and segment ID \(animationSequenceElement.segmentID ?? "nil").")
        brainComponent.animationSequence.removeFirst()
        return
    }

    if let animData = animationSequenceElement.animData,
       animData.animTimeArray.isEmpty ||
       animData.animTransforms.isEmpty ||
       animData.frameArray.isEmpty
    {
        AppLogger.shared.error("Error: One or more animation data arrays are empty for \(characterName) and segment ID \(animationSequenceElement.segmentID ?? "nil").")

        brainComponent.animationSequence.removeFirst()
    }
}

@MainActor
private func advanceAnimationSequenceIfNeeded(
    for character: Entity,
    brainComponent: inout BrainComponent,
    animationComponent: inout AnimationComponent,
    currentAnimationElement: inout AnimationSequenceElement,
    animTime: Float,
    dataManager: DataManager
) -> (animationSequenceElement: AnimationSequenceElement, animTime: Float)? {

    
    let effectiveStopTime = currentAnimationElement.effectiveStopTime()
    guard animTime >= effectiveStopTime else {
        return nil
    }
    
    let overTime = animTime - effectiveStopTime
    
    var lagElement = currentAnimationElement
    if var lagAnimData = lagElement.animData {
        let cutIdx = lagElement.effectiveEndIndex()   // use sequence‚Äëlevel limits

        lagAnimData.animTransforms = Array(lagAnimData.animTransforms[0...cutIdx])
        lagAnimData.animTimeArray = Array(lagAnimData.animTimeArray[0...cutIdx])
        lagAnimData.frameArray = Array(lagAnimData.frameArray[0...cutIdx])
    
        lagElement.animData = lagAnimData
    }
    animationComponent.lagAnimationSequenceElement = lagElement
    
    brainComponent.animationSequence.removeFirst()
        
    if !brainComponent.animationSequence.isEmpty {
        currentAnimationElement = brainComponent.animationSequence.first!
        
        let frameCount = calculateAnimationElementFrameCount(
            element: currentAnimationElement,
            dataManager: dataManager
        )
            
        if printAnimationSystem {
            AppLogger.shared.anim("üé•  Running .startingNewAnimation case:\nAnimation Sequence is: \(brainComponent.animationSequence.map { "\($0.animationName) from \($0.startPoseFrame) to \($0.endPoseFrame ?? -1)" })\n\n \(currentAnimationElement.description)")
            if let blendTree = currentAnimationElement.blendTree {
                AppLogger.shared.anim(" üé• BLENDING: going to blend \(currentAnimationElement.animationName) with \(blendTree.blendNodes.map { $0.blendElement.animationName })")
                for blendNode in blendTree.blendNodes {
                    let blendInfo = blendNode.blendInfo
                    AppLogger.shared.anim("üé•  for element \(blendNode.blendElement.animationName): totalEffectiveSeriesDuration: \(blendInfo.totalEffectiveSeriesDuration), fromEffectiveSeriesDuration: \(blendInfo.fromEffectiveSeriesDuration), toEffectiveSeriesDuration: \(blendInfo.toEffectiveSeriesDuration)")
                }
            }
        }
        return (currentAnimationElement, overTime)
    } else {
        AppLogger.shared.error("üé• Error: No more animations in sequence")
        return nil
    }
}

==== AnimLibS/Components/CustomAnimationSystem.swift ====

//                    AppLogger.shared.error("Error: SegmentID is nil.")
//                    AppLogger.shared.error("Error: segmentID does not contain enough components.")

==== AnimLibS/Components/AnimationPlaybackStateComponent.swift ====


import CoreLib
import RealityKit

public struct AnimationPlaybackStateComponent: RealityKit.Component {

    public var currentAnimationName: String = ""
    public var currentMoveType: MoveType = .other
    public var currentFrame: Int = -1

    public var debugHUDGenerationSeen: Int = 0

    public var debugHUDLastSignature: String = ""

    public var isIdle: Bool { currentMoveType == .idle }

    public init() {}
}

==== AnimLibS/Components/TravelComponent.swift ====


import AssetLib
import CoreLib
import RealityKit
import simd

public struct TravelComponent: RealityKit.Component {
    var lagAnimationTime: Float = .zero
    
    var lastBoneOnGround: [ExplicitBoneName] = []
        
    var lagTransforms: [ExplicitBoneName: Transform] = [:]
    
    var lagDeltaRotation: [Float] = [] // we are tracking only y axis of the quaternion
    var lagDeltaTranslation: [simd_float3] = []
    
    public init() {}
}

public class TravelSystem: RealityKit.System {
    @MainActor private static let query = animationComponentQuery
    
    @MainActor private static let teraQuery = EntityQuery(where: .has(TeraComponent.self))
    
    public required init(scene: RealityKit.Scene) {}
    
    public static var dependencies: [SystemDependency] { [.after(AnimationSystem.self)] }
    
    public func update(context: SceneUpdateContext) {
        let deltaTime = Float(context.deltaTime)
        
        let terrains = Array(context.entities(matching: Self.teraQuery, updatingSystemWhen: .rendering))
        // check and warn in there is more than one
        guard terrains.count == 1 else {
            AppLogger.shared.error("TravelSystem: Error - more than one terrain entity found, expected only one.")
            return
        }
        
        guard let terrain = terrains.first else {
            AppLogger.shared.error("TravelSystem: Error - terrain entity not found.")
            return
        }
        
        guard
            var teraComponent = terrain.components[TeraComponent.self]
        else {
            AppLogger.shared.error("Error: Failed to get teraComponent")
            return
        }
    
        let travellers = context.entities(matching: Self.query, updatingSystemWhen: .rendering)
        for traveller in travellers {
            guard
                let animComponent = traveller.components[AnimationComponent.self],
                let brainComponent = traveller.components[BrainComponent.self],
                var travelComponent = traveller.components[TravelComponent.self],
                let dataCenterComponent = traveller.components[DataCenterComponent.self]
            else { continue }
            
            if printTravelSystem { AppLogger.shared.anim(" ----- TravelSystem is running for  \(traveller.name) at \((dataCenterComponent.gameTime * 10000).rounded() / 10000) with deltaTime \((context.deltaTime * 10000).rounded() / 10000)-----") }
            
            guard brainComponent.animationSequence.isEmpty == false else {
                AppLogger.shared.error("Error: animationSequence is empty in TravelSystem")
                continue
            }
            

            let boneOnGround = brainComponent.animationSequence[0].startPoseName.groundBone
            
            let deltaTransform = fixFootOnGround(traveller: traveller, travelComponent: &travelComponent, boneOnGround: boneOnGround, gameTime: Float(dataCenterComponent.gameTime))
            
            if printPlot { AppLogger.shared.anim(" Traveller location from TravelSystem: \(traveller.transform.translation)") }
            

            if teraComponent.terrainAttached == true,
                let y = TerrainMeshBuilder.sampledHeight(
                worldX: traveller.transform.translation.x,
                worldZ: traveller.transform.translation.z,
                heightMap: teraComponent.heightMap,
                gridCols: teraComponent.heightMapWidth,
                horizontalSpacing: teraComponent.heightMapSpacing,
                verticalScale: teraComponent.heightMapVerticalScale,
                seaLevel: teraComponent.heightMapSeaLevel,
                parentTransform: teraComponent.terrainEntityTransform
            ) {
                traveller.transform.translation.y = 2.3
            }
            
            
            traveller.components.set(travelComponent)
            traveller.components.set(animComponent)
            
            
            
            let localHead = getLocalJointTransform(entity: traveller, boneName: .head)
            let localLThigh = getLocalJointTransform(entity: traveller, boneName: .leftThigh)
            let localRThigh = getLocalJointTransform(entity: traveller, boneName: .rightThigh)
            let localLFoot = getLocalJointTransform(entity: traveller, boneName: .leftFoot)
            let localRFoot = getLocalJointTransform(entity: traveller, boneName: .rightFoot)
            let localPelvis = getLocalJointTransform(entity: traveller, boneName: .pelvis)
            let localWaist = getLocalJointTransform(entity: traveller, boneName: .waist)

            if printTravelSystem {
                AppLogger.shared.plot("Plot: gameTime: \(dataCenterComponent.gameTime), deltaTime: \(deltaTime), head: \(localHead), lThigh: \(localLThigh), rThigh: \(localRThigh), lFoot: \(localLFoot), rFoot: \(localRFoot), waist: \(localWaist), pelvis: \(localPelvis), isNewSegment: \(brainComponent.isNewSegment)")
            }
        }
    }
}

@MainActor

func fixFootOnGround(
    traveller: Entity,
    travelComponent: inout TravelComponent,
    boneOnGround: ExplicitBoneName,
    gameTime: Float
) -> Transform {
    guard
        let leftFootPath = ExplicitBoneName.leftFoot.fullPath(),
        let rightFootPath = ExplicitBoneName.rightFoot.fullPath(),
        let leftToePath = ExplicitBoneName.leftToeBase.fullPath(),
        let rightToePath = ExplicitBoneName.rightToeBase.fullPath()
    else {
        AppLogger.shared.error("Error: Invalid bone name")
        return .identity
    }
    let identityQuat = simd_quatf(ix: 0, iy: 0, iz: 0, r: 1)

    guard
        let leftFootTransform = getJointWorldTransform(of: leftFootPath, in: traveller),
        let rightFootTransform = getJointWorldTransform(of: rightFootPath, in: traveller),
        let leftToeTransform = getJointWorldTransform(of: leftToePath, in: traveller),
        let rightToeTransform = getJointWorldTransform(of: rightToePath, in: traveller)
    else {
        AppLogger.shared.error("Error: Bone transforms not found for \(traveller.name)")
        return .identity
    }

    let activeTransform: Transform
    switch boneOnGround {
    case .leftFoot: activeTransform = leftFootTransform
    case .rightFoot: activeTransform = rightFootTransform
    case .leftToeBase: activeTransform = leftToeTransform
    case .rightToeBase: activeTransform = rightToeTransform
    default:
        AppLogger.shared.error("Error: Invalid boneOnGround")
        return .identity
    }

    var isSwitching = false
    var lagIsSwitching = false
    if travelComponent.lastBoneOnGround.count >= 2 {
        isSwitching = (boneOnGround != travelComponent.lastBoneOnGround[0])
        lagIsSwitching = (travelComponent.lastBoneOnGround[0] != travelComponent.lastBoneOnGround[1])
    }

    if travelComponent.lagTransforms[boneOnGround] == nil {
        travelComponent.lagTransforms[boneOnGround] = activeTransform
    }
    let usedLagTransform = travelComponent.lagTransforms[boneOnGround] ?? activeTransform

    var deltaRotation = usedLagTransform.rotation != identityQuat
        ? usedLagTransform.rotation * activeTransform.rotation.inverse
        : identityQuat

    deltaRotation = simd_quatf(
        ix: 0,
        iy: deltaRotation.imag.y,
        iz: 0,
        r: deltaRotation.real
    ).normalized

    traveller.orientation *= deltaRotation

    guard
        let activeTransformAfter = getJointWorldTransform(
            of: boneOnGround.fullPath()!,
            in: traveller
        )
    else {
        AppLogger.shared.error("Error: Could not get active transform after rotation for \(traveller.name)")
        return .identity
    }

    let usedLagTranslation = usedLagTransform.translation
    var deltaLocation = activeTransformAfter.translation - usedLagTranslation

    if activeTransformAfter.translation.y > 0.01 {
        deltaLocation.y = min(activeTransformAfter.translation.y, 0.001)
    } else if activeTransformAfter.translation.y < -0.01 {
        deltaLocation.y = max(activeTransformAfter.translation.y, -0.001)
    }
    deltaLocation.y = 0 // enforce foot on ground

    traveller.transform.translation -= deltaLocation

    if travelComponent.lagDeltaTranslation.count >= 2 {
        travelComponent.lagDeltaTranslation.removeLast()
    }
    travelComponent.lagDeltaTranslation.insert(deltaLocation, at: 0)

    if travelComponent.lagDeltaRotation.count >= 2 {
        travelComponent.lagDeltaRotation.removeLast()
    }
    travelComponent.lagDeltaRotation.insert(deltaRotation.imag.y, at: 0)

    for (boneName, _) in travelComponent.lagTransforms {
        if let fullPath = boneName.fullPath() {
            travelComponent.lagTransforms[boneName] =
                getJointWorldTransform(of: fullPath, in: traveller) ?? .identity
        }
    }

    travelComponent.lastBoneOnGround.insert(boneOnGround, at: 0)
    if travelComponent.lastBoneOnGround.count > 2 {
        travelComponent.lastBoneOnGround.removeLast()
    }

    let correction = Transform(scale: .one,
                               rotation: deltaRotation,
                               translation: -deltaLocation)

    return correction
}

//        AppLogger.shared.error("Error: Invalid bone name")
//        AppLogger.shared.error("Error: Bone transforms not found for \(traveller.name)")
//        AppLogger.shared.error("Error: Invalid boneOnGround")
//        AppLogger.shared.error("Error: Could not get active transform after rotation for \(traveller.name)")

func shouldUsePreviousValue(previousCount: Int,
                            isSwitching: Bool,
                            lagIsSwitching: Bool,
                            currentReal: Float? = nil,
                            previousReal: Float? = nil) -> Bool
{
    guard previousCount >= 1 else { return false }
    
    if let curReal = currentReal, let prevReal = previousReal {
        if curReal * prevReal < 0 {
            return false
        }
    }
    
    if isSwitching || lagIsSwitching {
        return true
    }
    
    return false
}

func clampDeltaLocation(_ newDelta: SIMD3<Float>, previousDelta: SIMD3<Float>, allowedChange: SIMD3<Float>) -> SIMD3<Float> {
    var clamped = SIMD3<Float>()
    
    for i in 0 ..< 3 {
        let prev = previousDelta[i]
        let current = newDelta[i]
        
        if Swift.abs(prev) < 0.0001 {
            clamped[i] = current
        } else {
            let lowerBound = Swift.abs(prev) * (1 - allowedChange[i])
            let upperBound = Swift.abs(prev) * (1 + allowedChange[i])
            
            let currentAbs = Swift.abs(current)
            let clampedAbs = min(max(currentAbs, lowerBound), upperBound)
            clamped[i] = copysign(clampedAbs, current)
        }
    }
    
    return clamped
}

func clampDeltaRotation(_ newDelta: simd_quatf,
                        _ prevDelta: simd_quatf?,
                        allowedChange: Float = 0.03, gameTime: Float) -> simd_quatf
{
    guard let prev = prevDelta else {
        return newDelta
    }
    
    let newImagLen = simd_length(newDelta.imag)
    let prevImagLen = simd_length(prev.imag)
    
    if prevImagLen < 0.0001 {
        return newDelta
    }
    
    let lowerBound = Swift.abs(prevImagLen) * (1 - allowedChange)
    let upperBound = Swift.abs(prevImagLen) * (1 + allowedChange)
    
    if newImagLen >= lowerBound, newImagLen <= upperBound {
        return newDelta
    }
    
    let targetLen = (newImagLen > upperBound) ? upperBound : lowerBound
    let scale = (newImagLen > 0.00001) ? (targetLen / newImagLen) : 1.0
    let scaledImag = newDelta.imag * scale
    
    let sq = max(0, 1 - targetLen * targetLen)
    let candidatePos = simd_quatf(vector: SIMD4<Float>(scaledImag.x,
                                                       scaledImag.y,
                                                       scaledImag.z,
                                                       sqrt(sq)))
    let candidateNeg = simd_quatf(vector: SIMD4<Float>(scaledImag.x,
                                                       scaledImag.y,
                                                       scaledImag.z,
                                                       -sqrt(sq)))
    
    let dotPos = simd_dot(candidatePos.vector, prev.vector)
    let dotNeg = simd_dot(candidateNeg.vector, prev.vector)
    let chosenCandidate = dotPos >= dotNeg ? candidatePos : candidateNeg
    
    return simd_normalize(chosenCandidate)
}

==== AnimLibS/Components/EventComponent.swift ====


import CoreLib
import Foundation
import joystickController
import RealityKit

public struct EventComponent: RealityKit.Component {
    var eventCache: [EventCacheElement] = []
    public let dataProvider: JoystickDataProvider
    var travelGuide: TravelGuide = .init()
    var styleGuide: StyleGuide = .init()

    var lastButtonState: Bool = false //    /// `true` while the action button was held *last* frame

    var currentIdleGuideIndex: Int = -1
    var currentWalkGuideIndex: Int = -1

    public init(dataProvider: JoystickDataProvider) {
        self.dataProvider = dataProvider
        self.eventCache = []
        self.travelGuide = TravelGuide()
    }
}

public class EventSystem: RealityKit.System {
    @MainActor private static let query = animationComponentQuery

    public required init(scene: RealityKit.Scene) {}

    public static var dependencies: [SystemDependency] { [.before(BrainSystem.self)] }

    public func update(context: SceneUpdateContext) {
        let characters = context.entities(matching: Self.query, updatingSystemWhen: .rendering)

        for character in characters {
            if printEventSystem {
                AppLogger.shared.anim("========== EventSystem is running for \(character.name) =============")
            }

            guard var eventComponent = character.components[EventComponent.self] else { continue }

            let freshGuide = travelGuideFromJoystick(
                dataProvider: eventComponent.dataProvider,
                entityWorldTransform: character.transform,
                distance: 10
            )

            var mergedGuide = freshGuide
            if !eventComponent.travelGuide.estPathway.isEmpty {
                mergedGuide.estPathway = eventComponent.travelGuide.estPathway
            }
            eventComponent.travelGuide = mergedGuide

            if printEventSystem {
                if let first = mergedGuide.targetDestinations.first {
                    AppLogger.shared.anim("[EventSystem] TravelGuide First destination: inPlace: \(first.inPlace)  |  isNew: \(first.isNew)")
                } else {
                    AppLogger.shared.anim("TravelGuide: no destinations.")
                }
            }

            if let first = mergedGuide.targetDestinations.first {
                let currentTarget = eventComponent.styleGuide.targets.first
                let currentMoveType = currentTarget?.moveType

                let needsIdleStyle = first.inPlace
                let needsWalkStyle = !first.inPlace

                let shouldSetDefault = (currentTarget == nil) ||
                                       (needsIdleStyle && currentMoveType != .idle) ||
                                       (needsWalkStyle && currentMoveType != .walk)

                if shouldSetDefault {
                    let baseAnim = first.inPlace ? defaultIdleAnimation : defaultWalkAnimation
                    let moveType: MoveType = first.inPlace ? .idle : .walk

                    eventComponent.styleGuide = StyleGuide(targets: [
                        StyleTarget(style: "default",
                                    baseAnimName: baseAnim,
                                    isNew: true,
                                    moveType: moveType)
                    ])
                }
            }

            setAnimationStyleWithAIIdleSuggestion(
                eventComponent: &eventComponent,
                dataProvider: eventComponent.dataProvider
            )

            setAnimationStyleWithButton(
                styleGuides: styleGuides,
                eventComponent: &eventComponent,
                dataProvider: eventComponent.dataProvider
            )

            character.components.set(eventComponent)
        }
    }
}

struct EventCacheElement {
    let eventName: String
    let eventGameTime: Double
    let isNew: Bool
}

func MarkAllEventsOld(for eventComponent: inout EventComponent) {
    guard eventComponent.eventCache.last != nil else {
        if printEventSystem { AppLogger.shared.anim("No events to update.") }
        return
    }

    eventComponent.eventCache = eventComponent.eventCache.map { event in
        EventCacheElement(eventName: event.eventName, eventGameTime: event.eventGameTime, isNew: false)
    }
}

==== AnimLibS/Components/SkeletalPosesSystem.swift ====

//                AppLogger.shared.error("Error: Missing SkeletalPosesComponent for \(characterName)")
//                AppLogger.shared.error("Error: Missing bonePosesComponent or DataCenterComponent for \(characterName)")
//                    AppLogger.shared.error("Error: No transform data found for animationName: \(defaultAnimation)")
//                AppLogger.shared.error("Error: Animation arrays are empty for \(characterName)")
//                AppLogger.shared.error("Error: Failed to calculate current transform for \(characterName)")
//                AppLogger.shared.error("Error: Could not create skeletal pose for \(characterName)")

==== AnimLibS/SettingsAndDataStructs/AnimationSettings.swift ====

import CoreLib
import Foundation
import RealityKit
import simd



let frameRate: Float = 60

let minSequenceLengthFrames = 120

let minBlendingFrameCount: Float = 15

let withinEndFrameCount = 3


let dataExportJsonPath = "/Users/nata/GitHub/NextTaleApp/NataRestart/ExportData/exportFromXCode.json"

let systemWideSpeedMultiplier: Float = 1


let printEventSystem = false
let printBrainSystem = false
let printAnimationSystem = false
let printTravelSystem = false
let printPlot = false // required printTravelSystem = true


let defaultAnimation =  "01001_1_Move_WalkFast_M" //"01001_7_Move_WalkSlow_M_2L"//"01003_2_02_Relax_Walk"  // "01003_5_20_Thinking_Walk"

let defaultIdleAnimation = "01001_2_Stand_Looking_M"
let defaultWalkAnimation = "01001_7_Move_WalkSlow_M_2L"

@MainActor let mustFinishMoveTypes: [MoveType] = [.transition]

@MainActor let startTransitionPoseTypeForWalk: PoseType = .low

let footRollAngleMin = Float.pi/6
let footRollAngleMax = Float.pi * 2/3
let footRollQuatMin = simd_quatf(angle: footRollAngleMin, axis: SIMD3<Float>(1, 0, 0)) // 30 degrees = pi / 6
let footRollQuatMax = simd_quatf(angle: footRollAngleMax, axis: SIMD3<Float>(1, 0, 0)) // 120 degrees = pi * 2/3

let calfRollQuatMax = simd_quatf(angle: -Float.pi/36, axis: SIMD3<Float>(1, 0, 0)) // -5 degrees = -pi/36 radians
let calfRollQuatMaxForLiftedFoot = simd_quatf(angle: -Float.pi/18, axis: SIMD3<Float>(1, 0, 0)) // -10 degrees = -pi/18 radians

let raiseOtherToebaseBy: SIMD3<Float> = .init(0, 0, 1)


let identityTransform = Transform(
    scale: SIMD3<Float>(1, 1, 1), // No scaling
    rotation: simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0)), // No rotation
    translation: SIMD3<Float>(0, 0, 0) // No translation
)

@MainActor public let animationComponentQuery = EntityQuery(where:
    .has(BrainComponent.self) &&
        .has(TravelComponent.self) &&
        .has(AnimationComponent.self)
)

==== AnimLibS/SettingsAndDataStructs/SequenceData.swift ====


import CoreLib
import RealityKit

struct AnimData: Equatable {
    var animTransforms: [[Transform]] = []
    var animTimeArray: [Float] = []
    var frameArray: [Int] = []

    func effectiveStartIndex(lateStartFrame: Int?) -> Int {
        guard let start = lateStartFrame,
              let idx = frameArray.firstIndexGE(to: start)
        else { return 0 }
        return idx
    }

    func effectiveStartTime(lateStartFrame: Int?) -> Float {
        guard !animTimeArray.isEmpty else { return 0 }
        return animTimeArray[effectiveStartIndex(lateStartFrame: lateStartFrame)]
    }

    func effectiveEndIndex(earlyStopFrame: Int?) -> Int {
        guard let stop = earlyStopFrame,
              let idx = frameArray.lastIndexLE(to: stop)
        else { return max(frameArray.count - 1, 0) }
        return idx
    }

    func effectiveStopTime(earlyStopFrame: Int?) -> Float {
        guard !animTimeArray.isEmpty else { return 0 }
        return animTimeArray[effectiveEndIndex(earlyStopFrame: earlyStopFrame)]
    }
}

struct AnimationSequenceElement: Equatable {
    var animationName: String
    var startPoseName: CriticalPoseName
    var startPoseFrame: Int
    let startPoseIndex: Int
    let startPoseID: Int?
    var endPoseName: CriticalPoseName
    var endPoseFrame: Int?
    let endPoseIndex: Int?
    let endPoseID: Int?
    var currentFrame: Int?
    var isPlaying: Bool
    var speed: Float
    var segmentID: String?
    var animData: AnimData?
    var earlyStopFrame: Int?
    var lateStartFrame: Int?
    var blendTree: BlendTree?
    var isFilledOut: Bool
    var isReadyToPlay: Bool = false
    var frameInterval: Float = 1.0 / frameRate
    var animAlteration: AnimAlteration?
    var inertialUnits: [InertialUnit]?
    var deltaLocation: SIMD3<Float>?
    var deltaRotation: simd_quatf?

    private var blendInfoInSourcesDescription: String {
        guard let sourceElements = blendTree?.blendNodes else {
            return "blendTree or sourceElements is nil."
        }
        return sourceElements.enumerated()
            .map { "BlendInfoInSource \($0.offset + 1): jointIndices \($0.element.blendInfo.jointIndices != nil ? "present" : "not present")" }
            .joined(separator: "\n")
    }

    var description: String {
        var lines: [String] = []

        lines.append("AnimationSequenceElement:")
        lines.append("  ‚Ä¢ Animation Name: \(animationName)")
        lines.append("  ‚Ä¢ Start Pose: \(startPoseName)[\(startPoseFrame)] (index \(startPoseIndex))")
        lines.append("  ‚Ä¢ End Pose: \(endPoseName)[\(endPoseFrame ?? 0)] (index \(endPoseIndex ?? -1))")
        lines.append("  ‚Ä¢ Early Stop Frame: \(earlyStopFrame ?? -1)")
        lines.append("  ‚Ä¢ Late Start Frame: \(lateStartFrame ?? -1)")
        lines.append("  ‚Ä¢ Playing: \(isPlaying), Speed: \(speed)")
        lines.append("  ‚Ä¢ Segment ID: \(segmentID ?? "N/A")")
        lines.append("  ‚Ä¢ Blend Tree Nodes: \((blendTree?.blendNodes.count).map { "\($0)" } ?? "N/A")")
        lines.append("  ‚Ä¢ Filled Out: \(isFilledOut)")

        if let alteration = animAlteration {
            lines.append("  ‚Ä¢ Anim Alteration:")
            if let cir = alteration.walkCircleAlteration {
                lines.append("      ‚Äì Walk‚ÄëCircle Degree: \(cir.cirWalkDegree ?? 0)¬∞")
                lines.append("      ‚Äì Start Altered: \(cir.startIsAltered)")
                lines.append("      ‚Äì End Altered: \(cir.endIsAltered)")
            } else {
                lines.append("      ‚Äì Walk‚ÄëCircle: none")
            }
            if let stride = alteration.strideLength {
                lines.append("      ‚Äì Stride Length: \(stride)")
            }
            if let match = alteration.matchTransformAlteration {
                lines.append("      ‚Äì Match Transform Alteration:")
                lines.append("        ‚Ä¢ Start Reference Animation: \(match.startPoseMatch?.startReferenceAnimFrameDict.animationName ?? "none")[\(String(describing: match.startPoseMatch?.startReferenceAnimFrameDict.frame))]")
                lines.append("        ‚Ä¢ End Reference Animation: \(match.endPoseMatch?.endReferenceAnimFrameDict.animationName ?? "none")[\(match.endPoseMatch?.endReferenceAnimFrameDict.frame)]")
            } else {
                lines.append("      ‚Äì Match Transform: none")
            }
        } else {
            lines.append("  ‚Ä¢ Anim Alteration: none")
        }

        if let units = inertialUnits, !units.isEmpty {
            lines.append("  ‚Ä¢ Inertial Units (\(units.count)):")
            for (i, unit) in units.enumerated() {
                lines.append("      Unit \(i + 1):")
                if let boneIndices = unit.boneIndices, !boneIndices.isEmpty {
                    let bonesDesc = boneIndices.map { "\($0)" }.joined(separator: ", ")
                    lines.append("        ‚Äì Bone Indices: [\(bonesDesc)]")
                } else {
                    lines.append("        ‚Äì Bone Indices: all")
                }
                lines.append("        ‚Äì Blend Frames: \(unit.blendFrames)")
                lines.append("        ‚Äì Reverse: \(unit.isReverse)")
            }
        } else {
            lines.append("  ‚Ä¢ Inertial Units: none")
        }

        return lines.joined(separator: "\n")
    }

    func effectiveStartIndex() -> Int {
        guard let data = animData else { return 0 }
        return data.effectiveStartIndex(lateStartFrame: lateStartFrame)
    }

    func effectiveEndIndex() -> Int {
        guard let data = animData else { return 0 }
        return data.effectiveEndIndex(earlyStopFrame: earlyStopFrame)
    }

    func effectiveStartTime() -> Float {
        guard let data = animData else { return 0 }
        return data.effectiveStartTime(lateStartFrame: lateStartFrame)
    }

    func effectiveStopTime() -> Float {
        guard let data = animData else { return 0 }
        return data.effectiveStopTime(earlyStopFrame: earlyStopFrame)
    }

    func effectiveStartFrame() -> Int {
        lateStartFrame ?? startPoseFrame
    }

    func effectiveEndFrame() -> Int? {
        earlyStopFrame ?? endPoseFrame
    }

    mutating func prepareForLateStartTrim(_ element: inout AnimationSequenceElement) {
        guard
            let lateStart = element.lateStartFrame,
            var data = element.animData,
            let cutIdx = data.frameArray.firstIndex(where: { $0 >= lateStart })
        else { return } // nothing to do

        data.animTransforms.removeFirst(cutIdx)
        data.frameArray.removeFirst(cutIdx)

        let offset = data.animTimeArray[cutIdx]
        data.animTimeArray = Array(data.animTimeArray.dropFirst(cutIdx)).map { $0 - offset }

        element.animData = data
        element.lateStartFrame = nil
    }
}

enum BlendWeightType: Equatable {
    case increasing
    case decreasing
    case fixedAt100
    case fixedAt0
    case fixedAt50
    case fixedAt(Float)

    var validatedFixedValue: Float? {
        if case let .fixedAt(value) = self {
            return (0 ... 1).contains(value) ? value : nil
        }
        return nil
    }
}

struct BlendInfo: Equatable {
    var jointIndices: [Int]? // joint indices affected by animation. If nil, then all are affected
    var ownBlendWeightType: BlendWeightType
    var otherBlendWeightType: BlendWeightType
    let isAdditive: Bool
    let blendFunction: BlendFunctionNames
    var blendType: BlendType
    let fromEffectiveSeriesDuration: Double
    let toEffectiveSeriesDuration: Double
    var totalEffectiveSeriesDuration: Double
}

struct BlendTree: Equatable {
    var blendNodes: [BlendNode]
}

struct BlendNode: Equatable {
    var blendElement: AnimationSequenceElement
    var blendInfo: BlendInfo
}

struct AnimAlteration: Equatable {
    var walkCircleAlteration: WalkCircleAlteration?
    var strideLength: Float?
    var matchTransformAlteration: MatchTransformAlteration?
}

struct WalkCircleAlteration: Equatable {
    var cirWalkDegree: Float?
    var cirCoreBlendInfo: BlendInfo?
    var cirNonCoreBlendInfo: BlendInfo?
    var cirBlendInfo: BlendInfo?
    var startIsAltered: Bool {
        guard let degree = cirWalkDegree, degree != 0 else { return false }

        let infos = [cirCoreBlendInfo, cirNonCoreBlendInfo, cirBlendInfo]

        if infos.allSatisfy({ $0 == nil }) {
            return true
        }

        let isUnaltered = infos.compactMap { $0 }.allSatisfy {
            ($0.ownBlendWeightType == .increasing && $0.fromEffectiveSeriesDuration == 0)
                || $0.ownBlendWeightType == .fixedAt0
        }

        return !isUnaltered
    }

    var endIsAltered: Bool {
        guard let degree = cirWalkDegree, degree != 0 else { return false }

        let infos = [cirCoreBlendInfo, cirNonCoreBlendInfo, cirBlendInfo]

        if infos.allSatisfy({ $0 == nil }) {
            return false
        }

        let isUnaltered = infos.compactMap { $0 }.allSatisfy {
            ($0.ownBlendWeightType == .decreasing && $0.toEffectiveSeriesDuration == $0.totalEffectiveSeriesDuration)
                || $0.ownBlendWeightType == .fixedAt0
        }

        return !isUnaltered
    }
}

struct MatchTransformAlteration: Equatable {
    let startPoseMatch: PoseMatchTransformAlteration?
    let endPoseMatch: PoseMatchTransformAlteration?
}

struct PoseMatchTransformAlteration: Equatable {
    let startReferenceAnimFrameDict: AnimFrameDict
    let endReferenceAnimFrameDict: AnimFrameDict
    let poseAdjustment: PoseAdjustment
    let baseSide: Side // usually weight-leaning side
    let referenceTransformType: StartEndType
    let sideFootRotationType: StartEndType
    let otherSideFootRotationType: StartEndType
}

struct AnimFrameDict: Equatable {
    let animationName: String
    let frame: Int
}

struct InertialUnit: Equatable {
    var boneIndices: [Int]? // <-  if nill then all bones
    var blendFrames: Int // count of frames over blending interval (starting with ultimate start or end)
    var isReverse: Bool
}

private extension Array where Element == Int {
    func firstIndexGE(to x: Int) -> Int? { firstIndex(where: { $0 >= x }) }
    func lastIndexLE(to x: Int) -> Int? { lastIndex(where: { $0 <= x }) }
}

==== AnimLibS/SettingsAndDataStructs/StyleGuide.swift ====


import CoreLib

public enum FlashAIIdleEmoteOptions {
    public static let animationNames: [String] = [
        "01011_3_EmotionalR-Salute_M",
        "01012_1_Emotes-Lose_Turn_Around",
        "01012_2_Emotes-Ponder"
    ]
}

struct StyleGuide {
    var targets: [StyleTarget] = [
        .init(style: "default",
              baseAnimName: "01003_2_02_Relax_Walk",
              isNew: false,
              moveType: .walk)
    ]
}

struct StyleTarget {
    var style: String
    var animationName: String
    var isNew: Bool
    var moveType: MoveType

    init(style: String, baseAnimName: String, isNew: Bool, moveType: MoveType = .walk) {
        self.style = style
        self.animationName = baseAnimName
        self.isNew = isNew
        self.moveType = moveType
    }
}

@MainActor
let styleGuides: [StyleGuide] = [
    StyleGuide(targets: [
        .init(style: "default", baseAnimName: "01003_5_20_Thinking_Walk", isNew: false, moveType: .walk)
    ]),
    StyleGuide(targets: [
        .init(style: "default", baseAnimName: "01003_2_02_Relax_Walk", isNew: false, moveType: .walk)
    ]),
    StyleGuide(targets: [
        .init(style: "default", baseAnimName: "01001_1_Move_WalkFast_M", isNew: false, moveType: .walk)
    ]),

    StyleGuide(targets: [
        .init(style: "default", baseAnimName: "01001_2_Stand_Looking_M", isNew: false, moveType: .idle)
    ]),
    StyleGuide(targets: [
        .init(style: "default", baseAnimName: "01001_3_Stand_Listen_M", isNew: false, moveType: .idle)
    ])

] + FlashAIIdleEmoteOptions.animationNames.map { animName in
    StyleGuide(targets: [
        .init(style: "ai_idle_emote", baseAnimName: animName, isNew: false, moveType: .idle)
    ])
}

==== AnimLibS/SettingsAndDataStructs/TravelGuide.swift ====

import CoreLib
import joystickController
import simd

struct TravelGuide {
    var targetDestinations: [TravelTarget] = [] //  this is what we want to achieve.
    var estPathway: [TravelTarget] = [] //calculated based on available animations. Way-points expressed in world coordinates.

    var isNewDestination: Bool {
        return targetDestinations.contains(where: { $0.isNew })
    }

    var veerOffPathDeltaThreshold: Float = 0.1
    var radiusThreshold: Float = 4
}

extension TravelGuide {
    func constructPathwayCurve() -> [SIMD3<Float>] {
        guard let startLocation = targetDestinations.first?.location else { return [] }
        var curvePoints: [SIMD3<Float>] = []
        for target in targetDestinations {
            guard let loc = target.location else { continue }
            if simd_length(loc - startLocation) > radiusThreshold {
                break
            }
            curvePoints.append(loc)
        }
        return curvePoints
    }
    
    func distanceToPathway(from point: SIMD3<Float>) -> (distance: Float, projection: SIMD3<Float>) {
        let curvePoints = constructPathwayCurve()
        
        guard !curvePoints.isEmpty else {
            return (simd_length(point), SIMD3<Float>(repeating: 0))
        }
        
        if curvePoints.count == 1 {
            let singlePoint = curvePoints[0]
            return (simd_length(point - singlePoint), singlePoint)
        }
        
        func distanceFromPointToSegment(point: SIMD3<Float>, a: SIMD3<Float>, b: SIMD3<Float>) -> (distance: Float, projection: SIMD3<Float>) {
            let ab = b - a
            let t = simd_dot(point - a, ab) / simd_dot(ab, ab)
            let clampedT = max(0, min(1, t))
            let proj = a + clampedT * ab
            let dist = simd_length(point - proj)
            return (dist, proj)
        }
        
        var minDistance: Float = .greatestFiniteMagnitude
        var bestProjection = SIMD3<Float>(repeating: 0)
        
        for i in 0 ..< (curvePoints.count - 1) {
            let a = curvePoints[i]
            let b = curvePoints[i + 1]
            let result = distanceFromPointToSegment(point: point, a: a, b: b)
            if result.distance < minDistance {
                minDistance = result.distance
                bestProjection = result.projection
            }
        }
        return (minDistance, bestProjection)
    }
    
    func calculatePathCorrectionQuaternion(endLocation: SIMD3<Float>) -> simd_quatf {
        let (minDistance, bestProjection) = distanceToPathway(from: endLocation)
        let threshold = veerOffPathDeltaThreshold
        
        if minDistance > threshold {
            let fromVector = simd_normalize(endLocation)
            let toVector = simd_normalize(bestProjection)
            let dotProd = simd_dot(fromVector, toVector)
            let clampedDot = max(-1, min(1, dotProd))
            let angle = acos(clampedDot)
            if angle.isNaN || angle < 0.0001 {
                return simd_quatf(angle: 0, axis: SIMD3<Float>(0, 0, 1))
            } else {
                let axis = simd_normalize(simd_cross(fromVector, toVector))
                return simd_quatf(angle: angle, axis: axis)
            }
        } else {
            return simd_quatf(angle: 0, axis: SIMD3<Float>(0, 0, 1))
        }
    }
    
    func distanceAfterPathCorrection(location: SIMD3<Float>, using correctionQuaternion: simd_quatf) -> Float {
        let rotationMatrix = simd_matrix3x3(correctionQuaternion)
        let correctedLocation = rotationMatrix * location
        let (distanceAfterCorrection, _) = distanceToPathway(from: correctedLocation)
        return distanceAfterCorrection
    }
}

struct TravelTarget {
    var priority: Double = 0.5
    var urgency: Double = 0.5
    var inPlace: Bool = true
    var location: SIMD3<Float>?
    var rotation: simd_quatf?
    
    var areaScope: areaScope = .point
    var isTransit: Bool = false
    var id: String?
    var isNew: Bool = false
    
    init(priority: Double = 0.5,
         urgency: Double = 0.5,
         inPlace: Bool = true,
         location: SIMD3<Float>,
         rotation: simd_quatf,
         areaScope: areaScope = .point,
         isTransit: Bool = false,
         id: String,
         isNew: Bool = false)
    {
        self.priority = priority
        self.urgency = urgency
        self.inPlace = inPlace
        self.location = location
        self.rotation = rotation
        self.areaScope = areaScope
        self.isTransit = isTransit
        self.id = id
        self.isNew = isNew
    }

    init(priority: Double = 0.5,
         urgency: Double = 0.5,
         inPlace: Bool = true,
         areaScope: areaScope = .point,
         isTransit: Bool = false,
         isNew: Bool = false)
    {
        self.priority = priority
        self.urgency = urgency
        self.inPlace = inPlace
        self.areaScope = areaScope
        self.isTransit = isTransit
        self.id = nil
        self.location = nil
        self.rotation = nil
        self.isNew = isNew
    }
    
    enum areaScope {
        case point
        case circle
        case rectangle
    }
}

==== MatheMagicApp/Top-Level/MatheMagicApp.swift ====


import AnimLib
import AssetLib
import CoreLib
import RealityKit
import SwiftUI

@main
struct FantasyAppGithubApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    private let teraStore: TeraModelDictionaryActor
    @StateObject private var gameModelView: GameModelView

    init() {
        let store = TeraModelDictionaryActor()
        let gmv = GameModelView(teraStore: store)

        self.teraStore = store
        _gameModelView = StateObject(wrappedValue: gmv)

        MoveComponent.registerComponent()
        TapComponent.registerComponent()
        CameraRotationComponent.registerComponent()

        MoveSystem.registerSystem()
        TapSystem.registerSystem()
        CameraRotationSystem.registerSystem()

        DataCenterComponent.registerComponent()
        DataCenterSystem.registerSystem()

        EventComponent.registerComponent()
        BrainComponent.registerComponent()
        AnimationComponent.registerComponent()
        AnimationPlaybackStateComponent.registerComponent()
        TravelComponent.registerComponent()

        EventSystem.registerSystem()
        BrainSystem.registerSystem()
        AnimationSystem.registerSystem()
        TravelSystem.registerSystem()

        TeraSystem.configure(with: teraStore)
        TeraSystem.registerSystem()

        AppLogger.shared.clockTimeProvider = { [weak gmv] in
            gmv?.clockTime ?? 0
        }

        MoveSystem.gameModelView = gmv
        TapSystem.gameModelView = gmv
        CameraRotationSystem.gameModelView = gmv
    }

    var body: some SwiftUI.Scene {
        WindowGroup {
            ContentView()
                .environmentObject(gameModelView)
                .environment(\.teraStore, teraStore)
        }
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func applicationShouldTerminateAfterLastWindowClosed(_ sender: UIApplication) -> Bool {
        return true
    }
}

==== MatheMagicApp/Views/Scene Functions/setupCharacterWithComponents.swift ====

import AnimLib
import CoreLib
import RealityKit


@MainActor func setupCharacterWithComponents(
    entityDictionaryID: String,
    gameModelView: GameModelView
) -> Entity {
    var entity = Entity()
    if let template = entityModelDictionaryCore[entityDictionaryID] {
        entity = template.entity

        entity.components[EventComponent.self] = EventComponent(dataProvider: gameModelView) // ERROR: Cannot find 'gameModelView' in scope

        if let dataManager = template.dataManager {
            entity.components[DataCenterComponent.self] = DataCenterComponent(dataManager: dataManager)
        }

        entity.components[BrainComponent.self] = BrainComponent()

        entity.components[TravelComponent.self] = TravelComponent()

        entity.components.set(AnimationComponent())

    } else { AppLogger.shared.error("Error: did not find \(entityDictionaryID) key in entityTemplateDictionary") }
    return entity
}
